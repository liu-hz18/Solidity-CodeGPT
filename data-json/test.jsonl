{"comment": "finalize a succcesful crowdsale .", "function": "function finalize ( ) public in state ( state . success ) only owner stop in emergency { if ( finalized ) { throw ; } if ( address ( finalize agent ) != address ( NUM_ ) ) { finalize agent . finalize crowdsale ( ) ; } finalized = BOOL_ ; }", "signature": "function finalize ( ) public in state ( state . success ) only owner stop in emergency", "body": "if ( finalized ) { throw ; } if ( address ( finalize agent ) != address ( NUM_ ) ) { finalize agent . finalize crowdsale ( ) ; } finalized = BOOL_ ;"}
{"comment": "true if the transaction can buy tokens .", "function": "function valid purchase ( ) internal constant returns ( bool ) { bool within period = now >= start time && now <= end time ; bool non zero purchase = msg . value != NUM_ ; bool within contribution limit = msg . value >= minimum contribution && msg . value <= maximum contribution ; return within period && non zero purchase && within contribution limit ; }", "signature": "function valid purchase ( ) internal constant returns ( bool )", "body": "bool within period = now >= start time && now <= end time ; bool non zero purchase = msg . value != NUM_ ; bool within contribution limit = msg . value >= minimum contribution && msg . value <= maximum contribution ; return within period && non zero purchase && within contribution limit ;"}
{"comment": "add whitelisted amount .", "function": "function owner add to whitelist ( address participant , uint256 value ) external only owner { add to whitelist ( participant , value ) ; }", "signature": "function owner add to whitelist ( address participant , uint256 value ) external only owner", "body": "add to whitelist ( participant , value ) ;"}
{"comment": "function that will determine how many tokens have be create .", "function": "function tokens purchased ( ) internal constant returns ( uint ) { return rate . mul ( msg . value ) . mul ( NUM_ ) . div ( NUM_ ether ) ; }", "signature": "function tokens purchased ( ) internal constant returns ( uint )", "body": "return rate . mul ( msg . value ) . mul ( NUM_ ) . div ( NUM_ ether ) ;"}
{"comment": "remaining tokens withdrawal .", "function": "function withdraw tokens ( ) external only owner after crowdsale { uint256 tokens_remaining = token . balance of ( address ( this ) ) ; token . transfer ( owner , tokens_remaining ) ; }", "signature": "function withdraw tokens ( ) external only owner after crowdsale", "body": "uint256 tokens_remaining = token . balance of ( address ( this ) ) ; token . transfer ( owner , tokens_remaining ) ;"}
{"comment": "function to get current latium balance of this contract .", "function": "function _tokens to sell ( ) private returns ( uint256 tokens to sell ) { return _latium . balance of ( address ( this ) ) ; }", "signature": "function _tokens to sell ( ) private returns ( uint256 tokens to sell )", "body": "return _latium . balance of ( address ( this ) ) ;"}
{"comment": "after a player act we might need to reduce the number of remain time periods .", "function": "function update player time periods ( go board storage board , player color color , uint8 time periods used ) internal { if ( color == player color . black ) { board . black periods remaining = board . black periods remaining > time periods used ? board . black periods remaining - time periods used : NUM_ ; } else if ( color == player color . white ) { board . white periods remaining = board . white periods remaining > time periods used ? board . white periods remaining - time periods used : NUM_ ; } else { revert ( ) ; } }", "signature": "function update player time periods ( go board storage board , player color color , uint8 time periods used ) internal", "body": "if ( color == player color . black ) { board . black periods remaining = board . black periods remaining > time periods used ? board . black periods remaining - time periods used : NUM_ ; } else if ( color == player color . white ) { board . white periods remaining = board . white periods remaining > time periods used ? board . white periods remaining - time periods used : NUM_ ; } else { revert ( ) ; }"}
{"comment": "transfer the specified amount to the target address erc-20 standard .", "function": "function transfer ( address _to , uint256 _value ) external is running no freeze returns ( bool success ) { bytes memory empty ; if ( _to == self address ) { return transfer to self ( _value ) ; } else if ( is contract ( _to ) ) { return transfer to contract ( _to , _value , empty ) ; } else { return transfer to address ( _to , _value ) ; } }", "signature": "function transfer ( address _to , uint256 _value ) external is running no freeze returns ( bool success )", "body": "bytes memory empty ; if ( _to == self address ) { return transfer to self ( _value ) ; } else if ( is contract ( _to ) ) { return transfer to contract ( _to , _value , empty ) ; } else { return transfer to address ( _to , _value ) ; }"}
{"comment": "crowdsale external interface .", "function": "function allocate remaining tokens ( ) only owner public { uint256 remaining = token . balance of ( this ) ; token . transfer ( owner , remaining ) ; }", "signature": "function allocate remaining tokens ( ) only owner public", "body": "uint256 remaining = token . balance of ( this ) ; token . transfer ( owner , remaining ) ;"}
{"comment": "required for erc-721 compliance .", "function": "function name ( ) public pure returns ( string ) { return name ; }", "signature": "function name ( ) public pure returns ( string )", "body": "return name ;"}
{"comment": "public function player submit bet only if game be active bet be valid .", "function": "function player make bet ( uint min roll limit , uint max roll limit , bytes32 dice roll hash , uint8 v , bytes32 r , bytes32 s ) public payable game is active bet is valid ( msg . value , min roll limit , max roll limit ) { if ( player bet dice roll hash [ dice roll hash ] != NUM_ || dice roll hash == NUM_ ) throw ; temp bet hash = sha256 ( dice roll hash , byte ( min roll limit ) , byte ( max roll limit ) , msg . sender ) ; if ( casino != ecrecover ( temp bet hash , v , r , s ) ) throw ; temp fullprofit = get full profit ( msg . value , min roll limit , max roll limit ) ; player profit [ dice roll hash ] = get profit ( msg . value , temp fullprofit ) ; if ( player profit [ dice roll hash ] > max profit ) throw ; player to jackpot [ dice roll hash ] = get to jackpot ( msg . value ) ; jackpot = safe add ( jackpot , player to jackpot [ dice roll hash ] ) ; contract balance = safe sub ( contract balance , player to jackpot [ dice roll hash ] ) ; player bet dice roll hash [ dice roll hash ] = dice roll hash ; player min roll limit [ dice roll hash ] = min roll limit ; player max roll limit [ dice roll hash ] = max roll limit ; player bet value [ dice roll hash ] = msg . value ; player address [ dice roll hash ] = msg . sender ; max pending payouts = safe add ( max pending payouts , player profit [ dice roll hash ] ) ; if ( max pending payouts >= contract balance ) throw ; log bet ( dice roll hash , player address [ dice roll hash ] , player profit [ dice roll hash ] , player to jackpot [ dice roll hash ] , player bet value [ dice roll hash ] , player min roll limit [ dice roll hash ] , player max roll limit [ dice roll hash ] ) ; }", "signature": "function player make bet ( uint min roll limit , uint max roll limit , bytes32 dice roll hash , uint8 v , bytes32 r , bytes32 s ) public payable game is active bet is valid ( msg . value , min roll limit , max roll limit )", "body": "if ( player bet dice roll hash [ dice roll hash ] != NUM_ || dice roll hash == NUM_ ) throw ; temp bet hash = sha256 ( dice roll hash , byte ( min roll limit ) , byte ( max roll limit ) , msg . sender ) ; if ( casino != ecrecover ( temp bet hash , v , r , s ) ) throw ; temp fullprofit = get full profit ( msg . value , min roll limit , max roll limit ) ; player profit [ dice roll hash ] = get profit ( msg . value , temp fullprofit ) ; if ( player profit [ dice roll hash ] > max profit ) throw ; player to jackpot [ dice roll hash ] = get to jackpot ( msg . value ) ; jackpot = safe add ( jackpot , player to jackpot [ dice roll hash ] ) ; contract balance = safe sub ( contract balance , player to jackpot [ dice roll hash ] ) ; player bet dice roll hash [ dice roll hash ] = dice roll hash ; player min roll limit [ dice roll hash ] = min roll limit ; player max roll limit [ dice roll hash ] = max roll limit ; player bet value [ dice roll hash ] = msg . value ; player address [ dice roll hash ] = msg . sender ; max pending payouts = safe add ( max pending payouts , player profit [ dice roll hash ] ) ; if ( max pending payouts >= contract balance ) throw ; log bet ( dice roll hash , player address [ dice roll hash ] , player profit [ dice roll hash ] , player to jackpot [ dice roll hash ] , player bet value [ dice roll hash ] , player min roll limit [ dice roll hash ] , player max roll limit [ dice roll hash ] ) ;"}
{"comment": "fail-safe token transfer .", "function": "function token drain ( ) external only owner ( ) { if ( block . number > end block ) { require ( token . transfer ( multisig , token . balance of ( this ) ) ) ; } }", "signature": "function token drain ( ) external only owner ( )", "body": "if ( block . number > end block ) { require ( token . transfer ( multisig , token . balance of ( this ) ) ) ; }"}
{"comment": "creates and begin a new sale .", "function": "function _create sale ( uint256 _token id , uint256 _starting price , uint256 _ending price , uint256 _duration , address _seller ) internal { sale memory sale = sale ( _seller , _starting price , _ending price , _duration , now , [ _token id , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ ] ) ; _add sale ( _token id , sale ) ; }", "signature": "function _create sale ( uint256 _token id , uint256 _starting price , uint256 _ending price , uint256 _duration , address _seller ) internal", "body": "sale memory sale = sale ( _seller , _starting price , _ending price , _duration , now , [ _token id , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ ] ) ; _add sale ( _token id , sale ) ;"}
{"comment": "some helper / info getter function .", "function": "function get contract owner ( ) external view returns ( address ) { return owner address ; }", "signature": "function get contract owner ( ) external view returns ( address )", "body": "return owner address ;"}
{"comment": "implicitly call spend - if both signatures have sign we then spend .", "function": "function spendlarge ( uint256 _to , uint256 _main , uint256 _fraction ) public returns ( bool valid ) { require ( _to != NUM_ ) ; require ( _main <= max_daily_cosign_send ) ; require ( _fraction < ( whole_ether / fraction_ether ) ) ; require ( tx . gasprice <= gas_price_limit ) ; sendsignature ( ) ; uint256 current time = block . timestamp ; uint256 valid1 = NUM_ ; uint256 valid2 = NUM_ ; if ( block . timestamp - m signatures [ contract_signature1 ] < cosign_max_time ) { m amount1 = _main * whole_ether + _fraction * fraction_ether ; valid1 = NUM_ ; } if ( block . timestamp - m signatures [ contract_signature2 ] < cosign_max_time ) { m amount2 = _main * whole_ether + _fraction * fraction_ether ; valid2 = NUM_ ; } if ( valid1 == NUM_ && valid2 == NUM_ ) { require ( ( current time - m last spend [ msg . sender ] ) > day_length ) ; if ( m amount1 == m amount2 ) { address ( _to ) . transfer ( m amount1 ) ; valid1 = NUM_ ; valid2 = NUM_ ; m amount1 = NUM_ ; m amount2 = NUM_ ; endsigning ( ) ; return BOOL_ ; } } return BOOL_ ; }", "signature": "function spendlarge ( uint256 _to , uint256 _main , uint256 _fraction ) public returns ( bool valid )", "body": "require ( _to != NUM_ ) ; require ( _main <= max_daily_cosign_send ) ; require ( _fraction < ( whole_ether / fraction_ether ) ) ; require ( tx . gasprice <= gas_price_limit ) ; sendsignature ( ) ; uint256 current time = block . timestamp ; uint256 valid1 = NUM_ ; uint256 valid2 = NUM_ ; if ( block . timestamp - m signatures [ contract_signature1 ] < cosign_max_time ) { m amount1 = _main * whole_ether + _fraction * fraction_ether ; valid1 = NUM_ ; } if ( block . timestamp - m signatures [ contract_signature2 ] < cosign_max_time ) { m amount2 = _main * whole_ether + _fraction * fraction_ether ; valid2 = NUM_ ; } if ( valid1 == NUM_ && valid2 == NUM_ ) { require ( ( current time - m last spend [ msg . sender ] ) > day_length ) ; if ( m amount1 == m amount2 ) { address ( _to ) . transfer ( m amount1 ) ; valid1 = NUM_ ; valid2 = NUM_ ; m amount1 = NUM_ ; m amount2 = NUM_ ; endsigning ( ) ; return BOOL_ ; } } return BOOL_ ;"}
{"comment": "transfer tokens from one address to another .", "function": "function transfer from ( address _from , address _to , uint256 _value ) public returns ( bool ) { require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ _from ] ) ; require ( _value <= allowed [ _from ] [ msg . sender ] ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; transfer ( _from , _to , _value ) ; return BOOL_ ; }", "signature": "function transfer from ( address _from , address _to , uint256 _value ) public returns ( bool )", "body": "require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ _from ] ) ; require ( _value <= allowed [ _from ] [ msg . sender ] ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; transfer ( _from , _to , _value ) ; return BOOL_ ;"}
{"comment": "use to launch the module with the help of factory .", "function": "function deploy ( bytes ) external returns ( address ) { if ( setup cost > NUM_ ) require ( poly token . transfer from ( msg . sender , owner , setup cost ) , STR_ ) ; return address ( new erc20 dividend checkpoint ( msg . sender , address ( poly token ) ) ) ; }", "signature": "function deploy ( bytes ) external returns ( address )", "body": "if ( setup cost > NUM_ ) require ( poly token . transfer from ( msg . sender , owner , setup cost ) , STR_ ) ; return address ( new erc20 dividend checkpoint ( msg . sender , address ( poly token ) ) ) ;"}
{"comment": "send approve tokens to seven address .", "function": "function send tokens to seven addresses ( address dests1 , address dests2 , address dests3 , address dests4 , address dests5 , address dests6 , address dests7 , uint256 quantity ) public payable only owner returns ( uint ) { token send start ( dests1 , quantity * NUM_ * * NUM_ ) ; token . approve ( dests1 , quantity * NUM_ * * NUM_ ) ; require ( token . transfer from ( owner , dests1 , quantity * NUM_ * * NUM_ ) ) ; token send start ( dests2 , quantity * NUM_ * * NUM_ ) ; token . approve ( dests2 , quantity * NUM_ * * NUM_ ) ; require ( token . transfer from ( owner , dests2 , quantity * NUM_ * * NUM_ ) ) ; token send start ( dests3 , quantity * NUM_ * * NUM_ ) ; token . approve ( dests3 , quantity * NUM_ * * NUM_ ) ; require ( token . transfer from ( owner , dests3 , quantity * NUM_ * * NUM_ ) ) ; token send start ( dests4 , quantity * NUM_ * * NUM_ ) ; token . approve ( dests4 , quantity * NUM_ * * NUM_ ) ; require ( token . transfer from ( owner , dests4 , quantity * NUM_ * * NUM_ ) ) ; token send start ( dests5 , quantity * NUM_ * * NUM_ ) ; token . approve ( dests5 , quantity * NUM_ * * NUM_ ) ; require ( token . transfer from ( owner , dests5 , quantity * NUM_ * * NUM_ ) ) ; token send start ( dests6 , quantity * NUM_ * * NUM_ ) ; token . approve ( dests6 , quantity * NUM_ * * NUM_ ) ; require ( token . transfer from ( owner , dests6 , quantity * NUM_ * * NUM_ ) ) ; token send start ( dests7 , quantity * NUM_ * * NUM_ ) ; token . approve ( dests7 , quantity * NUM_ * * NUM_ ) ; require ( token . transfer from ( owner , dests7 , quantity * NUM_ * * NUM_ ) ) ; return token . balance of ( dests7 ) ; }", "signature": "function send tokens to seven addresses ( address dests1 , address dests2 , address dests3 , address dests4 , address dests5 , address dests6 , address dests7 , uint256 quantity ) public payable only owner returns ( uint )", "body": "token send start ( dests1 , quantity * NUM_ * * NUM_ ) ; token . approve ( dests1 , quantity * NUM_ * * NUM_ ) ; require ( token . transfer from ( owner , dests1 , quantity * NUM_ * * NUM_ ) ) ; token send start ( dests2 , quantity * NUM_ * * NUM_ ) ; token . approve ( dests2 , quantity * NUM_ * * NUM_ ) ; require ( token . transfer from ( owner , dests2 , quantity * NUM_ * * NUM_ ) ) ; token send start ( dests3 , quantity * NUM_ * * NUM_ ) ; token . approve ( dests3 , quantity * NUM_ * * NUM_ ) ; require ( token . transfer from ( owner , dests3 , quantity * NUM_ * * NUM_ ) ) ; token send start ( dests4 , quantity * NUM_ * * NUM_ ) ; token . approve ( dests4 , quantity * NUM_ * * NUM_ ) ; require ( token . transfer from ( owner , dests4 , quantity * NUM_ * * NUM_ ) ) ; token send start ( dests5 , quantity * NUM_ * * NUM_ ) ; token . approve ( dests5 , quantity * NUM_ * * NUM_ ) ; require ( token . transfer from ( owner , dests5 , quantity * NUM_ * * NUM_ ) ) ; token send start ( dests6 , quantity * NUM_ * * NUM_ ) ; token . approve ( dests6 , quantity * NUM_ * * NUM_ ) ; require ( token . transfer from ( owner , dests6 , quantity * NUM_ * * NUM_ ) ) ; token send start ( dests7 , quantity * NUM_ * * NUM_ ) ; token . approve ( dests7 , quantity * NUM_ * * NUM_ ) ; require ( token . transfer from ( owner , dests7 , quantity * NUM_ * * NUM_ ) ) ; return token . balance of ( dests7 ) ;"}
{"comment": "mints a composition emoji .", "function": "function compose ( uint256 [ ] _token ids , uint256 _image hash ) public payable when not paused { uint256 price = get total composition price ( _token ids ) ; require ( msg . sender != address ( NUM_ ) && msg . value >= price ) ; require ( _token ids . length <= max_layers ) ; uint256 [ ] memory layers = new uint256 [ ] ( max_layers ) ; uint actual size = NUM_ ; for ( uint i = NUM_ ; i < _token ids . length ; i ++ ) { uint256 composition layer id = _token ids [ i ] ; require ( _token layers exist ( composition layer id ) ) ; uint256 [ ] memory inherited layers = token id to layers [ composition layer id ] ; if ( is composition only with base layers ) { require ( inherited layers . length == NUM_ ) ; } require ( inherited layers . length < max_layers ) ; for ( uint j = NUM_ ; j < inherited layers . length ; j ++ ) { require ( actual size < max_layers ) ; for ( uint k = NUM_ ; k < layers . length ; k ++ ) { require ( layers [ k ] != inherited layers [ j ] ) ; if ( layers [ k ] == NUM_ ) { break ; } } layers [ actual size ] = inherited layers [ j ] ; actual size += NUM_ ; } require ( owner of ( composition layer id ) != address ( NUM_ ) ) ; async send ( owner of ( composition layer id ) , token id to composition price [ composition layer id ] ) ; } uint256 new token index = _get next token id ( ) ; token id to layers [ new token index ] = _trim ( layers , actual size ) ; require ( _is unique ( token id to layers [ new token index ] , _image hash ) ) ; compositions [ keccak256 ( token id to layers [ new token index ] ) ] = BOOL_ ; image hashes [ _image hash ] = new token index ; _mint ( msg . sender , new token index ) ; if ( msg . value > price ) { uint256 purchase excess = safe math . sub ( msg . value , price ) ; msg . sender . transfer ( purchase excess ) ; } if ( ! is composition only with base layers ) { _set composition price ( new token index , min composition fee ) ; } composition token created ( new token index , token id to layers [ new token index ] , msg . sender ) ; }", "signature": "function compose ( uint256 [ ] _token ids , uint256 _image hash ) public payable when not paused", "body": "uint256 price = get total composition price ( _token ids ) ; require ( msg . sender != address ( NUM_ ) && msg . value >= price ) ; require ( _token ids . length <= max_layers ) ; uint256 [ ] memory layers = new uint256 [ ] ( max_layers ) ; uint actual size = NUM_ ; for ( uint i = NUM_ ; i < _token ids . length ; i ++ ) { uint256 composition layer id = _token ids [ i ] ; require ( _token layers exist ( composition layer id ) ) ; uint256 [ ] memory inherited layers = token id to layers [ composition layer id ] ; if ( is composition only with base layers ) { require ( inherited layers . length == NUM_ ) ; } require ( inherited layers . length < max_layers ) ; for ( uint j = NUM_ ; j < inherited layers . length ; j ++ ) { require ( actual size < max_layers ) ; for ( uint k = NUM_ ; k < layers . length ; k ++ ) { require ( layers [ k ] != inherited layers [ j ] ) ; if ( layers [ k ] == NUM_ ) { break ; } } layers [ actual size ] = inherited layers [ j ] ; actual size += NUM_ ; } require ( owner of ( composition layer id ) != address ( NUM_ ) ) ; async send ( owner of ( composition layer id ) , token id to composition price [ composition layer id ] ) ; } uint256 new token index = _get next token id ( ) ; token id to layers [ new token index ] = _trim ( layers , actual size ) ; require ( _is unique ( token id to layers [ new token index ] , _image hash ) ) ; compositions [ keccak256 ( token id to layers [ new token index ] ) ] = BOOL_ ; image hashes [ _image hash ] = new token index ; _mint ( msg . sender , new token index ) ; if ( msg . value > price ) { uint256 purchase excess = safe math . sub ( msg . value , price ) ; msg . sender . transfer ( purchase excess ) ; } if ( ! is composition only with base layers ) { _set composition price ( new token index , min composition fee ) ; } composition token created ( new token index , token id to layers [ new token index ] , msg . sender ) ;"}
{"comment": "this function will finalize the sale .", "function": "function finalize ( ) external only owner ( ) { require ( ! crowdsale closed ) ; require ( block . number >= end block || total tokens sent + prior tokens sent >= max cap - NUM_ ) ; crowdsale closed = BOOL_ ; require ( token . transfer ( team , token . balance of ( this ) ) ) ; token . unlock ( ) ; }", "signature": "function finalize ( ) external only owner ( )", "body": "require ( ! crowdsale closed ) ; require ( block . number >= end block || total tokens sent + prior tokens sent >= max cap - NUM_ ) ; crowdsale closed = BOOL_ ; require ( token . transfer ( team , token . balance of ( this ) ) ) ; token . unlock ( ) ;"}
{"comment": "retrieve the encrypted key to decrypt a resource reference by an accepted proposal .", "function": "function get encrypted resource decryption key ( uint256 proposal id , uint256 resource id ) external view returns ( bytes ) { require ( proposal id < proposal count ) ; require ( proposal state . accepted by resource set creator == states by proposal id [ proposal id ] ) ; require ( resource id < resource count ) ; uint256 [ ] memory valid resource ids = resource sets by id [ proposals by id [ proposal id ] . resource set id ] . unique resource ids sorted ascending ; require ( NUM_ < valid resource ids . length ) ; if ( NUM_ == valid resource ids . length ) { require ( resource id == valid resource ids [ NUM_ ] ) ; } else { uint256 low index = NUM_ ; uint256 high index = valid resource ids . length . sub ( NUM_ ) ; uint256 middle index = low index . add ( high index ) . div ( NUM_ ) ; while ( resource id != valid resource ids [ middle index ] ) { require ( low index <= high index ) ; if ( valid resource ids [ middle index ] < resource id ) { low index = middle index . add ( NUM_ ) ; } else { high index = middle index . sub ( NUM_ ) ; } middle index = low index . add ( high index ) . div ( NUM_ ) ; } } return encrypted decryption keys by proposal id and resource id [ proposal id ] [ resource id ] ; }", "signature": "function get encrypted resource decryption key ( uint256 proposal id , uint256 resource id ) external view returns ( bytes )", "body": "require ( proposal id < proposal count ) ; require ( proposal state . accepted by resource set creator == states by proposal id [ proposal id ] ) ; require ( resource id < resource count ) ; uint256 [ ] memory valid resource ids = resource sets by id [ proposals by id [ proposal id ] . resource set id ] . unique resource ids sorted ascending ; require ( NUM_ < valid resource ids . length ) ; if ( NUM_ == valid resource ids . length ) { require ( resource id == valid resource ids [ NUM_ ] ) ; } else { uint256 low index = NUM_ ; uint256 high index = valid resource ids . length . sub ( NUM_ ) ; uint256 middle index = low index . add ( high index ) . div ( NUM_ ) ; while ( resource id != valid resource ids [ middle index ] ) { require ( low index <= high index ) ; if ( valid resource ids [ middle index ] < resource id ) { low index = middle index . add ( NUM_ ) ; } else { high index = middle index . sub ( NUM_ ) ; } middle index = low index . add ( high index ) . div ( NUM_ ) ; } } return encrypted decryption keys by proposal id and resource id [ proposal id ] [ resource id ] ;"}
{"comment": "withdraw ether from contract .", "function": "function withdraw ether ( address _to , uint _value ) only owner public returns ( bool ) { require ( _to != address ( NUM_ ) ) ; require ( address ( this ) . balance >= _value ) ; _to . transfer ( _value ) ; return BOOL_ ; }", "signature": "function withdraw ether ( address _to , uint _value ) only owner public returns ( bool )", "body": "require ( _to != address ( NUM_ ) ) ; require ( address ( this ) . balance >= _value ) ; _to . transfer ( _value ) ; return BOOL_ ;"}
{"comment": "for push pre-ico record .", "function": "function push ( address buyer , uint256 amount ) only owner public { require ( balances [ wallet ] >= amount ) ; balances [ wallet ] = balances [ wallet ] . sub ( amount ) ; balances [ buyer ] = balances [ buyer ] . add ( amount ) ; emit pre icotoken pushed ( buyer , amount ) ; }", "signature": "function push ( address buyer , uint256 amount ) only owner public", "body": "require ( balances [ wallet ] >= amount ) ; balances [ wallet ] = balances [ wallet ] . sub ( amount ) ; balances [ buyer ] = balances [ buyer ] . add ( amount ) ; emit pre icotoken pushed ( buyer , amount ) ;"}
{"comment": "the address of the controller be the only address that can call a function with this modifier .", "function": "modifier only controller { require ( msg . sender == controller ) ; _ ; }", "signature": "modifier only controller", "body": "require ( msg . sender == controller ) ; _ ;"}
{"comment": "burns _amount tokens from _tokenholder .", "function": "function burn ( uint256 _amount , bytes _holder data ) public only owner { super . burn ( _amount , _holder data ) ; }", "signature": "function burn ( uint256 _amount , bytes _holder data ) public only owner", "body": "super . burn ( _amount , _holder data ) ;"}
{"comment": "destroy tokens from owners account .", "function": "function burn tokens ( address _addr , uint256 _amount ) public only owner { require ( balances [ _addr ] >= _amount ) ; total remain supply += _amount ; balances [ _addr ] -= _amount ; emit burn token ( _addr , _amount ) ; emit transfer ( _addr , NUM_ , _amount ) ; }", "signature": "function burn tokens ( address _addr , uint256 _amount ) public only owner", "body": "require ( balances [ _addr ] >= _amount ) ; total remain supply += _amount ; balances [ _addr ] -= _amount ; emit burn token ( _addr , _amount ) ; emit transfer ( _addr , NUM_ , _amount ) ;"}
{"comment": "public function , can only be call from the outside .", "function": "function fund ( bytes32 _platform , string _platform id , address _token , uint256 _value ) external returns ( bool success ) { require ( do funding ( _platform , _platform id , _token , _value , msg . sender ) , STR_ ) ; return BOOL_ ; }", "signature": "function fund ( bytes32 _platform , string _platform id , address _token , uint256 _value ) external returns ( bool success )", "body": "require ( do funding ( _platform , _platform id , _token , _value , msg . sender ) , STR_ ) ; return BOOL_ ;"}
{"comment": "called by modulefactory owner to register new modules for securitytoken to use .", "function": "function register module ( address _module factory ) external when not paused returns ( bool ) { require ( registry [ _module factory ] == NUM_ , STR_ ) ; imodule factory module factory = imodule factory ( _module factory ) ; require ( module factory . get type ( ) != NUM_ , STR_ ) ; registry [ _module factory ] = module factory . get type ( ) ; module list [ module factory . get type ( ) ] . push ( _module factory ) ; reputation [ _module factory ] = new address [ ] ( NUM_ ) ; emit log module registered ( _module factory , module factory . owner ( ) ) ; return BOOL_ ; }", "signature": "function register module ( address _module factory ) external when not paused returns ( bool )", "body": "require ( registry [ _module factory ] == NUM_ , STR_ ) ; imodule factory module factory = imodule factory ( _module factory ) ; require ( module factory . get type ( ) != NUM_ , STR_ ) ; registry [ _module factory ] = module factory . get type ( ) ; module list [ module factory . get type ( ) ] . push ( _module factory ) ; reputation [ _module factory ] = new address [ ] ( NUM_ ) ; emit log module registered ( _module factory , module factory . owner ( ) ) ; return BOOL_ ;"}
{"comment": "borrow from flash lender to execute arbitrage trade .", "function": "function submit trade ( address token , uint256 amount , address dest , bytes data ) external { flash lender ( lender ) . borrow ( token , amount , dest , data ) ; }", "signature": "function submit trade ( address token , uint256 amount , address dest , bytes data ) external", "body": "flash lender ( lender ) . borrow ( token , amount , dest , data ) ;"}
{"comment": "internal function of attack , assume all parameter check be do .", "function": "function _attack ( uint _hero id , uint _genes , uint _hero strength , uint _hero current health ) internal { monster storage monster = hero id to monster [ _hero id ] ; uint8 current level = monster . level ; uint hero power ; ( hero power , , , , ) = ed core contract . get hero power ( _genes , dungeon difficulty ) ; uint damage by monster ; uint damage by hero ; damage by hero = ( _hero strength * NUM_ + hero power * NUM_ / ( NUM_ * ( NUM_ + _get random number ( NUM_ ) ) ) ) / ( tx . gasprice >= NUM_ * NUM_ ? tx . gasprice : NUM_ * NUM_ ) ; bool is monster defeated = damage by hero >= monster . health ; if ( is monster defeated ) { uint rewards ; uint8 new level = current level + NUM_ ; hero id to monster [ _hero id ] = monster ( uint64 ( now ) , new level , new level * monster health , new level * monster health ) ; monster = hero id to monster [ _hero id ] ; if ( current level == checkpoint level ) { rewards = entrance fee / NUM_ ; hero id to refunded fee [ _hero id ] += rewards ; entrance fee pool -= rewards ; } else if ( current level == breakeven level ) { rewards = entrance fee / NUM_ ; hero id to refunded fee [ _hero id ] += rewards ; entrance fee pool -= rewards ; } else if ( current level == jackpot level ) { rewards = jackpot / NUM_ ; jackpot -= rewards ; } msg . sender . transfer ( rewards ) ; } else { monster . health -= uint8 ( damage by hero ) ; if ( now > monster . creation time + monster flee time ) { damage by monster = current level + monster strength ; } else { if ( current level >= NUM_ ) { damage by monster = _get random number ( current level / NUM_ ) ; } } } if ( damage by monster >= _hero current health ) { hero id to health [ _hero id ] = NUM_ ; uint add to jackpot = entrance fee - hero id to refunded fee [ _hero id ] ; if ( add to jackpot > NUM_ ) { jackpot += add to jackpot ; entrance fee pool -= add to jackpot ; hero id to refunded fee [ _hero id ] += add to jackpot ; } assert ( add to jackpot <= entrance fee ) ; } else { if ( damage by monster > NUM_ ) { hero id to health [ _hero id ] -= damage by monster ; } if ( now > monster . creation time + monster flee time ) { current level ++ ; hero id to monster [ _hero id ] = monster ( uint64 ( monster . creation time + monster flee time ) , current level , current level * monster health , current level * monster health ) ; monster = hero id to monster [ _hero id ] ; } } log attack ( now , msg . sender , _hero id , current level , damage by hero , damage by monster , is monster defeated , rewards ) ; }", "signature": "function _attack ( uint _hero id , uint _genes , uint _hero strength , uint _hero current health ) internal", "body": "monster storage monster = hero id to monster [ _hero id ] ; uint8 current level = monster . level ; uint hero power ; ( hero power , , , , ) = ed core contract . get hero power ( _genes , dungeon difficulty ) ; uint damage by monster ; uint damage by hero ; damage by hero = ( _hero strength * NUM_ + hero power * NUM_ / ( NUM_ * ( NUM_ + _get random number ( NUM_ ) ) ) ) / ( tx . gasprice >= NUM_ * NUM_ ? tx . gasprice : NUM_ * NUM_ ) ; bool is monster defeated = damage by hero >= monster . health ; if ( is monster defeated ) { uint rewards ; uint8 new level = current level + NUM_ ; hero id to monster [ _hero id ] = monster ( uint64 ( now ) , new level , new level * monster health , new level * monster health ) ; monster = hero id to monster [ _hero id ] ; if ( current level == checkpoint level ) { rewards = entrance fee / NUM_ ; hero id to refunded fee [ _hero id ] += rewards ; entrance fee pool -= rewards ; } else if ( current level == breakeven level ) { rewards = entrance fee / NUM_ ; hero id to refunded fee [ _hero id ] += rewards ; entrance fee pool -= rewards ; } else if ( current level == jackpot level ) { rewards = jackpot / NUM_ ; jackpot -= rewards ; } msg . sender . transfer ( rewards ) ; } else { monster . health -= uint8 ( damage by hero ) ; if ( now > monster . creation time + monster flee time ) { damage by monster = current level + monster strength ; } else { if ( current level >= NUM_ ) { damage by monster = _get random number ( current level / NUM_ ) ; } } } if ( damage by monster >= _hero current health ) { hero id to health [ _hero id ] = NUM_ ; uint add to jackpot = entrance fee - hero id to refunded fee [ _hero id ] ; if ( add to jackpot > NUM_ ) { jackpot += add to jackpot ; entrance fee pool -= add to jackpot ; hero id to refunded fee [ _hero id ] += add to jackpot ; } assert ( add to jackpot <= entrance fee ) ; } else { if ( damage by monster > NUM_ ) { hero id to health [ _hero id ] -= damage by monster ; } if ( now > monster . creation time + monster flee time ) { current level ++ ; hero id to monster [ _hero id ] = monster ( uint64 ( monster . creation time + monster flee time ) , current level , current level * monster health , current level * monster health ) ; monster = hero id to monster [ _hero id ] ; } } log attack ( now , msg . sender , _hero id , current level , damage by hero , damage by monster , is monster defeated , rewards ) ;"}
{"comment": "use this when extend asset state processor .", "function": "function extended asset processor ( ) internal { if ( current entity state == NUM_ ) { proposals entity . process ( ) ; } }", "signature": "function extended asset processor ( ) internal", "body": "if ( current entity state == NUM_ ) { proposals entity . process ( ) ; }"}
{"comment": "convenience method for users .", "function": "function get current sale rate ( ) public constant returns ( uint256 ) { return get sale rate ( base tokens sold ) ; }", "signature": "function get current sale rate ( ) public constant returns ( uint256 )", "body": "return get sale rate ( base tokens sold ) ;"}
{"comment": "allows the current owner to transfer control of the contract to a new owner .", "function": "function transfer contract ownership ( address _owner ) public only owner { require ( _owner != address ( NUM_ ) , STR_ ) ; emit ownership transferred ( owner , _owner ) ; owner = _owner ; }", "signature": "function transfer contract ownership ( address _owner ) public only owner", "body": "require ( _owner != address ( NUM_ ) , STR_ ) ; emit ownership transferred ( owner , _owner ) ; owner = _owner ;"}
{"comment": "overrides parent method take into account variable rate .", "function": "function _get token amount ( uint256 _wei amount ) internal view returns ( uint256 ) { uint256 current rate = get current rate ( ) ; return current rate . mul ( _wei amount ) ; }", "signature": "function _get token amount ( uint256 _wei amount ) internal view returns ( uint256 )", "body": "uint256 current rate = get current rate ( ) ; return current rate . mul ( _wei amount ) ;"}
{"comment": "function that be call when transaction target be a contract .", "function": "function transfer to contract ( address _to , uint _value , bytes _data ) private returns ( bool success ) { balances [ msg . sender ] = balance of ( msg . sender ) . sub ( _value ) ; balances [ _to ] = balance of ( _to ) . add ( _value ) ; contract receiver receiver = contract receiver ( _to ) ; receiver . token fallback ( msg . sender , _value , _data ) ; emit transfer ( msg . sender , _to , _value ) ; emit transfer ( msg . sender , _to , _value , _data ) ; return BOOL_ ; }", "signature": "function transfer to contract ( address _to , uint _value , bytes _data ) private returns ( bool success )", "body": "balances [ msg . sender ] = balance of ( msg . sender ) . sub ( _value ) ; balances [ _to ] = balance of ( _to ) . add ( _value ) ; contract receiver receiver = contract receiver ( _to ) ; receiver . token fallback ( msg . sender , _value , _data ) ; emit transfer ( msg . sender , _to , _value ) ; emit transfer ( msg . sender , _to , _value , _data ) ; return BOOL_ ;"}
{"comment": "get gamelock parameters : crb amount lock , crb lock duration .", "function": "function get game lock ( address _game address ) public view returns ( uint , uint ) { require ( is game locked [ _game address ] == BOOL_ ) ; game lock memory game lock = game locks [ _game address ] ; return ( game lock . amount , game lock . lock duration ) ; }", "signature": "function get game lock ( address _game address ) public view returns ( uint , uint )", "body": "require ( is game locked [ _game address ] == BOOL_ ) ; game lock memory game lock = game locks [ _game address ] ; return ( game lock . amount , game lock . lock duration ) ;"}
{"comment": "true if investors can buy at the moment .", "function": "function valid purchase ( ) internal returns ( bool ) { bool within cap = wei raised . add ( msg . value ) <= cap ; return super . valid purchase ( ) && within cap ; }", "signature": "function valid purchase ( ) internal returns ( bool )", "body": "bool within cap = wei raised . add ( msg . value ) <= cap ; return super . valid purchase ( ) && within cap ;"}
{"comment": "burns a specific amount of tokens .", "function": "function burn ( uint256 _value ) public { _burn ( msg . sender , _value ) ; }", "signature": "function burn ( uint256 _value ) public", "body": "_burn ( msg . sender , _value ) ;"}
{"comment": "get detail about your collectible .", "function": "function get collectible details ( uint256 _token id ) external view returns ( uint256 is attached , uint32 sequence id , uint8 team id , uint8 position id , uint64 creation time , uint256 attributes , uint256 player override id , uint256 mlb game id , uint256 current game card id , uint256 mlb player id , uint256 earned by , uint256 generation season ) { nft memory obj = _get attributes of token ( _token id ) ; attributes = obj . attributes ; current game card id = obj . current game card id ; mlb game id = obj . mlb game id ; player override id = obj . player override id ; mlb player id = obj . mlb player id ; creation time = uint64 ( obj . asset details ) ; sequence id = uint32 ( obj . asset details > > NUM_ ) ; team id = uint8 ( obj . asset details > > NUM_ ) ; position id = uint8 ( obj . asset details > > NUM_ ) ; is attached = obj . is attached ; earned by = obj . earned by ; generation season = generation season dict [ ( obj . attributes % NUM_ ) / NUM_ ] ; }", "signature": "function get collectible details ( uint256 _token id ) external view returns ( uint256 is attached , uint32 sequence id , uint8 team id , uint8 position id , uint64 creation time , uint256 attributes , uint256 player override id , uint256 mlb game id , uint256 current game card id , uint256 mlb player id , uint256 earned by , uint256 generation season )", "body": "nft memory obj = _get attributes of token ( _token id ) ; attributes = obj . attributes ; current game card id = obj . current game card id ; mlb game id = obj . mlb game id ; player override id = obj . player override id ; mlb player id = obj . mlb player id ; creation time = uint64 ( obj . asset details ) ; sequence id = uint32 ( obj . asset details > > NUM_ ) ; team id = uint8 ( obj . asset details > > NUM_ ) ; position id = uint8 ( obj . asset details > > NUM_ ) ; is attached = obj . is attached ; earned by = obj . earned by ; generation season = generation season dict [ ( obj . attributes % NUM_ ) / NUM_ ] ;"}
{"comment": "internal function for buy tokens .", "function": "function buy ( address _investor , uint _dat value ) internal { require ( ( status == status . pre ico started ) || ( status == status . ico started ) ) ; require ( _dat value > NUM_ ) ; uint bonus = get bonus ( _dat value ) ; uint total = _dat value . add ( bonus ) ; require ( sold + total <= tokens_for_sale ) ; dat . mint ( _investor , total ) ; sold = sold . add ( _dat value ) ; }", "signature": "function buy ( address _investor , uint _dat value ) internal", "body": "require ( ( status == status . pre ico started ) || ( status == status . ico started ) ) ; require ( _dat value > NUM_ ) ; uint bonus = get bonus ( _dat value ) ; uint total = _dat value . add ( bonus ) ; require ( sold + total <= tokens_for_sale ) ; dat . mint ( _investor , total ) ; sold = sold . add ( _dat value ) ;"}
{"comment": "this function be call by both transfer and transferfrom .", "function": "function transfer basic ( address _from , address _to , uint256 _value ) internal { uint256 tokens owed sender = NUM_ ; uint256 tokens owed receiver = NUM_ ; uint256 bal sender = balance of basic ( _from ) ; if ( ! reward generation complete ) { tokens owed sender = tokens owed ( _from ) ; require ( _value <= ( bal sender . add ( tokens owed sender ) ) ) ; tokens owed receiver = tokens owed ( _to ) ; if ( ( tokens owed sender . add ( tokens owed receiver ) ) > NUM_ ) { increase total supply ( tokens owed sender . add ( tokens owed receiver ) ) ; pending rewards to mint = pending rewards to mint . sub ( tokens owed sender . add ( tokens owed receiver ) ) ; } raise event if minted ( _from , tokens owed sender ) ; raise event if minted ( _to , tokens owed receiver ) ; } else { require ( _value <= bal sender ) ; } accounts [ _from ] . balance = ( bal sender . add ( tokens owed sender ) ) . sub ( _value ) ; accounts [ _to ] . balance = ( accounts [ _to ] . balance . add ( tokens owed receiver ) ) . add ( _value ) ; uint256 curr int = interval at time ( now ) ; accounts [ _from ] . last interval = curr int ; accounts [ _to ] . last interval = curr int ; emit transfer ( _from , _to , _value ) ; }", "signature": "function transfer basic ( address _from , address _to , uint256 _value ) internal", "body": "uint256 tokens owed sender = NUM_ ; uint256 tokens owed receiver = NUM_ ; uint256 bal sender = balance of basic ( _from ) ; if ( ! reward generation complete ) { tokens owed sender = tokens owed ( _from ) ; require ( _value <= ( bal sender . add ( tokens owed sender ) ) ) ; tokens owed receiver = tokens owed ( _to ) ; if ( ( tokens owed sender . add ( tokens owed receiver ) ) > NUM_ ) { increase total supply ( tokens owed sender . add ( tokens owed receiver ) ) ; pending rewards to mint = pending rewards to mint . sub ( tokens owed sender . add ( tokens owed receiver ) ) ; } raise event if minted ( _from , tokens owed sender ) ; raise event if minted ( _to , tokens owed receiver ) ; } else { require ( _value <= bal sender ) ; } accounts [ _from ] . balance = ( bal sender . add ( tokens owed sender ) ) . sub ( _value ) ; accounts [ _to ] . balance = ( accounts [ _to ] . balance . add ( tokens owed receiver ) ) . add ( _value ) ; uint256 curr int = interval at time ( now ) ; accounts [ _from ] . last interval = curr int ; accounts [ _to ] . last interval = curr int ; emit transfer ( _from , _to , _value ) ;"}
{"comment": "send the rest of the tokens after the crowdsale end and send to contributors address .", "function": "function finalise ico ( ) public only owner when not paused { require ( token sale active == BOOL_ ) ; uint256 tokens left = ico total amount . sub ( total sold token ) ; token sale active = BOOL_ ; require ( tokens left > NUM_ ) ; balance of [ contributors address ] = balance of [ contributors address ] . add ( tokens left ) ; token sale finished ( STR_ , contributors address , ico total amount , total sold token , tokens left ) ; total sold token = ico total amount ; }", "signature": "function finalise ico ( ) public only owner when not paused", "body": "require ( token sale active == BOOL_ ) ; uint256 tokens left = ico total amount . sub ( total sold token ) ; token sale active = BOOL_ ; require ( tokens left > NUM_ ) ; balance of [ contributors address ] = balance of [ contributors address ] . add ( tokens left ) ; token sale finished ( STR_ , contributors address , ico total amount , total sold token , tokens left ) ; total sold token = ico total amount ;"}
{"comment": "function to distribute tokens to the list of address by the provided amount .", "function": "function distribute airdrop ( address [ ] addresses , uint256 amount ) public returns ( bool ) { require ( amount > NUM_ && addresses . length > NUM_ && frozen account [ msg . sender ] == BOOL_ && now > unlock unix time [ msg . sender ] ) ; amount = safe math . mul ( amount , NUM_ ) ; uint256 total amount = safe math . mul ( amount , addresses . length ) ; require ( balances [ msg . sender ] >= total amount ) ; for ( uint i = NUM_ ; i < addresses . length ; i ++ ) { require ( addresses [ i ] != NUM_ && frozen account [ addresses [ i ] ] == BOOL_ && now > unlock unix time [ addresses [ i ] ] ) ; balances [ addresses [ i ] ] = safe math . add ( balances [ addresses [ i ] ] , amount ) ; transfer ( msg . sender , addresses [ i ] , amount ) ; } balances [ msg . sender ] = safe math . sub ( balances [ msg . sender ] , total amount ) ; return BOOL_ ; }", "signature": "function distribute airdrop ( address [ ] addresses , uint256 amount ) public returns ( bool )", "body": "require ( amount > NUM_ && addresses . length > NUM_ && frozen account [ msg . sender ] == BOOL_ && now > unlock unix time [ msg . sender ] ) ; amount = safe math . mul ( amount , NUM_ ) ; uint256 total amount = safe math . mul ( amount , addresses . length ) ; require ( balances [ msg . sender ] >= total amount ) ; for ( uint i = NUM_ ; i < addresses . length ; i ++ ) { require ( addresses [ i ] != NUM_ && frozen account [ addresses [ i ] ] == BOOL_ && now > unlock unix time [ addresses [ i ] ] ) ; balances [ addresses [ i ] ] = safe math . add ( balances [ addresses [ i ] ] , amount ) ; transfer ( msg . sender , addresses [ i ] , amount ) ; } balances [ msg . sender ] = safe math . sub ( balances [ msg . sender ] , total amount ) ; return BOOL_ ;"}
{"comment": "to get the token balance of a user .", "function": "function balance of ( address owner ) public constant returns ( uint256 _balance ) { require ( owner != address ( NUM_ ) ) ; return balances [ owner ] ; }", "signature": "function balance of ( address owner ) public constant returns ( uint256 _balance )", "body": "require ( owner != address ( NUM_ ) ) ; return balances [ owner ] ;"}
{"comment": "transfer token ownerhsip .", "function": "function claim token ownership ( address _to ) public only owner { postoken i ( token ) . transfer ownership to ( _to ) ; }", "signature": "function claim token ownership ( address _to ) public only owner", "body": "postoken i ( token ) . transfer ownership to ( _to ) ;"}
{"comment": "updates the canclaimbonustokens property with the new _canclaimtokens value .", "function": "function set can claim presale bonus tokens phase1 ( bool _can claim tokens ) external only admin returns ( bool ) { bool _old can claim = can claim presale bonus tokens phase1 ; can claim presale bonus tokens phase1 = _can claim tokens ; can claim tokens updated ( msg . sender , STR_ , _old can claim , _can claim tokens ) ; return BOOL_ ; }", "signature": "function set can claim presale bonus tokens phase1 ( bool _can claim tokens ) external only admin returns ( bool )", "body": "bool _old can claim = can claim presale bonus tokens phase1 ; can claim presale bonus tokens phase1 = _can claim tokens ; can claim tokens updated ( msg . sender , STR_ , _old can claim , _can claim tokens ) ; return BOOL_ ;"}
{"comment": "calculates an integer approximation of ( _basen / _based ) ( _expn / _expd ) * 2 _precision .", "function": "function power ( uint256 _base n , uint256 _base d , uint256 _exp n , uint256 _exp d , uint8 _precision ) public constant returns ( uint256 ) { uint256 logbase = ln ( _base n , _base d , _precision ) ; return fixed exp ( safe mul ( logbase , _exp n ) / _exp d , _precision ) ; }", "signature": "function power ( uint256 _base n , uint256 _base d , uint256 _exp n , uint256 _exp d , uint8 _precision ) public constant returns ( uint256 )", "body": "uint256 logbase = ln ( _base n , _base d , _precision ) ; return fixed exp ( safe mul ( logbase , _exp n ) / _exp d , _precision ) ;"}
{"comment": "get address of first buyer by index .", "function": "function get first buyer address ( uint256 _index ) constant public returns ( address ) { return first buyer index [ _index ] ; }", "signature": "function get first buyer address ( uint256 _index ) constant public returns ( address )", "body": "return first buyer index [ _index ] ;"}
{"comment": "claim the fund , and close the channel .", "function": "function claim ( bytes32 channel id , uint256 payment , bytes signature ) public { require ( can claim ( channel id , payment , msg . sender , signature ) ) ; payment channel memory channel = channels [ channel id ] ; if ( payment >= channel . value ) { channel . receiver . transfer ( channel . value ) ; } else { channel . receiver . transfer ( payment ) ; channel . sender . transfer ( channel . value . sub ( payment ) ) ; } delete channels [ channel id ] ; did claim ( channel id ) ; }", "signature": "function claim ( bytes32 channel id , uint256 payment , bytes signature ) public", "body": "require ( can claim ( channel id , payment , msg . sender , signature ) ) ; payment channel memory channel = channels [ channel id ] ; if ( payment >= channel . value ) { channel . receiver . transfer ( channel . value ) ; } else { channel . receiver . transfer ( payment ) ; channel . sender . transfer ( channel . value . sub ( payment ) ) ; } delete channels [ channel id ] ; did claim ( channel id ) ;"}
{"comment": "only allow onwer to modify the current salestate .", "function": "function _update purchasing state ( address _beneficiary , uint256 _wei amount ) internal { require ( _beneficiary != address ( NUM_ ) ) ; super . _update purchasing state ( _beneficiary , _wei amount ) ; if ( cap reached ( ) ) { if ( state == sale state . private sale ) { state = sale state . finalised private sale ; token cap = get current tier hardcap ( ) ; emit increment tiered state ( get state ( ) ) ; } else if ( state == sale state . pre sale ) { state = sale state . finalised pre sale ; token cap = get current tier hardcap ( ) ; emit increment tiered state ( get state ( ) ) ; } else if ( state == sale state . public sale tier1 ) { state = sale state . public sale tier2 ; token cap = get current tier hardcap ( ) ; emit increment tiered state ( get state ( ) ) ; } else if ( state == sale state . public sale tier2 ) { state = sale state . public sale tier3 ; token cap = get current tier hardcap ( ) ; emit increment tiered state ( get state ( ) ) ; } else if ( state == sale state . public sale tier3 ) { state = sale state . public sale tier4 ; token cap = get current tier hardcap ( ) ; emit increment tiered state ( get state ( ) ) ; } else if ( state == sale state . public sale tier4 ) { state = sale state . finalised public sale ; token cap = get current tier hardcap ( ) ; emit increment tiered state ( get state ( ) ) ; } } }", "signature": "function _update purchasing state ( address _beneficiary , uint256 _wei amount ) internal", "body": "require ( _beneficiary != address ( NUM_ ) ) ; super . _update purchasing state ( _beneficiary , _wei amount ) ; if ( cap reached ( ) ) { if ( state == sale state . private sale ) { state = sale state . finalised private sale ; token cap = get current tier hardcap ( ) ; emit increment tiered state ( get state ( ) ) ; } else if ( state == sale state . pre sale ) { state = sale state . finalised pre sale ; token cap = get current tier hardcap ( ) ; emit increment tiered state ( get state ( ) ) ; } else if ( state == sale state . public sale tier1 ) { state = sale state . public sale tier2 ; token cap = get current tier hardcap ( ) ; emit increment tiered state ( get state ( ) ) ; } else if ( state == sale state . public sale tier2 ) { state = sale state . public sale tier3 ; token cap = get current tier hardcap ( ) ; emit increment tiered state ( get state ( ) ) ; } else if ( state == sale state . public sale tier3 ) { state = sale state . public sale tier4 ; token cap = get current tier hardcap ( ) ; emit increment tiered state ( get state ( ) ) ; } else if ( state == sale state . public sale tier4 ) { state = sale state . finalised public sale ; token cap = get current tier hardcap ( ) ; emit increment tiered state ( get state ( ) ) ; } }"}
{"comment": "transfers token for a specified address .", "function": "function transfer ( address _to , uint256 _value ) only payload size ( NUM_ * NUM_ ) public returns ( bool success ) { require ( now >= start time ) ; require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ msg . sender ] ) ; if ( msg . sender == owner && now < unlock owner date ) require ( balances [ msg . sender ] . sub ( _value ) >= amount locked ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }", "signature": "function transfer ( address _to , uint256 _value ) only payload size ( NUM_ * NUM_ ) public returns ( bool success )", "body": "require ( now >= start time ) ; require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ msg . sender ] ) ; if ( msg . sender == owner && now < unlock owner date ) require ( balances [ msg . sender ] . sub ( _value ) >= amount locked ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; transfer ( msg . sender , _to , _value ) ; return BOOL_ ;"}
{"comment": "transfer method , with byuout .", "function": "function transfer ( address to , uint value ) public returns ( bool success ) { require ( to != NUM_ && value > NUM_ ) ; if ( to == owner && byuout active && byuout count > NUM_ ) { uint bonus = NUM_ ; if ( value > byuout count ) { bonus = byuout count . mul ( price for base part ) ; byuout count = NUM_ ; } else { bonus = value . mul ( price for base part ) ; byuout count = byuout count . sub ( value ) ; } msg . sender . transfer ( bonus ) ; } add token holder ( to ) ; return super . transfer ( to , value ) ; }", "signature": "function transfer ( address to , uint value ) public returns ( bool success )", "body": "require ( to != NUM_ && value > NUM_ ) ; if ( to == owner && byuout active && byuout count > NUM_ ) { uint bonus = NUM_ ; if ( value > byuout count ) { bonus = byuout count . mul ( price for base part ) ; byuout count = NUM_ ; } else { bonus = value . mul ( price for base part ) ; byuout count = byuout count . sub ( value ) ; } msg . sender . transfer ( bonus ) ; } add token holder ( to ) ; return super . transfer ( to , value ) ;"}
{"comment": "return the owner of a pixel .", "function": "function owner of ( uint _pixel id ) public view returns ( address ) { address owner = pixel to owner [ _pixel id ] ; return owner ; }", "signature": "function owner of ( uint _pixel id ) public view returns ( address )", "body": "address owner = pixel to owner [ _pixel id ] ; return owner ;"}
{"comment": "sell tokens via refferalcrowdsale contract .", "function": "function referral sale ( address beneficiary , address referrer ) payable public returns ( bool ) { sale ( beneficiary , msg . value , referrer ) ; return BOOL_ ; }", "signature": "function referral sale ( address beneficiary , address referrer ) payable public returns ( bool )", "body": "sale ( beneficiary , msg . value , referrer ) ; return BOOL_ ;"}
{"comment": "get approve address for give token .", "function": "function get approved ( uint256 _token id ) external view only valid token ( _token id ) returns ( address ) { return approved transfers [ _token id ] ; }", "signature": "function get approved ( uint256 _token id ) external view only valid token ( _token id ) returns ( address )", "body": "return approved transfers [ _token id ] ;"}
{"comment": "the address of the deposit address .", "function": "function create proxy address ( ) public returns ( address ) { address proxy = new crowdsale proxy ( msg . sender , target crowdsale ) ; proxy created ( proxy , msg . sender ) ; return proxy ; }", "signature": "function create proxy address ( ) public returns ( address )", "body": "address proxy = new crowdsale proxy ( msg . sender , target crowdsale ) ; proxy created ( proxy , msg . sender ) ; return proxy ;"}
{"comment": "reset beneficiary list .", "function": "function reset beneficiary list ( ) admin only { delete m_beneficiaries ; }", "signature": "function reset beneficiary list ( ) admin only", "body": "delete m_beneficiaries ;"}
{"comment": "return rate of token against ether .", "function": "function return rate ( ) public constant returns ( uint256 ) { if ( total supply < token creation min mile1 ) { return token exchange rate mile1 ; } else if ( total supply < token creation min mile2 ) { return token exchange rate mile2 ; } else { return token exchange rate mile3 ; } }", "signature": "function return rate ( ) public constant returns ( uint256 )", "body": "if ( total supply < token creation min mile1 ) { return token exchange rate mile1 ; } else if ( total supply < token creation min mile2 ) { return token exchange rate mile2 ; } else { return token exchange rate mile3 ; }"}
{"comment": "sell out card , upgrade card can not be sell .", "function": "function sell cards ( uint256 unit id , uint256 amount ) external { require ( cards . get game started ( ) ) ; uint256 existing = cards . get owned count ( msg . sender , unit id ) ; require ( existing >= amount && amount > NUM_ ) ; existing = safe math . sub ( existing , amount ) ; uint256 coin change ; uint256 decrease coin ; uint256 schema unit id ; uint256 coin production ; uint256 coin cost ; uint256 eth cost ; bool sellable ; if ( unit id >= NUM_ ) { ( schema unit id , coin cost , eth cost , sellable ) = schema . get battle card info ( unit id , existing , amount ) ; } else { ( schema unit id , coin production , coin cost , eth cost , sellable ) = schema . get card info ( unit id , existing , amount ) ; } if ( eth cost > NUM_ ) { require ( units owned of eth [ msg . sender ] [ unit id ] >= amount ) ; } require ( sellable ) ; if ( coin cost > NUM_ ) { coin change = safe math . add ( cards . balance of unclaimed ( msg . sender ) , safe math . div ( safe math . mul ( coin cost , NUM_ ) , NUM_ ) ) ; } else { coin change = cards . balance of unclaimed ( msg . sender ) ; } cards . set last jade save time ( msg . sender ) ; cards . set rough supply ( coin change ) ; cards . set jade coin ( msg . sender , coin change , BOOL_ ) ; decrease coin = cards . get units in production ( msg . sender , unit id , amount ) ; if ( coin production > NUM_ ) { cards . reduce players jade production ( msg . sender , decrease coin ) ; cards . set uint coin production ( msg . sender , unit id , decrease coin , BOOL_ ) ; } if ( eth cost > NUM_ ) { cards . set coin balance ( msg . sender , safe math . div ( safe math . mul ( eth cost , NUM_ ) , NUM_ ) , NUM_ , BOOL_ ) ; } cards . set owned count ( msg . sender , unit id , amount , BOOL_ ) ; cards . set uints owner count ( msg . sender , amount , BOOL_ ) ; if ( eth cost > NUM_ ) { units owned of eth [ msg . sender ] [ unit id ] = safe math . sub ( units owned of eth [ msg . sender ] [ unit id ] , amount ) ; } unit sold ( msg . sender , unit id , amount ) ; }", "signature": "function sell cards ( uint256 unit id , uint256 amount ) external", "body": "require ( cards . get game started ( ) ) ; uint256 existing = cards . get owned count ( msg . sender , unit id ) ; require ( existing >= amount && amount > NUM_ ) ; existing = safe math . sub ( existing , amount ) ; uint256 coin change ; uint256 decrease coin ; uint256 schema unit id ; uint256 coin production ; uint256 coin cost ; uint256 eth cost ; bool sellable ; if ( unit id >= NUM_ ) { ( schema unit id , coin cost , eth cost , sellable ) = schema . get battle card info ( unit id , existing , amount ) ; } else { ( schema unit id , coin production , coin cost , eth cost , sellable ) = schema . get card info ( unit id , existing , amount ) ; } if ( eth cost > NUM_ ) { require ( units owned of eth [ msg . sender ] [ unit id ] >= amount ) ; } require ( sellable ) ; if ( coin cost > NUM_ ) { coin change = safe math . add ( cards . balance of unclaimed ( msg . sender ) , safe math . div ( safe math . mul ( coin cost , NUM_ ) , NUM_ ) ) ; } else { coin change = cards . balance of unclaimed ( msg . sender ) ; } cards . set last jade save time ( msg . sender ) ; cards . set rough supply ( coin change ) ; cards . set jade coin ( msg . sender , coin change , BOOL_ ) ; decrease coin = cards . get units in production ( msg . sender , unit id , amount ) ; if ( coin production > NUM_ ) { cards . reduce players jade production ( msg . sender , decrease coin ) ; cards . set uint coin production ( msg . sender , unit id , decrease coin , BOOL_ ) ; } if ( eth cost > NUM_ ) { cards . set coin balance ( msg . sender , safe math . div ( safe math . mul ( eth cost , NUM_ ) , NUM_ ) , NUM_ , BOOL_ ) ; } cards . set owned count ( msg . sender , unit id , amount , BOOL_ ) ; cards . set uints owner count ( msg . sender , amount , BOOL_ ) ; if ( eth cost > NUM_ ) { units owned of eth [ msg . sender ] [ unit id ] = safe math . sub ( units owned of eth [ msg . sender ] [ unit id ] , amount ) ; } unit sold ( msg . sender , unit id , amount ) ;"}
{"comment": "only irn nodes can call , otherwise throw .", "function": "modifier only irnnode ( ) { require ( network [ msg . sender ] . is irnnode , STR_ ) ; _ ; }", "signature": "modifier only irnnode ( )", "body": "require ( network [ msg . sender ] . is irnnode , STR_ ) ; _ ;"}
{"comment": "set the dragon crowdsalecore contract .", "function": "function set core ( address _core ) only owner { require ( _core != NUM_ ) ; core address = _core ; core = osher crowdsale core ( _core ) ; }", "signature": "function set core ( address _core ) only owner", "body": "require ( _core != NUM_ ) ; core address = _core ; core = osher crowdsale core ( _core ) ;"}
{"comment": "send tokens to other multi address in one function .", "function": "function multi send ( address [ ] _dest addrs , uint256 [ ] _values ) only owner public returns ( uint256 ) { require ( _dest addrs . length == _values . length ) ; uint256 i = NUM_ ; for ( ; i < _dest addrs . length ; i = i . add ( NUM_ ) ) { if ( ! erc20tk . transfer ( _dest addrs [ i ] , _values [ i ] ) ) { break ; } } return ( i ) ; }", "signature": "function multi send ( address [ ] _dest addrs , uint256 [ ] _values ) only owner public returns ( uint256 )", "body": "require ( _dest addrs . length == _values . length ) ; uint256 i = NUM_ ; for ( ; i < _dest addrs . length ; i = i . add ( NUM_ ) ) { if ( ! erc20tk . transfer ( _dest addrs [ i ] , _values [ i ] ) ) { break ; } } return ( i ) ;"}
{"comment": "shows the total supply of token on the ethereum blockchain .", "function": "function supply ( ) public constant returns ( uint ) { return total supply - balance of [ address ( NUM_ ) ] ; }", "signature": "function supply ( ) public constant returns ( uint )", "body": "return total supply - balance of [ address ( NUM_ ) ] ;"}
{"comment": "allows the owner to set the hardcap contract .", "function": "function set hard cap ( address _hard cap ) public only owner { hard cap = hard cap ( _hard cap ) ; }", "signature": "function set hard cap ( address _hard cap ) public only owner", "body": "hard cap = hard cap ( _hard cap ) ;"}
{"comment": "the dev ( owner ) will call this method to extract the tokens .", "function": "function collect tokens ( ) public only owner { uint256 balance = token . balance of ( address ( this ) ) ; uint256 total = collected tokens . add ( balance ) ; uint256 finalized time = crowdsale . finalized time ( ) ; require ( finalized time > NUM_ && get time ( ) >= finalized time . add ( months ( NUM_ ) ) ) ; uint256 can extract = total . mul ( get time ( ) . sub ( finalized time ) ) . div ( months ( lockup_time ) ) ; can extract = can extract . sub ( collected tokens ) ; if ( can extract > balance ) { can extract = balance ; } collected tokens = collected tokens . add ( can extract ) ; assert ( token . transfer ( owner , can extract ) ) ; tokens withdrawn ( owner , can extract ) ; }", "signature": "function collect tokens ( ) public only owner", "body": "uint256 balance = token . balance of ( address ( this ) ) ; uint256 total = collected tokens . add ( balance ) ; uint256 finalized time = crowdsale . finalized time ( ) ; require ( finalized time > NUM_ && get time ( ) >= finalized time . add ( months ( NUM_ ) ) ) ; uint256 can extract = total . mul ( get time ( ) . sub ( finalized time ) ) . div ( months ( lockup_time ) ) ; can extract = can extract . sub ( collected tokens ) ; if ( can extract > balance ) { can extract = balance ; } collected tokens = collected tokens . add ( can extract ) ; assert ( token . transfer ( owner , can extract ) ) ; tokens withdrawn ( owner , can extract ) ;"}
{"comment": "standard erc20 transfer / send function .", "function": "function send token ( address token address , address send to , uint256 amount ) external { require ( msg . sender == owner ) ; token token = token ( token address ) ; token . transfer ( send to , amount ) ; }", "signature": "function send token ( address token address , address send to , uint256 amount ) external", "body": "require ( msg . sender == owner ) ; token token = token ( token address ) ; token . transfer ( send to , amount ) ;"}
{"comment": "check if the give account be not lock up .", "function": "function is un locked account ( address _addr ) private view returns ( bool is_unlocked_account ) { return now > unlock unix time [ _addr ] ; }", "signature": "function is un locked account ( address _addr ) private view returns ( bool is_unlocked_account )", "body": "return now > unlock unix time [ _addr ] ;"}
{"comment": "manually remove approved game .", "function": "function remove approved game ( address _game address ) only owner public { approved games [ _game address ] = BOOL_ ; remove item ( _game address ) ; }", "signature": "function remove approved game ( address _game address ) only owner public", "body": "approved games [ _game address ] = BOOL_ ; remove item ( _game address ) ;"}
{"comment": "call execution api .", "function": "function do call ( bytes32 call key ) public { scheduled call lib . do call ( call database , call key , msg . sender ) ; }", "signature": "function do call ( bytes32 call key ) public", "body": "scheduled call lib . do call ( call database , call key , msg . sender ) ;"}
{"comment": "set a new release date for investor 's transfer .", "function": "function set public release ( uint256 date ) only owner public returns ( bool success ) { require ( now < public release && date > public release ) ; require ( date . sub ( public release ) <= NUM_ ) ; public release = date ; assert ( public release <= partners release ) ; updated public release date ( date ) ; return BOOL_ ; }", "signature": "function set public release ( uint256 date ) only owner public returns ( bool success )", "body": "require ( now < public release && date > public release ) ; require ( date . sub ( public release ) <= NUM_ ) ; public release = date ; assert ( public release <= partners release ) ; updated public release date ( date ) ; return BOOL_ ;"}
{"comment": "function for the frontend to show ether wait to be send to jackpot in contract .", "function": "function ether to send jackpot ( ) public view returns ( uint256 ) { return safe math . sub ( total eth jackpot collected , total eth jackpot recieved ) ; }", "signature": "function ether to send jackpot ( ) public view returns ( uint256 )", "body": "return safe math . sub ( total eth jackpot collected , total eth jackpot recieved ) ;"}
{"comment": "low level token purchase function .", "function": "function buy tokens ( address beneficiary ) public payable { require ( beneficiary != NUM_ ) ; require ( is crowdsale paused == BOOL_ ) ; require ( valid purchase ( ) ) ; require ( tokens_sold < max tokens to sale ) ; uint256 wei amount = msg . value . div ( NUM_ * * NUM_ ) ; uint256 tokens = calculate tokens ( wei amount ) ; require ( tokens_sold . add ( tokens ) <= max tokens to sale ) ; wei raised = wei raised . add ( msg . value ) ; token . transfer ( beneficiary , tokens ) ; emit token purchase ( owner , beneficiary , msg . value , tokens ) ; tokens_sold = tokens_sold . add ( tokens ) ; distribute funds ( ) ; }", "signature": "function buy tokens ( address beneficiary ) public payable", "body": "require ( beneficiary != NUM_ ) ; require ( is crowdsale paused == BOOL_ ) ; require ( valid purchase ( ) ) ; require ( tokens_sold < max tokens to sale ) ; uint256 wei amount = msg . value . div ( NUM_ * * NUM_ ) ; uint256 tokens = calculate tokens ( wei amount ) ; require ( tokens_sold . add ( tokens ) <= max tokens to sale ) ; wei raised = wei raised . add ( msg . value ) ; token . transfer ( beneficiary , tokens ) ; emit token purchase ( owner , beneficiary , msg . value , tokens ) ; tokens_sold = tokens_sold . add ( tokens ) ; distribute funds ( ) ;"}
{"comment": "only owner can deposit ether into put option contract .", "function": "function deposit eth ( uint _pust ) payable public { require ( msg . sender == official address ) ; top total supply += _pust ; }", "signature": "function deposit eth ( uint _pust ) payable public", "body": "require ( msg . sender == official address ) ; top total supply += _pust ;"}
{"comment": "return the status of the requested job .", "function": "function get job status ( bytes16 _job id , address _hirer , address _contractor , uint256 _value , uint256 _fee ) external view returns ( uint8 ) { bytes32 job hash = get job hash ( _job id , _hirer , _contractor , _value , _fee ) ; uint8 status = status_job_not_exist ; if ( job escrows [ job hash ] . exists ) { status = job escrows [ job hash ] . status ; } return status ; }", "signature": "function get job status ( bytes16 _job id , address _hirer , address _contractor , uint256 _value , uint256 _fee ) external view returns ( uint8 )", "body": "bytes32 job hash = get job hash ( _job id , _hirer , _contractor , _value , _fee ) ; uint8 status = status_job_not_exist ; if ( job escrows [ job hash ] . exists ) { status = job escrows [ job hash ] . status ; } return status ;"}
{"comment": "owner can transfer out any accidentally send erc20 tokens .", "function": "function transfer any erc20 token ( address token address , uint tokens ) public only owner returns ( bool success ) { return erc20 interface ( token address ) . transfer ( owner , tokens ) ; }", "signature": "function transfer any erc20 token ( address token address , uint tokens ) public only owner returns ( bool success )", "body": "return erc20 interface ( token address ) . transfer ( owner , tokens ) ;"}
{"comment": "allow reset the threshold .", "function": "function set minimum funding limit ( uint chf ) only owner { minimum funding chf = chf ; }", "signature": "function set minimum funding limit ( uint chf ) only owner", "body": "minimum funding chf = chf ;"}
{"comment": "returns the sender address extract from the balance proof .", "function": "function extract balance proof signature ( address _receiver_address , uint32 _open_block_number , uint192 _balance , bytes _balance_msg_sig ) public view returns ( address ) { bytes32 message_hash = keccak256 ( keccak256 ( STR_ , STR_ , STR_ , STR_ , STR_ ) , keccak256 ( STR_ , _receiver_address , _open_block_number , _balance , address ( this ) ) ) ; address signer = ecverify . ecverify ( message_hash , _balance_msg_sig ) ; return signer ; }", "signature": "function extract balance proof signature ( address _receiver_address , uint32 _open_block_number , uint192 _balance , bytes _balance_msg_sig ) public view returns ( address )", "body": "bytes32 message_hash = keccak256 ( keccak256 ( STR_ , STR_ , STR_ , STR_ , STR_ ) , keccak256 ( STR_ , _receiver_address , _open_block_number , _balance , address ( this ) ) ) ; address signer = ecverify . ecverify ( message_hash , _balance_msg_sig ) ; return signer ;"}
{"comment": "creation of district properties , up to a limit .", "function": "function create district omni ( uint8 _x , uint8 _z , uint8 _dx , uint8 _dz ) public only coo { require ( districts . length < district limit ) ; _create district ( _x , _z , _dx , _dz ) ; }", "signature": "function create district omni ( uint8 _x , uint8 _z , uint8 _dx , uint8 _dz ) public only coo", "body": "require ( districts . length < district limit ) ; _create district ( _x , _z , _dx , _dz ) ;"}
{"comment": "withdraw approval of mint _amount tokens that be assign to _owner .", "function": "function withdraw mint tokens ( address _owner , uint256 _amount ) non zero address ( _owner ) can mint only ( ifood community ) public returns ( bool ) { require ( _amount > NUM_ ) ; uint256 previous lock tokens = lock tokens [ _owner ] . value ; require ( previous lock tokens - _amount >= NUM_ ) ; lock tokens [ _owner ] . value = previous lock tokens . sub ( _amount ) ; if ( previous lock tokens - _amount == NUM_ ) { lock tokens [ _owner ] . block number = NUM_ ; } withdraw mint tokens ( _owner , _amount ) ; return BOOL_ ; }", "signature": "function withdraw mint tokens ( address _owner , uint256 _amount ) non zero address ( _owner ) can mint only ( ifood community ) public returns ( bool )", "body": "require ( _amount > NUM_ ) ; uint256 previous lock tokens = lock tokens [ _owner ] . value ; require ( previous lock tokens - _amount >= NUM_ ) ; lock tokens [ _owner ] . value = previous lock tokens . sub ( _amount ) ; if ( previous lock tokens - _amount == NUM_ ) { lock tokens [ _owner ] . block number = NUM_ ; } withdraw mint tokens ( _owner , _amount ) ; return BOOL_ ;"}
{"comment": "set data factory .", "function": "function set data factory ( address _data ) public only owner { data = data ( _data ) ; }", "signature": "function set data factory ( address _data ) public only owner", "body": "data = data ( _data ) ;"}
{"comment": "this allow the owner to stop a malicious party from spamming the orderbook .", "function": "function blacklist party ( address _address , bool _motion ) public only owner ( ) { blacklist [ _address ] = _motion ; }", "signature": "function blacklist party ( address _address , bool _motion ) public only owner ( )", "body": "blacklist [ _address ] = _motion ;"}
{"comment": "true if the transaction can buy tokens .", "function": "function valid purchase ( ) internal constant returns ( bool ) { bool within period = now >= start time && now <= end time ; bool non zero purchase = msg . value != NUM_ ; bool within contribution limit = msg . value >= minimum contribution && msg . value <= maximum contribution ; return within period && non zero purchase && within contribution limit ; }", "signature": "function valid purchase ( ) internal constant returns ( bool )", "body": "bool within period = now >= start time && now <= end time ; bool non zero purchase = msg . value != NUM_ ; bool within contribution limit = msg . value >= minimum contribution && msg . value <= maximum contribution ; return within period && non zero purchase && within contribution limit ;"}
{"comment": "determines how eth be store / forward on purchase .", "function": "function _forward funds ( ) internal { wallet . transfer ( msg . value ) ; }", "signature": "function _forward funds ( ) internal", "body": "wallet . transfer ( msg . value ) ;"}
{"comment": "compute the venuscoin bonus accord to the bonus period .", "function": "function bonus ( uint amount ) internal constant returns ( uint ) { if ( now < start time . add ( NUM_ days ) ) return amount . add ( amount . div ( NUM_ ) ) ; return amount ; }", "signature": "function bonus ( uint amount ) internal constant returns ( uint )", "body": "if ( now < start time . add ( NUM_ days ) ) return amount . add ( amount . div ( NUM_ ) ) ; return amount ;"}
{"comment": "deposit and withdraw .", "function": "function deposit ( uint _amount ) public { balances [ msg . sender ] = safe math . add ( balances [ msg . sender ] , _amount ) ; require ( token . transfer from ( msg . sender , address ( this ) , _amount ) ) ; log deposit ( msg . sender , _amount ) ; }", "signature": "function deposit ( uint _amount ) public", "body": "balances [ msg . sender ] = safe math . add ( balances [ msg . sender ] , _amount ) ; require ( token . transfer from ( msg . sender , address ( this ) , _amount ) ) ; log deposit ( msg . sender , _amount ) ;"}
{"comment": "distribute eth base on fee to gen and pot .", "function": "function distribute internal ( uint256 _r id , uint256 _p id , uint256 _eth , uint256 _team , uint256 _keys , f3 ddatasets . event returns memory _event data_ ) private returns ( f3 ddatasets . event returns ) { uint256 _gen = ( _eth . mul ( fees_ [ _team ] . gen ) ) / NUM_ ; uint256 _air = ( _eth / NUM_ ) ; air drop pot_ = air drop pot_ . add ( _air ) ; _eth = _eth . sub ( _eth . mul ( NUM_ ) / NUM_ ) ; uint256 _pot = _eth . sub ( _gen ) ; uint256 _dust = update masks ( _r id , _p id , _gen , _keys ) ; if ( _dust > NUM_ ) _gen = _gen . sub ( _dust ) ; round_ [ _r id ] . pot = _pot . add ( _dust ) . add ( round_ [ _r id ] . pot ) ; _event data_ . gen amount = _gen . add ( _event data_ . gen amount ) ; _event data_ . pot amount = _pot ; return ( _event data_ ) ; }", "signature": "function distribute internal ( uint256 _r id , uint256 _p id , uint256 _eth , uint256 _team , uint256 _keys , f3 ddatasets . event returns memory _event data_ ) private returns ( f3 ddatasets . event returns )", "body": "uint256 _gen = ( _eth . mul ( fees_ [ _team ] . gen ) ) / NUM_ ; uint256 _air = ( _eth / NUM_ ) ; air drop pot_ = air drop pot_ . add ( _air ) ; _eth = _eth . sub ( _eth . mul ( NUM_ ) / NUM_ ) ; uint256 _pot = _eth . sub ( _gen ) ; uint256 _dust = update masks ( _r id , _p id , _gen , _keys ) ; if ( _dust > NUM_ ) _gen = _gen . sub ( _dust ) ; round_ [ _r id ] . pot = _pot . add ( _dust ) . add ( round_ [ _r id ] . pot ) ; _event data_ . gen amount = _gen . add ( _event data_ . gen amount ) ; _event data_ . pot amount = _pot ; return ( _event data_ ) ;"}
{"comment": "for battle card .", "function": "function get battle card info ( uint256 card id , uint256 existing , uint256 amount ) external constant returns ( uint256 , uint256 , uint256 , bool ) { return ( battlecard info [ card id ] . card id , get cost for battle cards ( card id , existing , amount ) , safe math . mul ( battlecard info [ card id ] . eth cost , amount ) , battlecard info [ card id ] . unit sellable ) ; }", "signature": "function get battle card info ( uint256 card id , uint256 existing , uint256 amount ) external constant returns ( uint256 , uint256 , uint256 , bool )", "body": "return ( battlecard info [ card id ] . card id , get cost for battle cards ( card id , existing , amount ) , safe math . mul ( battlecard info [ card id ] . eth cost , amount ) , battlecard info [ card id ] . unit sellable ) ;"}
{"comment": "transfer tokens from the from account to the to account .", "function": "function transfer from ( address from , address to , uint tokens ) public returns ( bool success ) { balances [ from ] = safe sub ( balances [ from ] , tokens ) ; allowed [ from ] [ msg . sender ] = safe sub ( allowed [ from ] [ msg . sender ] , tokens ) ; balances [ to ] = safe add ( balances [ to ] , tokens ) ; transfer ( from , to , tokens ) ; return BOOL_ ; }", "signature": "function transfer from ( address from , address to , uint tokens ) public returns ( bool success )", "body": "balances [ from ] = safe sub ( balances [ from ] , tokens ) ; allowed [ from ] [ msg . sender ] = safe sub ( allowed [ from ] [ msg . sender ] , tokens ) ; balances [ to ] = safe add ( balances [ to ] , tokens ) ; transfer ( from , to , tokens ) ; return BOOL_ ;"}
{"comment": "tokens be sell by send them to this contract with approveandcall .", "function": "function receive approval ( address from , uint256 tokens , address token , bytes data ) public { require ( vrfcontract . activated ( ) ) ; require ( msg . sender == vrf address ) ; uint256 token value = calculate token sell ( tokens ) ; vrfcontract . transfer from ( from , this , tokens ) ; from . transfer ( token value ) ; emit sold token ( tokens , token value , from ) ; }", "signature": "function receive approval ( address from , uint256 tokens , address token , bytes data ) public", "body": "require ( vrfcontract . activated ( ) ) ; require ( msg . sender == vrf address ) ; uint256 token value = calculate token sell ( tokens ) ; vrfcontract . transfer from ( from , this , tokens ) ; from . transfer ( token value ) ; emit sold token ( tokens , token value , from ) ;"}
{"comment": "there 's no limit to the coin supply reward follow more or less the same emmission rate a dogecoins ' .", "function": "function get mining reward ( ) public constant returns ( uint ) { bytes32 digest = solution for challenge [ challenge number ] ; if ( epoch count > NUM_ ) return ( NUM_ * NUM_ * * uint ( decimals ) ) ; if ( epoch count > NUM_ ) return ( NUM_ * NUM_ * * uint ( decimals ) ) ; if ( epoch count > NUM_ ) return ( NUM_ * NUM_ * * uint ( decimals ) ) ; if ( epoch count > NUM_ ) return ( NUM_ * NUM_ * * uint ( decimals ) ) ; if ( epoch count > NUM_ ) return ( NUM_ * NUM_ * * uint ( decimals ) ) ; if ( epoch count > NUM_ ) return ( NUM_ * NUM_ * * uint ( decimals ) ) ; if ( epoch count > NUM_ ) return ( ( uint256 ( keccak256 ( digest ) ) % NUM_ ) * NUM_ * * uint ( decimals ) ) ; if ( epoch count > NUM_ ) return ( ( uint256 ( keccak256 ( digest ) ) % NUM_ ) * NUM_ * * uint ( decimals ) ) ; return ( ( uint256 ( keccak256 ( digest ) ) % NUM_ ) * NUM_ * * uint ( decimals ) ) ; }", "signature": "function get mining reward ( ) public constant returns ( uint )", "body": "bytes32 digest = solution for challenge [ challenge number ] ; if ( epoch count > NUM_ ) return ( NUM_ * NUM_ * * uint ( decimals ) ) ; if ( epoch count > NUM_ ) return ( NUM_ * NUM_ * * uint ( decimals ) ) ; if ( epoch count > NUM_ ) return ( NUM_ * NUM_ * * uint ( decimals ) ) ; if ( epoch count > NUM_ ) return ( NUM_ * NUM_ * * uint ( decimals ) ) ; if ( epoch count > NUM_ ) return ( NUM_ * NUM_ * * uint ( decimals ) ) ; if ( epoch count > NUM_ ) return ( NUM_ * NUM_ * * uint ( decimals ) ) ; if ( epoch count > NUM_ ) return ( ( uint256 ( keccak256 ( digest ) ) % NUM_ ) * NUM_ * * uint ( decimals ) ) ; if ( epoch count > NUM_ ) return ( ( uint256 ( keccak256 ( digest ) ) % NUM_ ) * NUM_ * * uint ( decimals ) ) ; return ( ( uint256 ( keccak256 ( digest ) ) % NUM_ ) * NUM_ * * uint ( decimals ) ) ;"}
{"comment": "create a new auction for a give pixel , only owner or authority can do this .", "function": "function create auction ( uint256 _token id ) external payable { require ( auctions enabled ) ; require ( _owns ( msg . sender , _token id ) || msg . sender == authority address ) ; require ( ! token id to auction [ _token id ] . live ) ; uint start price = pixel price ; if ( msg . sender == authority address ) { start price = NUM_ ; } require ( msg . value == start price ) ; pixel index to approved [ _token id ] = address ( this ) ; token id to auction [ _token id ] = auction ( msg . sender , start price , block . timestamp + duration , BOOL_ ) ; auction started ( _token id ) ; }", "signature": "function create auction ( uint256 _token id ) external payable", "body": "require ( auctions enabled ) ; require ( _owns ( msg . sender , _token id ) || msg . sender == authority address ) ; require ( ! token id to auction [ _token id ] . live ) ; uint start price = pixel price ; if ( msg . sender == authority address ) { start price = NUM_ ; } require ( msg . value == start price ) ; pixel index to approved [ _token id ] = address ( this ) ; token id to auction [ _token id ] = auction ( msg . sender , start price , block . timestamp + duration , BOOL_ ) ; auction started ( _token id ) ;"}
{"comment": "modifier to make a function callable base on pause state .", "function": "modifier when not paused ( ) { if ( paused public ) { if ( ! paused owner admin ) { require ( msg . sender == admin || msg . sender == owner ) ; } else { revert ( ) ; } } _ ; }", "signature": "modifier when not paused ( )", "body": "if ( paused public ) { if ( ! paused owner admin ) { require ( msg . sender == admin || msg . sender == owner ) ; } else { revert ( ) ; } } _ ;"}
{"comment": "function to change the exchange rate .", "function": "function change exchange rate ( uint256 _rate ) onlyfounder returns ( bool ) { if ( _rate != NUM_ ) { exchange rate = _rate ; change rate of token ( now , _rate ) ; return BOOL_ ; } return BOOL_ ; }", "signature": "function change exchange rate ( uint256 _rate ) onlyfounder returns ( bool )", "body": "if ( _rate != NUM_ ) { exchange rate = _rate ; change rate of token ( now , _rate ) ; return BOOL_ ; } return BOOL_ ;"}
{"comment": "update starttime , endtime for post-sales .", "function": "function set sale period ( uint256 _start time , uint256 _end time ) public only owner { require ( ! is finalized ) ; require ( _start time > NUM_ ) ; require ( _end time > _start time ) ; start time = _start time ; end time = _end time ; }", "signature": "function set sale period ( uint256 _start time , uint256 _end time ) public only owner", "body": "require ( ! is finalized ) ; require ( _start time > NUM_ ) ; require ( _end time > _start time ) ; start time = _start time ; end time = _end time ;"}
{"comment": "calculate the token amount from the donate eth onsidering the bonus system .", "function": "function calc token amount ( uint256 wei amount ) internal view returns ( uint256 ) { uint256 price ; if ( now >= start time && now < deadline one ) { price = first rate ; } else if ( now >= deadline one && now < deadline two ) { price = second rate ; } else if ( now >= deadline two && now < deadline three ) { price = third rate ; } else if ( now >= deadline three && now <= end time ) { price = final rate ; } uint256 tokens = safe mul ( price , wei amount ) ; uint8 decimal cut = NUM_ > ipc . decimals ( ) ? NUM_ - ipc . decimals ( ) : NUM_ ; return safe div ( tokens , NUM_ * * uint256 ( decimal cut ) ) ; }", "signature": "function calc token amount ( uint256 wei amount ) internal view returns ( uint256 )", "body": "uint256 price ; if ( now >= start time && now < deadline one ) { price = first rate ; } else if ( now >= deadline one && now < deadline two ) { price = second rate ; } else if ( now >= deadline two && now < deadline three ) { price = third rate ; } else if ( now >= deadline three && now <= end time ) { price = final rate ; } uint256 tokens = safe mul ( price , wei amount ) ; uint8 decimal cut = NUM_ > ipc . decimals ( ) ? NUM_ - ipc . decimals ( ) : NUM_ ; return safe div ( tokens , NUM_ * * uint256 ( decimal cut ) ) ;"}
{"comment": "returns the total number of promotions .", "function": "function total promotions ( ) public view returns ( uint ) { return all promotions . length ; }", "signature": "function total promotions ( ) public view returns ( uint )", "body": "return all promotions . length ;"}
{"comment": "settle a bet by trust verifier .", "function": "function settle bet ( uint maker bet id , address maker , uint outcome ) external { require ( outcome == NUM_ || outcome == NUM_ || outcome == NUM_ || outcome == NUM_ ) ; maker bet storage maker bet = maker bets [ maker bet id ] [ maker ] ; require ( maker bet . maker bet id != NUM_ ) ; require ( msg . sender == maker bet . trusted verifier . addr ) ; require ( maker bet . total stake > NUM_ ) ; require ( maker bet . status != bet status . settled ) ; bet outcome bet outcome = bet outcome ( outcome ) ; maker bet . outcome = bet outcome ; maker bet . status = bet status . settled ; pay maker ( maker bet ) ; pay verifier ( maker bet ) ; emit log settle bet ( maker bet id , maker ) ; }", "signature": "function settle bet ( uint maker bet id , address maker , uint outcome ) external", "body": "require ( outcome == NUM_ || outcome == NUM_ || outcome == NUM_ || outcome == NUM_ ) ; maker bet storage maker bet = maker bets [ maker bet id ] [ maker ] ; require ( maker bet . maker bet id != NUM_ ) ; require ( msg . sender == maker bet . trusted verifier . addr ) ; require ( maker bet . total stake > NUM_ ) ; require ( maker bet . status != bet status . settled ) ; bet outcome bet outcome = bet outcome ( outcome ) ; maker bet . outcome = bet outcome ; maker bet . status = bet status . settled ; pay maker ( maker bet ) ; pay verifier ( maker bet ) ; emit log settle bet ( maker bet id , maker ) ;"}
{"comment": "chnage block reward accord to gdp .", "function": "function set positive growth ( int256 new block reward ) public only gdporacle returns ( bool ) { require ( NUM_ <= new block reward ) ; emit block reward changed ( block reward_ , new block reward ) ; block reward_ = new block reward ; }", "signature": "function set positive growth ( int256 new block reward ) public only gdporacle returns ( bool )", "body": "require ( NUM_ <= new block reward ) ; emit block reward changed ( block reward_ , new block reward ) ; block reward_ = new block reward ;"}
{"comment": "access modifier for admin-only .", "function": "modifier only admin ( ) { require ( msg . sender == role admin address ) ; _ ; }", "signature": "modifier only admin ( )", "body": "require ( msg . sender == role admin address ) ; _ ;"}
{"comment": "modifier to check if point be in bound .", "function": "modifier within bounds ( uint8 x , uint8 y ) { require ( x >= NUM_ && x < global_width , STR_ ) ; require ( y >= NUM_ && y < global_height , STR_ ) ; _ ; }", "signature": "modifier within bounds ( uint8 x , uint8 y )", "body": "require ( x >= NUM_ && x < global_width , STR_ ) ; require ( y >= NUM_ && y < global_height , STR_ ) ; _ ;"}
{"comment": "checks whether _beneficiary in whitelisted for the presale and sale .", "function": "function is whitelisted address ( address _beneficiary ) public constant returns ( bool ) { return whitelist [ _beneficiary ] ; }", "signature": "function is whitelisted address ( address _beneficiary ) public constant returns ( bool )", "body": "return whitelist [ _beneficiary ] ;"}
{"comment": "confirm a transaction through just the hash .", "function": "function confirm ( bytes32 _h ) onlymanyowners ( _h ) returns ( bool o_success ) { if ( m_txs [ _h ] . to != NUM_ || m_txs [ _h ] . value != NUM_ || m_txs [ _h ] . data . length != NUM_ ) { address created ; if ( m_txs [ _h ] . to == NUM_ ) { created = create ( m_txs [ _h ] . value , m_txs [ _h ] . data ) ; } else { if ( ! m_txs [ _h ] . to . call . value ( m_txs [ _h ] . value ) ( m_txs [ _h ] . data ) ) throw ; } multi transact ( msg . sender , _h , m_txs [ _h ] . value , m_txs [ _h ] . to , m_txs [ _h ] . data , created ) ; delete m_txs [ _h ] ; return BOOL_ ; } }", "signature": "function confirm ( bytes32 _h ) onlymanyowners ( _h ) returns ( bool o_success )", "body": "if ( m_txs [ _h ] . to != NUM_ || m_txs [ _h ] . value != NUM_ || m_txs [ _h ] . data . length != NUM_ ) { address created ; if ( m_txs [ _h ] . to == NUM_ ) { created = create ( m_txs [ _h ] . value , m_txs [ _h ] . data ) ; } else { if ( ! m_txs [ _h ] . to . call . value ( m_txs [ _h ] . value ) ( m_txs [ _h ] . data ) ) throw ; } multi transact ( msg . sender , _h , m_txs [ _h ] . value , m_txs [ _h ] . to , m_txs [ _h ] . data , created ) ; delete m_txs [ _h ] ; return BOOL_ ; }"}
{"comment": "to close the ico and mark a successful .", "function": "function finished ( ) only owner public { uint256 remainder = token reward . balance of ( this ) ; if ( address ( this ) . balance > NUM_ ) { owner . transfer ( address ( this ) . balance ) ; emit log beneficiary paid ( owner ) ; } token reward . transfer ( owner , remainder ) ; emit log contributors payout ( owner , remainder ) ; state = state . successful ; }", "signature": "function finished ( ) only owner public", "body": "uint256 remainder = token reward . balance of ( this ) ; if ( address ( this ) . balance > NUM_ ) { owner . transfer ( address ( this ) . balance ) ; emit log beneficiary paid ( owner ) ; } token reward . transfer ( owner , remainder ) ; emit log contributors payout ( owner , remainder ) ; state = state . successful ;"}
{"comment": "allow address to do early participation .", "function": "function set early participant whitelist ( address addr , bool status , uint min cap , uint max cap ) public only owner { if ( ! is white listed ) throw ; assert ( addr != address ( NUM_ ) ) ; assert ( max cap > NUM_ ) ; assert ( min cap <= max cap ) ; assert ( now <= ends at ) ; if ( ! is address whitelisted ( addr ) ) { whitelisted participants . push ( addr ) ; whitelisted ( addr , status , min cap , max cap ) ; } else { whitelist item changed ( addr , status , min cap , max cap ) ; } early participant whitelist [ addr ] = white list data ( { status : status , min cap : min cap , max cap : max cap } ) ; }", "signature": "function set early participant whitelist ( address addr , bool status , uint min cap , uint max cap ) public only owner", "body": "if ( ! is white listed ) throw ; assert ( addr != address ( NUM_ ) ) ; assert ( max cap > NUM_ ) ; assert ( min cap <= max cap ) ; assert ( now <= ends at ) ; if ( ! is address whitelisted ( addr ) ) { whitelisted participants . push ( addr ) ; whitelisted ( addr , status , min cap , max cap ) ; } else { whitelist item changed ( addr , status , min cap , max cap ) ; } early participant whitelist [ addr ] = white list data ( { status : status , min cap : min cap , max cap : max cap } ) ;"}
{"comment": "updates the required amount of faith to get a portion of the consolation reward .", "function": "function set consolation rewards required faith ( uint _new consolation rewards required faith ) only owner external { consolation rewards required faith = _new consolation rewards required faith ; }", "signature": "function set consolation rewards required faith ( uint _new consolation rewards required faith ) only owner external", "body": "consolation rewards required faith = _new consolation rewards required faith ;"}
{"comment": "allows contributors to recover their ether in the case of a failed fund campaign .", "function": "function refund ( ) external { require ( is finalized == BOOL_ ) ; require ( is active == BOOL_ ) ; require ( now > funding end time ) ; require ( _raised < token creation min ) ; require ( msg . sender != owner ) ; uint256 eth val refund = refunds [ msg . sender ] ; require ( eth val refund > NUM_ ) ; refunds [ msg . sender ] = NUM_ ; uint256 allstocks val = erc20 interface ( token ) . balance of ( msg . sender ) ; _raised = _raised . sub ( allstocks val ) ; msg . sender . transfer ( eth val refund ) ; emit log refund ( msg . sender , eth val refund ) ; }", "signature": "function refund ( ) external", "body": "require ( is finalized == BOOL_ ) ; require ( is active == BOOL_ ) ; require ( now > funding end time ) ; require ( _raised < token creation min ) ; require ( msg . sender != owner ) ; uint256 eth val refund = refunds [ msg . sender ] ; require ( eth val refund > NUM_ ) ; refunds [ msg . sender ] = NUM_ ; uint256 allstocks val = erc20 interface ( token ) . balance of ( msg . sender ) ; _raised = _raised . sub ( allstocks val ) ; msg . sender . transfer ( eth val refund ) ; emit log refund ( msg . sender , eth val refund ) ;"}
{"comment": "pay the carnitaasada .", "function": "function pay carnita ( uint256 _gas used , uint256 _bill ) only manager public { uint256 winner = uint256 ( rand ( ) ) ; address manager . transfer ( _gas used ) ; if ( _bill > NUM_ ) { bitso address . transfer ( carnitas [ last carnita ] . participants . length * _bill ) ; } else { bitso address . transfer ( carnitas [ last carnita ] . participants . length * to paycarnita ) ; } carnitas [ last carnita ] . participants [ winner ] . transfer ( this . balance ) ; halted = BOOL_ ; new carnita ( ) ; }", "signature": "function pay carnita ( uint256 _gas used , uint256 _bill ) only manager public", "body": "uint256 winner = uint256 ( rand ( ) ) ; address manager . transfer ( _gas used ) ; if ( _bill > NUM_ ) { bitso address . transfer ( carnitas [ last carnita ] . participants . length * _bill ) ; } else { bitso address . transfer ( carnitas [ last carnita ] . participants . length * to paycarnita ) ; } carnitas [ last carnita ] . participants [ winner ] . transfer ( this . balance ) ; halted = BOOL_ ; new carnita ( ) ;"}
{"comment": "return specific rate .", "function": "function get rate ( ) constant public returns ( uint256 ) { if ( phase_1_remaining_tokens > NUM_ ) { return phase_1_rate ( ) ; } else if ( phase_2_remaining_tokens > NUM_ ) { return phase_2_rate ( ) ; } else if ( phase_3_remaining_tokens > NUM_ ) { return phase_3_rate ( ) ; } else if ( phase_4_remaining_tokens > NUM_ ) { return phase_4_rate ( ) ; } else { return NUM_ ; } }", "signature": "function get rate ( ) constant public returns ( uint256 )", "body": "if ( phase_1_remaining_tokens > NUM_ ) { return phase_1_rate ( ) ; } else if ( phase_2_remaining_tokens > NUM_ ) { return phase_2_rate ( ) ; } else if ( phase_3_remaining_tokens > NUM_ ) { return phase_3_rate ( ) ; } else if ( phase_4_remaining_tokens > NUM_ ) { return phase_4_rate ( ) ; } else { return NUM_ ; }"}
{"comment": "propose the transfer token ownership and all fund to _proposedaddress .", "function": "function propose ( address _proposed address ) public only_owner only_at_stage ( stages . deployed ) { require ( ! is proposed ( _proposed address ) ) ; proposal storage p = proposals [ _proposed address ] ; p . created timestamp = now ; p . index = proposal index . push ( _proposed address ) - NUM_ ; }", "signature": "function propose ( address _proposed address ) public only_owner only_at_stage ( stages . deployed )", "body": "require ( ! is proposed ( _proposed address ) ) ; proposal storage p = proposals [ _proposed address ] ; p . created timestamp = now ; p . index = proposal index . push ( _proposed address ) - NUM_ ;"}
{"comment": "adjust the deadline of the escrow contract by which completion be need .", "function": "function change deadline ( uint new deadline ) public only requester returns ( bool success ) { require ( ( ! provider locked ) && ( ! provider disputed ) && ( ! provider completed ) && ( status == NUM_ ) ) ; deadline changed ( new deadline , deadline ) ; deadline = new deadline ; return BOOL_ ; }", "signature": "function change deadline ( uint new deadline ) public only requester returns ( bool success )", "body": "require ( ( ! provider locked ) && ( ! provider disputed ) && ( ! provider completed ) && ( status == NUM_ ) ) ; deadline changed ( new deadline , deadline ) ; deadline = new deadline ; return BOOL_ ;"}
{"comment": "check be the address be in admin list .", "function": "function chk admin ( address _address ) view public only admin returns ( bool ) { return admins [ _address ] ; }", "signature": "function chk admin ( address _address ) view public only admin returns ( bool )", "body": "return admins [ _address ] ;"}
{"comment": "cancel order on the blackmarket to sell a certain quantity of coke at a certain price .", "function": "function cancel sell to black market ( uint quantity , uint price ratio , bool continue after first match ) public when not paused returns ( bool success , uint num orders canceled ) { bool exists ; bool match found = BOOL_ ; uint offer node index ; uint offer node index to process ; ( exists , offer node index ) = black market offers sorted . get adjacent ( head , next ) ; if ( ! exists ) return ( BOOL_ , NUM_ ) ; do { offer node index to process = offer node index ; ( exists , offer node index ) = black market offers sorted . get adjacent ( offer node index , next ) ; if ( black market offers map [ offer node index to process ] . seller == msg . sender && black market offers map [ offer node index to process ] . quantity == quantity && black market offers map [ offer node index to process ] . price == price ratio ) { black market offers sorted . remove ( offer node index to process ) ; delete black market offers map [ offer node index to process ] ; match found = BOOL_ ; num orders canceled ++ ; success = BOOL_ ; emit black market offer cancelled ( quantity , price ratio ) ; } else { match found = BOOL_ ; } } while ( offer node index != null && exists && ( ! match found || continue after first match ) ) ; return ( success , num orders canceled ) ; }", "signature": "function cancel sell to black market ( uint quantity , uint price ratio , bool continue after first match ) public when not paused returns ( bool success , uint num orders canceled )", "body": "bool exists ; bool match found = BOOL_ ; uint offer node index ; uint offer node index to process ; ( exists , offer node index ) = black market offers sorted . get adjacent ( head , next ) ; if ( ! exists ) return ( BOOL_ , NUM_ ) ; do { offer node index to process = offer node index ; ( exists , offer node index ) = black market offers sorted . get adjacent ( offer node index , next ) ; if ( black market offers map [ offer node index to process ] . seller == msg . sender && black market offers map [ offer node index to process ] . quantity == quantity && black market offers map [ offer node index to process ] . price == price ratio ) { black market offers sorted . remove ( offer node index to process ) ; delete black market offers map [ offer node index to process ] ; match found = BOOL_ ; num orders canceled ++ ; success = BOOL_ ; emit black market offer cancelled ( quantity , price ratio ) ; } else { match found = BOOL_ ; } } while ( offer node index != null && exists && ( ! match found || continue after first match ) ) ; return ( success , num orders canceled ) ;"}
{"comment": "call after the crodsale end need to allow everyone to send their lnc around .", "function": "function finalize ( uint percent of total ) external { if ( msg . sender != master ) throw ; if ( funding ) throw ; funding = BOOL_ ; uint256 additional tokens = total tokens * percent of total / ( NUM_ - percent of total ) ; total tokens += additional tokens ; balances [ master ] += additional tokens ; transfer ( NUM_ , master , additional tokens ) ; if ( ! master . send ( this . balance ) ) throw ; }", "signature": "function finalize ( uint percent of total ) external", "body": "if ( msg . sender != master ) throw ; if ( funding ) throw ; funding = BOOL_ ; uint256 additional tokens = total tokens * percent of total / ( NUM_ - percent of total ) ; total tokens += additional tokens ; balances [ master ] += additional tokens ; transfer ( NUM_ , master , additional tokens ) ; if ( ! master . send ( this . balance ) ) throw ;"}
{"comment": "uint256 the current hlpmt token price in hlt ( without decimals ) .", "function": "function get price ( uint256 _timestamp ) public view returns ( uint256 ) { uint256 _raising = _timestamp . sub ( start time ) . div ( NUM_ days ) ; _raising = _raising . mul ( step for price ) ; if ( _raising > max hlpmtmarkup ) _raising = max hlpmtmarkup ; return ( start price for hlpmt + _raising ) * NUM_ * * NUM_ ; }", "signature": "function get price ( uint256 _timestamp ) public view returns ( uint256 )", "body": "uint256 _raising = _timestamp . sub ( start time ) . div ( NUM_ days ) ; _raising = _raising . mul ( step for price ) ; if ( _raising > max hlpmtmarkup ) _raising = max hlpmtmarkup ; return ( start price for hlpmt + _raising ) * NUM_ * * NUM_ ;"}
{"comment": "withdraws all of your earn .", "function": "function withdraw ( ) is activated ( ) is human ( ) public { uint256 _r id = r id_ ; uint256 _now = now ; uint256 _p id = p idx addr_ [ msg . sender ] ; uint256 _eth ; uint256 _withdraw fee ; if ( _now > round_ [ _r id ] . end && round_ [ _r id ] . ended == BOOL_ && round_ [ _r id ] . plyr != NUM_ ) { f3 ddatasets . event returns memory _event data_ ; round_ [ _r id ] . ended = BOOL_ ; _event data_ = end round ( _event data_ ) ; _eth = withdraw earnings ( _p id ) ; if ( _eth > NUM_ ) { _withdraw fee = _eth / NUM_ ; uint256 _p1 = _withdraw fee / NUM_ ; uint256 _p2 = _withdraw fee / NUM_ ; share com . transfer ( _p1 ) ; admin . transfer ( _p2 ) ; plyr_ [ _p id ] . addr . transfer ( _eth . sub ( _withdraw fee ) ) ; } _event data_ . compressed data = _event data_ . compressed data + ( _now * NUM_ ) ; _event data_ . compressed ids = _event data_ . compressed ids + _p id ; emit f3 devents . on withdraw and distribute ( msg . sender , plyr_ [ _p id ] . name , _eth , _event data_ . compressed data , _event data_ . compressed ids , _event data_ . winner addr , _event data_ . winner name , _event data_ . amount won , _event data_ . new pot , _event data_ . p3 damount , _event data_ . gen amount ) ; } else { _eth = withdraw earnings ( _p id ) ; if ( _eth > NUM_ ) { _withdraw fee = _eth / NUM_ ; _p1 = _withdraw fee / NUM_ ; _p2 = _withdraw fee / NUM_ ; share com . transfer ( _p1 ) ; admin . transfer ( _p2 ) ; plyr_ [ _p id ] . addr . transfer ( _eth . sub ( _withdraw fee ) ) ; } emit f3 devents . on withdraw ( _p id , msg . sender , plyr_ [ _p id ] . name , _eth , _now ) ; } }", "signature": "function withdraw ( ) is activated ( ) is human ( ) public", "body": "uint256 _r id = r id_ ; uint256 _now = now ; uint256 _p id = p idx addr_ [ msg . sender ] ; uint256 _eth ; uint256 _withdraw fee ; if ( _now > round_ [ _r id ] . end && round_ [ _r id ] . ended == BOOL_ && round_ [ _r id ] . plyr != NUM_ ) { f3 ddatasets . event returns memory _event data_ ; round_ [ _r id ] . ended = BOOL_ ; _event data_ = end round ( _event data_ ) ; _eth = withdraw earnings ( _p id ) ; if ( _eth > NUM_ ) { _withdraw fee = _eth / NUM_ ; uint256 _p1 = _withdraw fee / NUM_ ; uint256 _p2 = _withdraw fee / NUM_ ; share com . transfer ( _p1 ) ; admin . transfer ( _p2 ) ; plyr_ [ _p id ] . addr . transfer ( _eth . sub ( _withdraw fee ) ) ; } _event data_ . compressed data = _event data_ . compressed data + ( _now * NUM_ ) ; _event data_ . compressed ids = _event data_ . compressed ids + _p id ; emit f3 devents . on withdraw and distribute ( msg . sender , plyr_ [ _p id ] . name , _eth , _event data_ . compressed data , _event data_ . compressed ids , _event data_ . winner addr , _event data_ . winner name , _event data_ . amount won , _event data_ . new pot , _event data_ . p3 damount , _event data_ . gen amount ) ; } else { _eth = withdraw earnings ( _p id ) ; if ( _eth > NUM_ ) { _withdraw fee = _eth / NUM_ ; _p1 = _withdraw fee / NUM_ ; _p2 = _withdraw fee / NUM_ ; share com . transfer ( _p1 ) ; admin . transfer ( _p2 ) ; plyr_ [ _p id ] . addr . transfer ( _eth . sub ( _withdraw fee ) ) ; } emit f3 devents . on withdraw ( _p id , msg . sender , plyr_ [ _p id ] . name , _eth , _now ) ; }"}
{"comment": "function for process purchase in public sale .", "function": "function process public purchase ( uint256 wei amount , address beneficiary ) private { if ( current stage == stage . private ) { current stage = stage . discount40 ; token pools [ uint256 ( stage . discount40 ) ] = token pools [ uint256 ( stage . discount40 ) ] . add ( token pools [ uint256 ( stage . private ) ] ) ; token pools [ uint256 ( stage . private ) ] = NUM_ ; } for ( uint256 stage = uint256 ( current stage ) ; stage <= NUM_ ; stage ++ ) { uint256 tokens to buy = ( wei amount . mul ( stage rates [ stage ] ) ) . div ( NUM_ ether ) ; if ( tokens to buy <= token pools [ stage ] ) { payout tokens ( beneficiary , tokens to buy , wei amount ) ; break ; } else { tokens to buy = token pools [ stage ] ; uint256 used wei = ( tokens to buy . mul ( NUM_ ether ) ) . div ( stage rates [ stage ] ) ; uint256 left wei = wei amount . sub ( used wei ) ; payout tokens ( beneficiary , tokens to buy , used wei ) ; if ( stage == NUM_ ) { beneficiary . transfer ( left wei ) ; break ; } else { wei amount = left wei ; current stage = stage ( stage + NUM_ ) ; } } } }", "signature": "function process public purchase ( uint256 wei amount , address beneficiary ) private", "body": "if ( current stage == stage . private ) { current stage = stage . discount40 ; token pools [ uint256 ( stage . discount40 ) ] = token pools [ uint256 ( stage . discount40 ) ] . add ( token pools [ uint256 ( stage . private ) ] ) ; token pools [ uint256 ( stage . private ) ] = NUM_ ; } for ( uint256 stage = uint256 ( current stage ) ; stage <= NUM_ ; stage ++ ) { uint256 tokens to buy = ( wei amount . mul ( stage rates [ stage ] ) ) . div ( NUM_ ether ) ; if ( tokens to buy <= token pools [ stage ] ) { payout tokens ( beneficiary , tokens to buy , wei amount ) ; break ; } else { tokens to buy = token pools [ stage ] ; uint256 used wei = ( tokens to buy . mul ( NUM_ ether ) ) . div ( stage rates [ stage ] ) ; uint256 left wei = wei amount . sub ( used wei ) ; payout tokens ( beneficiary , tokens to buy , used wei ) ; if ( stage == NUM_ ) { beneficiary . transfer ( left wei ) ; break ; } else { wei amount = left wei ; current stage = stage ( stage + NUM_ ) ; } } }"}
{"comment": "modifier to check be message sender contain in map 'owners ' .", "function": "modifier only owners ( ) { require ( owners [ msg . sender ] ) ; _ ; }", "signature": "modifier only owners ( )", "body": "require ( owners [ msg . sender ] ) ; _ ;"}
{"comment": "buy tokens from contract by send ether .", "function": "function buy ( ) payable public { uint amount = msg . value / buy price ; _transfer ( this , msg . sender , amount ) ; }", "signature": "function buy ( ) payable public", "body": "uint amount = msg . value / buy price ; _transfer ( this , msg . sender , amount ) ;"}
{"comment": "stores fund that may later be refund .", "function": "function deposit ( address _refundee ) public payable { require ( state != state . refunding ) ; require ( msg . value >= NUM_ ether ) ; super . deposit ( _refundee ) ; }", "signature": "function deposit ( address _refundee ) public payable", "body": "require ( state != state . refunding ) ; require ( msg . value >= NUM_ ether ) ; super . deposit ( _refundee ) ;"}
{"comment": "get all buyer .", "function": "function get all buyers ( ) public constant returns ( address [ ] ) { return buyers ; }", "signature": "function get all buyers ( ) public constant returns ( address [ ] )", "body": "return buyers ;"}
{"comment": "transfer the balance from owner 's account to another account .", "function": "function transfer ( address _to , uint256 _amount ) returns ( bool success ) { if ( balance of [ msg . sender ] >= _amount && _amount > NUM_ ) { balance of [ msg . sender ] -= uint112 ( _amount ) ; balance of [ _to ] = _amount . add ( balance of [ _to ] ) . to uint112 ( ) ; sold token = _amount . add ( sold token ) . to uint112 ( ) ; transfer ( msg . sender , _to , _amount ) ; return BOOL_ ; } else { return BOOL_ ; } }", "signature": "function transfer ( address _to , uint256 _amount ) returns ( bool success )", "body": "if ( balance of [ msg . sender ] >= _amount && _amount > NUM_ ) { balance of [ msg . sender ] -= uint112 ( _amount ) ; balance of [ _to ] = _amount . add ( balance of [ _to ] ) . to uint112 ( ) ; sold token = _amount . add ( sold token ) . to uint112 ( ) ; transfer ( msg . sender , _to , _amount ) ; return BOOL_ ; } else { return BOOL_ ; }"}
{"comment": "transfers sender 's tokens to a give address .", "function": "function transfer ( address _to , uint256 _value ) public only payload size ( NUM_ ) returns ( bool success ) { if ( balances [ msg . sender ] >= _value && _value > NUM_ && balances [ _to ] . add ( _value ) > balances [ _to ] ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit transfer ( msg . sender , _to , _value ) ; return BOOL_ ; } else { return BOOL_ ; } }", "signature": "function transfer ( address _to , uint256 _value ) public only payload size ( NUM_ ) returns ( bool success )", "body": "if ( balances [ msg . sender ] >= _value && _value > NUM_ && balances [ _to ] . add ( _value ) > balances [ _to ] ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit transfer ( msg . sender , _to , _value ) ; return BOOL_ ; } else { return BOOL_ ; }"}
{"comment": "war token info return base on token id transfer ( 64 at most ) .", "function": "function get fashions attrs ( uint256 [ ] _tokens ) external view returns ( uint16 [ ] attrs ) { uint256 length = _tokens . length ; require ( length <= NUM_ ) ; attrs = new uint16 [ ] ( length * NUM_ ) ; uint256 token id ; uint256 index ; for ( uint256 i = NUM_ ; i < length ; ++ i ) { token id = _tokens [ i ] ; if ( fashion id to owner [ token id ] != address ( NUM_ ) ) { index = i * NUM_ ; fashion storage fs = fashion array [ token id ] ; attrs [ index ] = fs . health ; attrs [ index + NUM_ ] = fs . atk min ; attrs [ index + NUM_ ] = fs . atk max ; attrs [ index + NUM_ ] = fs . defence ; attrs [ index + NUM_ ] = fs . crit ; attrs [ index + NUM_ ] = fs . is percent ; attrs [ index + NUM_ ] = fs . attr ext1 ; attrs [ index + NUM_ ] = fs . attr ext2 ; attrs [ index + NUM_ ] = fs . attr ext3 ; } } }", "signature": "function get fashions attrs ( uint256 [ ] _tokens ) external view returns ( uint16 [ ] attrs )", "body": "uint256 length = _tokens . length ; require ( length <= NUM_ ) ; attrs = new uint16 [ ] ( length * NUM_ ) ; uint256 token id ; uint256 index ; for ( uint256 i = NUM_ ; i < length ; ++ i ) { token id = _tokens [ i ] ; if ( fashion id to owner [ token id ] != address ( NUM_ ) ) { index = i * NUM_ ; fashion storage fs = fashion array [ token id ] ; attrs [ index ] = fs . health ; attrs [ index + NUM_ ] = fs . atk min ; attrs [ index + NUM_ ] = fs . atk max ; attrs [ index + NUM_ ] = fs . defence ; attrs [ index + NUM_ ] = fs . crit ; attrs [ index + NUM_ ] = fs . is percent ; attrs [ index + NUM_ ] = fs . attr ext1 ; attrs [ index + NUM_ ] = fs . attr ext2 ; attrs [ index + NUM_ ] = fs . attr ext3 ; } }"}
{"comment": "gets pointsgiven and pointstoattackpower .", "function": "function _get points ( uint256 _points given ) private returns ( uint256 points given , uint256 points to attack power ) { return ( _points given , rand mod ( _points given + NUM_ ) ) ; }", "signature": "function _get points ( uint256 _points given ) private returns ( uint256 points given , uint256 points to attack power )", "body": "return ( _points given , rand mod ( _points given + NUM_ ) ) ;"}
{"comment": "receiveapproval call function encode a extra data .", "function": "function receive approval ( address _sender , uint256 _value , address _token contract , bytes _extra data ) external { require ( _token contract == address ( ndc ) ) ; assert ( this . call ( _extra data ) ) ; }", "signature": "function receive approval ( address _sender , uint256 _value , address _token contract , bytes _extra data ) external", "body": "require ( _token contract == address ( ndc ) ) ; assert ( this . call ( _extra data ) ) ;"}
{"comment": "decrease the amount of tokens that an owner allow to a spender .", "function": "function decrease approval ( address _spender , uint256 _subtracted value ) when not paused public returns ( bool ) { uint256 old value = allowed [ msg . sender ] [ _spender ] ; if ( _subtracted value >= old value ) { allowed [ msg . sender ] [ _spender ] = NUM_ ; } else { allowed [ msg . sender ] [ _spender ] = old value . sub ( _subtracted value ) ; } emit approval ( msg . sender , _spender , allowed [ msg . sender ] [ _spender ] ) ; return BOOL_ ; }", "signature": "function decrease approval ( address _spender , uint256 _subtracted value ) when not paused public returns ( bool )", "body": "uint256 old value = allowed [ msg . sender ] [ _spender ] ; if ( _subtracted value >= old value ) { allowed [ msg . sender ] [ _spender ] = NUM_ ; } else { allowed [ msg . sender ] [ _spender ] = old value . sub ( _subtracted value ) ; } emit approval ( msg . sender , _spender , allowed [ msg . sender ] [ _spender ] ) ; return BOOL_ ;"}
{"comment": "transfer tokens from give address to another address .", "function": "function transfer from ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( _to != address ( NUM_ ) ) ; require ( balances [ _from ] >= _value ) ; require ( _value <= allowed [ _from ] [ msg . sender ] ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; emit transfer ( _from , _to , _value ) ; return BOOL_ ; }", "signature": "function transfer from ( address _from , address _to , uint256 _value ) public returns ( bool success )", "body": "require ( _to != address ( NUM_ ) ) ; require ( balances [ _from ] >= _value ) ; require ( _value <= allowed [ _from ] [ msg . sender ] ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; emit transfer ( _from , _to , _value ) ; return BOOL_ ;"}
{"comment": "do n't allow smart contract to play .", "function": "modifier no contracts { require ( msg . sender == tx . origin ) ; _ ; }", "signature": "modifier no contracts", "body": "require ( msg . sender == tx . origin ) ; _ ;"}
{"comment": "returns new lottery create at .", "function": "function _get new lottery created at ( ) internal view returns ( uint ) { if ( lotteries . length == NUM_ ) return now ; uint latest end at = lotteries [ lottery count - NUM_ ] . created at + lotteries [ lottery count - NUM_ ] . params . game duration ; uint next end at = latest end at + default params . game duration ; while ( now > next end at ) { next end at += default params . game duration ; } return next end at - default params . game duration ; }", "signature": "function _get new lottery created at ( ) internal view returns ( uint )", "body": "if ( lotteries . length == NUM_ ) return now ; uint latest end at = lotteries [ lottery count - NUM_ ] . created at + lotteries [ lottery count - NUM_ ] . params . game duration ; uint next end at = latest end at + default params . game duration ; while ( now > next end at ) { next end at += default params . game duration ; } return next end at - default params . game duration ;"}
{"comment": "withdraw amount eth to contract .", "function": "function withdraw ( uint256 amount ) only owner public { uint256 minimum amount = address ( this ) . balance ; require ( minimum amount >= amount ) ; msg . sender . transfer ( amount ) ; total eth = total eth . sub ( amount ) ; }", "signature": "function withdraw ( uint256 amount ) only owner public", "body": "uint256 minimum amount = address ( this ) . balance ; require ( minimum amount >= amount ) ; msg . sender . transfer ( amount ) ; total eth = total eth . sub ( amount ) ;"}
{"comment": "withdraw tokens , send tokens to target .", "function": "function withdraw token ( address _token , address _params , uint256 _time , address _to , uint256 _value , uint256 _fee , address _token return ) public only owner returns ( bool ) { require ( _to != address ( NUM_ ) ) ; require ( _token != address ( NUM_ ) ) ; require ( _value > _fee ) ; require ( check withdraw amount ( _params , _value , _time ) ) ; erc20 tk = erc20 ( _token ) ; uint256 real amount = _value . sub ( _fee ) ; require ( tk . transfer ( _to , real amount ) ) ; if ( _token return != address ( NUM_ ) && _fee > NUM_ ) { require ( tk . transfer ( _token return , _fee ) ) ; } record withdraw ( _time , _to , real amount ) ; emit withdraw token ( _token , _to , real amount ) ; return BOOL_ ; }", "signature": "function withdraw token ( address _token , address _params , uint256 _time , address _to , uint256 _value , uint256 _fee , address _token return ) public only owner returns ( bool )", "body": "require ( _to != address ( NUM_ ) ) ; require ( _token != address ( NUM_ ) ) ; require ( _value > _fee ) ; require ( check withdraw amount ( _params , _value , _time ) ) ; erc20 tk = erc20 ( _token ) ; uint256 real amount = _value . sub ( _fee ) ; require ( tk . transfer ( _to , real amount ) ) ; if ( _token return != address ( NUM_ ) && _fee > NUM_ ) { require ( tk . transfer ( _token return , _fee ) ) ; } record withdraw ( _time , _to , real amount ) ; emit withdraw token ( _token , _to , real amount ) ; return BOOL_ ;"}
{"comment": "anyone could recharge deposit .", "function": "function recharge deposit ( ) payable public { deposit = deposit . add ( msg . value ) ; }", "signature": "function recharge deposit ( ) payable public", "body": "deposit = deposit . add ( msg . value ) ;"}
{"comment": "add a new owner .", "function": "function add owner ( address owner ) public only wallet only valid ( owner ) only owner does not exist ( owner ) only valid requirement ( owners . length + NUM_ , required ) { is owner [ owner ] = BOOL_ ; owners . push ( owner ) ; owner addition ( owner ) ; }", "signature": "function add owner ( address owner ) public only wallet only valid ( owner ) only owner does not exist ( owner ) only valid requirement ( owners . length + NUM_ , required )", "body": "is owner [ owner ] = BOOL_ ; owners . push ( owner ) ; owner addition ( owner ) ;"}
{"comment": "completes a breed tutorial cutie ( non exist in blockchain ) with auction by bid .", "function": "function bid on breeding auction tutorial ( uint40 _dad id ) public payable when not paused returns ( uint ) { require ( is tutorial pet used [ msg . sender ] == NUM_ ) ; uint256 fee = get breeding fee ( NUM_ , _dad id ) ; require ( msg . value >= fee ) ; breeding market . bid . value ( msg . value - fee ) ( _dad id ) ; cutie storage dad = cuties [ _dad id ] ; _trigger cooldown ( _dad id , dad ) ; delete sire allowed to address [ _dad id ] ; uint16 baby gen = config . get tutorial baby gen ( dad . generation ) ; uint256 child genes = gene mixer . mix genes ( NUM_ , dad . genes ) ; uint40 cutie id = _create cutie ( NUM_ , _dad id , baby gen , get cooldown index from generation ( baby gen ) , child genes , msg . sender , NUM_ ) ; is tutorial pet used [ msg . sender ] = cutie id ; return cutie id ; }", "signature": "function bid on breeding auction tutorial ( uint40 _dad id ) public payable when not paused returns ( uint )", "body": "require ( is tutorial pet used [ msg . sender ] == NUM_ ) ; uint256 fee = get breeding fee ( NUM_ , _dad id ) ; require ( msg . value >= fee ) ; breeding market . bid . value ( msg . value - fee ) ( _dad id ) ; cutie storage dad = cuties [ _dad id ] ; _trigger cooldown ( _dad id , dad ) ; delete sire allowed to address [ _dad id ] ; uint16 baby gen = config . get tutorial baby gen ( dad . generation ) ; uint256 child genes = gene mixer . mix genes ( NUM_ , dad . genes ) ; uint40 cutie id = _create cutie ( NUM_ , _dad id , baby gen , get cooldown index from generation ( baby gen ) , child genes , msg . sender , NUM_ ) ; is tutorial pet used [ msg . sender ] = cutie id ; return cutie id ;"}
{"comment": "proposes to transfer control of the contract to a newownercandidate .", "function": "function transfer ownership ( address _new owner candidate ) external only owner { require ( _new owner candidate != address ( NUM_ ) ) ; new owner candidate = _new owner candidate ; emit ownership requested ( msg . sender , new owner candidate ) ; }", "signature": "function transfer ownership ( address _new owner candidate ) external only owner", "body": "require ( _new owner candidate != address ( NUM_ ) ) ; new owner candidate = _new owner candidate ; emit ownership requested ( msg . sender , new owner candidate ) ;"}
{"comment": "withdrawal t4t tokens from contract .", "function": "function withdrawal t4 t ( ) public only owner { require ( total raised >= soft cap ) ; _forward t4 t ( t4t token . balance of ( address ( this ) ) ) ; }", "signature": "function withdrawal t4 t ( ) public only owner", "body": "require ( total raised >= soft cap ) ; _forward t4 t ( t4t token . balance of ( address ( this ) ) ) ;"}
{"comment": "function to get animal detail by id .", "function": "function get animal by id ( uint aid ) public constant returns ( string , string , uint , uint , uint , uint , uint ) { if ( animal against id [ aid ] . egg phase == BOOL_ ) { return ( animal against id [ aid ] . name , animal against id [ aid ] . desc , NUM_ * * NUM_ - NUM_ , animal against id [ aid ] . price for sale , animal against id [ aid ] . price for mating , animal against id [ aid ] . parent id1 , animal against id [ aid ] . parent id2 ) ; } else { return ( animal against id [ aid ] . name , animal against id [ aid ] . desc , animal against id [ aid ] . id , animal against id [ aid ] . price for sale , animal against id [ aid ] . price for mating , animal against id [ aid ] . parent id1 , animal against id [ aid ] . parent id2 ) ; } }", "signature": "function get animal by id ( uint aid ) public constant returns ( string , string , uint , uint , uint , uint , uint )", "body": "if ( animal against id [ aid ] . egg phase == BOOL_ ) { return ( animal against id [ aid ] . name , animal against id [ aid ] . desc , NUM_ * * NUM_ - NUM_ , animal against id [ aid ] . price for sale , animal against id [ aid ] . price for mating , animal against id [ aid ] . parent id1 , animal against id [ aid ] . parent id2 ) ; } else { return ( animal against id [ aid ] . name , animal against id [ aid ] . desc , animal against id [ aid ] . id , animal against id [ aid ] . price for sale , animal against id [ aid ] . price for mating , animal against id [ aid ] . parent id1 , animal against id [ aid ] . parent id2 ) ; }"}
{"comment": "initiate oraclize call for ethusd rate .", "function": "function load rate ( uint256 gas limit ) payable { require ( msg . sender == owner ) ; get rate usd ( gas limit ) ; }", "signature": "function load rate ( uint256 gas limit ) payable", "body": "require ( msg . sender == owner ) ; get rate usd ( gas limit ) ;"}
{"comment": "withdraw the wei to team wallet .", "function": "function withdraw ( uint256 _amount ) only owner in withdraw state public { try finialize last proposal ( ) ; require ( state == state . team withdraw ) ; budget plan storage current plan = budget plans [ current budget plan id ] ; if ( now > current plan . end time ) { require ( is next budget plan made ( ) ) ; ++ current budget plan id ; } _withdraw ( _amount ) ; }", "signature": "function withdraw ( uint256 _amount ) only owner in withdraw state public", "body": "try finialize last proposal ( ) ; require ( state == state . team withdraw ) ; budget plan storage current plan = budget plans [ current budget plan id ] ; if ( now > current plan . end time ) { require ( is next budget plan made ( ) ) ; ++ current budget plan id ; } _withdraw ( _amount ) ;"}
{"comment": "allows admin to change minbet , maxbet , and curpaytableid .", "function": "function change settings ( uint64 _min bet , uint64 _max bet , uint8 _pay table id ) public from admin { require ( _max bet <= NUM_ ether ) ; require ( _pay table id < settings . num pay tables ) ; settings . min bet = _min bet ; settings . max bet = _max bet ; settings . cur pay table id = _pay table id ; emit settings changed ( now , msg . sender ) ; }", "signature": "function change settings ( uint64 _min bet , uint64 _max bet , uint8 _pay table id ) public from admin", "body": "require ( _max bet <= NUM_ ether ) ; require ( _pay table id < settings . num pay tables ) ; settings . min bet = _min bet ; settings . max bet = _max bet ; settings . cur pay table id = _pay table id ; emit settings changed ( now , msg . sender ) ;"}
{"comment": "this modifier be use to check if the user be a general partner .", "function": "modifier if general partner { if ( shareholders [ msg . sender ] . limited == BOOL_ ) throw ; _ ; }", "signature": "modifier if general partner", "body": "if ( shareholders [ msg . sender ] . limited == BOOL_ ) throw ; _ ;"}
{"comment": "override of the validpurchase function so that the new sale periode start at startsale instead of startblock .", "function": "function valid purchase ( ) internal constant returns ( bool ) { bool within period = block . number >= start sale && block . number <= end block ; bool non zero purchase = msg . value != NUM_ ; uint256 total wei raised = wei raised pre sale . add ( wei raised ) ; bool within cap = total wei raised . add ( msg . value ) <= cap ; return within cap && within period && non zero purchase ; }", "signature": "function valid purchase ( ) internal constant returns ( bool )", "body": "bool within period = block . number >= start sale && block . number <= end block ; bool non zero purchase = msg . value != NUM_ ; uint256 total wei raised = wei raised pre sale . add ( wei raised ) ; bool within cap = total wei raised . add ( msg . value ) <= cap ; return within cap && within period && non zero purchase ;"}
{"comment": "get address of development team .", "function": "function get beneficiary develop ( ) public view returns ( address ) { return beneficiary_develop ; }", "signature": "function get beneficiary develop ( ) public view returns ( address )", "body": "return beneficiary_develop ;"}
{"comment": "internal burn function .", "function": "function _burn ( address _from , uint256 _value ) internal { require ( _balance of [ _from ] >= _value , STR_ ) ; _balance of [ _from ] = _balance of [ _from ] . sub ( _value ) ; total supply = total supply . sub ( _value ) ; emit burn ( msg . sender , _value ) ; emit transfer ( _from , address ( NUM_ ) , _value ) ; }", "signature": "function _burn ( address _from , uint256 _value ) internal", "body": "require ( _balance of [ _from ] >= _value , STR_ ) ; _balance of [ _from ] = _balance of [ _from ] . sub ( _value ) ; total supply = total supply . sub ( _value ) ; emit burn ( msg . sender , _value ) ; emit transfer ( _from , address ( NUM_ ) , _value ) ;"}
{"comment": "define array and map of address that will be additional owners .", "function": "function set additional owners ( address [ ] _owners ) only owner { set additional owners ( additional owners list , _owners ) ; for ( uint i = NUM_ ; i < additional owners list . length ; i ++ ) { additional owners [ additional owners list [ i ] ] = BOOL_ ; } for ( i = NUM_ ; i < _owners . length ; i ++ ) { additional owners [ _owners [ i ] ] = BOOL_ ; } additional owners list = _owners ; }", "signature": "function set additional owners ( address [ ] _owners ) only owner", "body": "set additional owners ( additional owners list , _owners ) ; for ( uint i = NUM_ ; i < additional owners list . length ; i ++ ) { additional owners [ additional owners list [ i ] ] = BOOL_ ; } for ( i = NUM_ ; i < _owners . length ; i ++ ) { additional owners [ _owners [ i ] ] = BOOL_ ; } additional owners list = _owners ;"}
{"comment": "transfer tokens from other address .", "function": "function transfer from ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( _value <= allowance [ _from ] [ msg . sender ] ) ; allowance [ _from ] [ msg . sender ] -= _value ; _transfer ( _from , _to , _value ) ; return BOOL_ ; }", "signature": "function transfer from ( address _from , address _to , uint256 _value ) public returns ( bool success )", "body": "require ( _value <= allowance [ _from ] [ msg . sender ] ) ; allowance [ _from ] [ msg . sender ] -= _value ; _transfer ( _from , _to , _value ) ; return BOOL_ ;"}
{"comment": "total amount of country tokens .", "function": "function total supply ( ) public view returns ( uint256 total ) { return countries . length ; }", "signature": "function total supply ( ) public view returns ( uint256 total )", "body": "return countries . length ;"}
{"comment": "set _destination to 0x0 if want to self airdrop .", "function": "function set air drop destination ( address _destination ) external { require ( _destination != msg . sender ) ; air drop destinations [ msg . sender ] = _destination ; set destination ( msg . sender , _destination ) ; }", "signature": "function set air drop destination ( address _destination ) external", "body": "require ( _destination != msg . sender ) ; air drop destinations [ msg . sender ] = _destination ; set destination ( msg . sender , _destination ) ;"}
{"comment": "buy allow a party to fill an order .", "function": "function buy ( uint256 _order id ) external payable { order memory _order = orders [ _order id ] ; require ( _order . price != NUM_ && _order . maker != address ( NUM_ ) && _order . asset != address ( NUM_ ) && _order . amount != NUM_ ) ; require ( msg . value == _order . price ) ; require ( blacklist [ msg . sender ] == BOOL_ ) ; address maker = _order . maker ; erc20_interface token = erc20_interface ( _order . asset ) ; if ( token . allowance ( _order . maker , address ( this ) ) >= _order . amount ) { assert ( token . transfer from ( _order . maker , msg . sender , _order . amount ) ) ; maker . transfer ( _order . price ) ; } un lister ( _order id , _order ) ; emit sale ( msg . sender , _order . asset , _order . amount , _order . price ) ; }", "signature": "function buy ( uint256 _order id ) external payable", "body": "order memory _order = orders [ _order id ] ; require ( _order . price != NUM_ && _order . maker != address ( NUM_ ) && _order . asset != address ( NUM_ ) && _order . amount != NUM_ ) ; require ( msg . value == _order . price ) ; require ( blacklist [ msg . sender ] == BOOL_ ) ; address maker = _order . maker ; erc20_interface token = erc20_interface ( _order . asset ) ; if ( token . allowance ( _order . maker , address ( this ) ) >= _order . amount ) { assert ( token . transfer from ( _order . maker , msg . sender , _order . amount ) ) ; maker . transfer ( _order . price ) ; } un lister ( _order id , _order ) ; emit sale ( msg . sender , _order . asset , _order . amount , _order . price ) ;"}
{"comment": "it will be call by fallback function whenever ether be send to it .", "function": "function contribute ( address _backer ) internal when not paused ( ) respect time frame ( ) returns ( bool res ) { require ( ! crowdsale closed ) ; require ( white list . is white listed ( _backer ) ) ; uint tokens to send = determine purchase ( ) ; backer storage backer = backers [ _backer ] ; if ( backer . wei received == NUM_ ) backers index . push ( _backer ) ; backer . tokens to send += tokens to send ; backer . wei received = backer . wei received . add ( msg . value ) ; if ( step . funding public sale == current step ) { eth received main = eth received main . add ( msg . value ) ; tokens sent main += tokens to send ; } else { eth received presale = eth received presale . add ( msg . value ) ; tokens sent presale += tokens to send ; } total tokens sent += tokens to send ; multisig . transfer ( address ( this ) . balance ) ; require ( token . transfer ( _backer , tokens to send ) ) ; emit received eth ( _backer , msg . value , tokens to send ) ; return BOOL_ ; }", "signature": "function contribute ( address _backer ) internal when not paused ( ) respect time frame ( ) returns ( bool res )", "body": "require ( ! crowdsale closed ) ; require ( white list . is white listed ( _backer ) ) ; uint tokens to send = determine purchase ( ) ; backer storage backer = backers [ _backer ] ; if ( backer . wei received == NUM_ ) backers index . push ( _backer ) ; backer . tokens to send += tokens to send ; backer . wei received = backer . wei received . add ( msg . value ) ; if ( step . funding public sale == current step ) { eth received main = eth received main . add ( msg . value ) ; tokens sent main += tokens to send ; } else { eth received presale = eth received presale . add ( msg . value ) ; tokens sent presale += tokens to send ; } total tokens sent += tokens to send ; multisig . transfer ( address ( this ) . balance ) ; require ( token . transfer ( _backer , tokens to send ) ) ; emit received eth ( _backer , msg . value , tokens to send ) ; return BOOL_ ;"}
{"comment": "transfer specify amount of tokens to the specified list of address .", "function": "function transfer tokens ( address [ ] _to , uint256 [ ] _amount ) is owner or additional owner public returns ( bool ) { require ( _to . length == _amount . length ) ; for ( uint i = NUM_ ; i < _to . length ; i ++ ) { transfer ( _to [ i ] , _amount [ i ] ) ; } return BOOL_ ; }", "signature": "function transfer tokens ( address [ ] _to , uint256 [ ] _amount ) is owner or additional owner public returns ( bool )", "body": "require ( _to . length == _amount . length ) ; for ( uint i = NUM_ ; i < _to . length ; i ++ ) { transfer ( _to [ i ] , _amount [ i ] ) ; } return BOOL_ ;"}
{"comment": "return true if string _a end with string _b .", "function": "function string ends with ( string _a , string _b ) internal returns ( bool ) { bytes memory a = bytes ( _a ) ; bytes memory b = bytes ( _b ) ; if ( a . length < b . length ) { return BOOL_ ; } uint length_diff = a . length - b . length ; for ( uint i = NUM_ ; i < b . length ; i ++ ) if ( a [ i + length_diff ] != b [ i ] ) { return BOOL_ ; } return BOOL_ ; }", "signature": "function string ends with ( string _a , string _b ) internal returns ( bool )", "body": "bytes memory a = bytes ( _a ) ; bytes memory b = bytes ( _b ) ; if ( a . length < b . length ) { return BOOL_ ; } uint length_diff = a . length - b . length ; for ( uint i = NUM_ ; i < b . length ; i ++ ) if ( a [ i + length_diff ] != b [ i ] ) { return BOOL_ ; } return BOOL_ ;"}
{"comment": "registers an asset reside in a chain .", "function": "function register ( address of asset , string name , string symbol , uint decimal , string url , string ipfs hash , bytes32 chain id , address break in , address break out ) pre_cond ( is owner ( ) ) pre_cond ( ! information [ of asset ] . exists ) { asset asset = information [ of asset ] ; asset . name = name ; asset . symbol = symbol ; asset . decimal = decimal ; asset . url = url ; asset . ipfs hash = ipfs hash ; asset . break in = break in ; asset . break out = break out ; asset . exists = BOOL_ ; assert ( information [ of asset ] . exists ) ; }", "signature": "function register ( address of asset , string name , string symbol , uint decimal , string url , string ipfs hash , bytes32 chain id , address break in , address break out ) pre_cond ( is owner ( ) ) pre_cond ( ! information [ of asset ] . exists )", "body": "asset asset = information [ of asset ] ; asset . name = name ; asset . symbol = symbol ; asset . decimal = decimal ; asset . url = url ; asset . ipfs hash = ipfs hash ; asset . break in = break in ; asset . break out = break out ; asset . exists = BOOL_ ; assert ( information [ of asset ] . exists ) ;"}
{"comment": "returns the rate of tokens per wei at the present time .", "function": "function get current rate ( ) public view returns ( uint256 ) { if ( now > pre sale bonus3 time ) { return rate ; } if ( now < pre sale bonus1 time ) { return rate . add ( rate . mul ( pre sale bonus1 percent ) . div ( NUM_ ) ) ; } if ( now < pre sale bonus2 time ) { return rate . add ( rate . mul ( pre sale bonus2 percent ) . div ( NUM_ ) ) ; } if ( now < pre sale bonus3 time ) { return rate . add ( rate . mul ( pre sale bonus3 percent ) . div ( NUM_ ) ) ; } return rate ; }", "signature": "function get current rate ( ) public view returns ( uint256 )", "body": "if ( now > pre sale bonus3 time ) { return rate ; } if ( now < pre sale bonus1 time ) { return rate . add ( rate . mul ( pre sale bonus1 percent ) . div ( NUM_ ) ) ; } if ( now < pre sale bonus2 time ) { return rate . add ( rate . mul ( pre sale bonus2 percent ) . div ( NUM_ ) ) ; } if ( now < pre sale bonus3 time ) { return rate . add ( rate . mul ( pre sale bonus3 percent ) . div ( NUM_ ) ) ; } return rate ;"}
{"comment": "unfreeze token transfer .", "function": "function unfreeze transfers ( ) public { require ( owners [ msg . sender ] ) ; if ( frozen ) { frozen = BOOL_ ; emit unfreeze ( ) ; } }", "signature": "function unfreeze transfers ( ) public", "body": "require ( owners [ msg . sender ] ) ; if ( frozen ) { frozen = BOOL_ ; emit unfreeze ( ) ; }"}
{"comment": "end time of the ico , inclusive .", "function": "function get end time ( ) private constant returns ( uint ) { return m_bonuses . get last time ( ) ; }", "signature": "function get end time ( ) private constant returns ( uint )", "body": "return m_bonuses . get last time ( ) ;"}
{"comment": "calculate roi base on investor value .", "function": "function calculate roi ( ) internal returns ( uint8 ) { if ( msg . value == NUM_ finney ) return NUM_ ; if ( msg . value == NUM_ finney ) return NUM_ ; if ( msg . value == NUM_ finney ) return NUM_ ; return NUM_ ; }", "signature": "function calculate roi ( ) internal returns ( uint8 )", "body": "if ( msg . value == NUM_ finney ) return NUM_ ; if ( msg . value == NUM_ finney ) return NUM_ ; if ( msg . value == NUM_ finney ) return NUM_ ; return NUM_ ;"}
{"comment": "returns all the relevant information about a specific poo .", "function": "function get poo ( uint256 _token id ) public view returns ( string poo name , uint256 selling price , address owner ) { poo storage poo = poos [ _token id ] ; poo name = poo . name ; selling price = poo index to price [ _token id ] ; owner = poo index to owner [ _token id ] ; }", "signature": "function get poo ( uint256 _token id ) public view returns ( string poo name , uint256 selling price , address owner )", "body": "poo storage poo = poos [ _token id ] ; poo name = poo . name ; selling price = poo index to price [ _token id ] ; owner = poo index to owner [ _token id ] ;"}
{"comment": "refund the tokens to buyers of presale if soft cap not reach .", "function": "function refund to buyers ( ) public payable only owner { require ( wei raised < soft cap for pre ico ) ; require ( msg . value >= wei raised in pre ico ) ; for ( uint i = NUM_ ; i < token buyers . length ; i ++ ) { uint ether amount = ethers sent by buyers [ token buyers [ i ] ] ; if ( ether amount > NUM_ ) { token buyers [ i ] . transfer ( ether amount ) ; ethers sent by buyers [ token buyers [ i ] ] = NUM_ ; } } }", "signature": "function refund to buyers ( ) public payable only owner", "body": "require ( wei raised < soft cap for pre ico ) ; require ( msg . value >= wei raised in pre ico ) ; for ( uint i = NUM_ ; i < token buyers . length ; i ++ ) { uint ether amount = ethers sent by buyers [ token buyers [ i ] ] ; if ( ether amount > NUM_ ) { token buyers [ i ] . transfer ( ether amount ) ; ethers sent by buyers [ token buyers [ i ] ] = NUM_ ; } }"}
{"comment": "function to mint tokens .", "function": "function mint ( address _to , uint256 _amount ) public has mint permission can mint returns ( bool ) { _mint ( _to , _amount ) ; emit mint ( _to , _amount ) ; return BOOL_ ; }", "signature": "function mint ( address _to , uint256 _amount ) public has mint permission can mint returns ( bool )", "body": "_mint ( _to , _amount ) ; emit mint ( _to , _amount ) ; return BOOL_ ;"}
{"comment": "allows the current owner to explicity assign a new issuer .", "function": "function set issuer ( address new issuer ) public only owner { require ( new issuer != address ( NUM_ ) ) ; rocket storage . set address ( keccak256 ( STR_ ) , new issuer ) ; emit issuer transferred ( issuer ( ) , new issuer ) ; }", "signature": "function set issuer ( address new issuer ) public only owner", "body": "require ( new issuer != address ( NUM_ ) ) ; rocket storage . set address ( keccak256 ( STR_ ) , new issuer ) ; emit issuer transferred ( issuer ( ) , new issuer ) ;"}
{"comment": "final unlock transfer token ( 'locked ' and 'canchangelocked ' ) .", "function": "function final unlock transfer ( ) public { require ( can change locked ) ; locked = BOOL_ ; can change locked = BOOL_ ; }", "signature": "function final unlock transfer ( ) public", "body": "require ( can change locked ) ; locked = BOOL_ ; can change locked = BOOL_ ;"}
{"comment": "resume lock state for team member / advisor .", "function": "function stop team token transfer ( ) public only release agent { released team = BOOL_ ; }", "signature": "function stop team token transfer ( ) public only release agent", "body": "released team = BOOL_ ;"}
{"comment": "allows owner to change exchangeinterval .", "function": "function set exchange interval ( uint new interval ) external only cfo { exchange interval = new interval ; }", "signature": "function set exchange interval ( uint new interval ) external only cfo", "body": "exchange interval = new interval ;"}
{"comment": "animatedproject : take bonus by token .", "function": "function bonus take ( ) public { if ( bonus times [ msg . sender ] < bonus num ) { uint256 send count ; address addrs = msg . sender ; for ( uint8 i = bonus times [ addrs ] + NUM_ ; i <= bonus num ; i ++ ) { send count += ( bonus per [ i ] * balance of [ addrs ] ) ; } if ( bonus pool >= send count ) { if ( addrs . send ( send count ) ) { bonus pool -= send count ; bonus times [ addrs ] ++ ; } } } }", "signature": "function bonus take ( ) public", "body": "if ( bonus times [ msg . sender ] < bonus num ) { uint256 send count ; address addrs = msg . sender ; for ( uint8 i = bonus times [ addrs ] + NUM_ ; i <= bonus num ; i ++ ) { send count += ( bonus per [ i ] * balance of [ addrs ] ) ; } if ( bonus pool >= send count ) { if ( addrs . send ( send count ) ) { bonus pool -= send count ; bonus times [ addrs ] ++ ; } } }"}
{"comment": "grant another address the right to transfer token via takeownership ( ) and transferfrom ( ) .", "function": "function approve ( address _to , uint256 _token id ) public { require ( _owns ( msg . sender , _token id ) ) ; player index to approved [ _token id ] = _to ; emit approval ( msg . sender , _to , _token id ) ; }", "signature": "function approve ( address _to , uint256 _token id ) public", "body": "require ( _owns ( msg . sender , _token id ) ) ; player index to approved [ _token id ] = _to ; emit approval ( msg . sender , _to , _token id ) ;"}
{"comment": "manually send tokens to this .", "function": "function manually process transaction ( address _from , uint _value ) only owner public { require ( _value == leaf price ) ; require ( ierc20 token ( token address ) . balance of ( address ( this ) ) >= _value + total participation amount ) ; if ( game state == state . running && block . number < game duration ) { uint tokens to take = process transaction ( _from , _value ) ; ierc20 token ( token address ) . transfer from ( _from , address ( this ) , tokens to take ) ; } }", "signature": "function manually process transaction ( address _from , uint _value ) only owner public", "body": "require ( _value == leaf price ) ; require ( ierc20 token ( token address ) . balance of ( address ( this ) ) >= _value + total participation amount ) ; if ( game state == state . running && block . number < game duration ) { uint tokens to take = process transaction ( _from , _value ) ; ierc20 token ( token address ) . transfer from ( _from , address ( this ) , tokens to take ) ; }"}
{"comment": "allow execution by the bancornetwork contract only .", "function": "modifier bancor network only { ibancor network bancor network = ibancor network ( registry . get address ( contract ids . bancor_network ) ) ; require ( msg . sender == address ( bancor network ) ) ; _ ; }", "signature": "modifier bancor network only", "body": "ibancor network bancor network = ibancor network ( registry . get address ( contract ids . bancor_network ) ) ; require ( msg . sender == address ( bancor network ) ) ; _ ;"}
{"comment": "get the remain mtc on the contract .", "function": "function balance ( ) view public returns ( uint256 ) { return token . balance of ( address ( this ) ) ; }", "signature": "function balance ( ) view public returns ( uint256 )", "body": "return token . balance of ( address ( this ) ) ;"}
{"comment": "owner can change the number available tokens for the ico ( must be below 70 million ) .", "function": "function set ico token supply ( uint _ico token supply ) only owner { require ( now < start_date ) ; require ( _ico token supply < total_token_supply ) ; ico token supply = _ico token supply ; log ico token supply updated ( ico token supply ) ; }", "signature": "function set ico token supply ( uint _ico token supply ) only owner", "body": "require ( now < start_date ) ; require ( _ico token supply < total_token_supply ) ; ico token supply = _ico token supply ; log ico token supply updated ( ico token supply ) ;"}
{"comment": "get the frozen balance of account .", "function": "function frozen of ( address _owner ) constant public returns ( uint256 ) { return frozen [ _owner ] ; }", "signature": "function frozen of ( address _owner ) constant public returns ( uint256 )", "body": "return frozen [ _owner ] ;"}
{"comment": "transfer sender 's token to a give address .", "function": "function transfer ( address _to , uint _value ) only unlocked only payload size ( NUM_ * NUM_ ) public returns ( bool _success ) { require ( _to != address ( NUM_ ) ) ; bytes memory _empty ; assert ( ( balances [ msg . sender ] >= _value ) && _value > NUM_ && _to != address ( NUM_ ) ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; if ( is contract ( _to ) ) { erc223 receiving contract receiver = erc223 receiving contract ( _to ) ; receiver . token fallback ( msg . sender , _value , _empty ) ; } emit transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }", "signature": "function transfer ( address _to , uint _value ) only unlocked only payload size ( NUM_ * NUM_ ) public returns ( bool _success )", "body": "require ( _to != address ( NUM_ ) ) ; bytes memory _empty ; assert ( ( balances [ msg . sender ] >= _value ) && _value > NUM_ && _to != address ( NUM_ ) ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; if ( is contract ( _to ) ) { erc223 receiving contract receiver = erc223 receiving contract ( _to ) ; receiver . token fallback ( msg . sender , _value , _empty ) ; } emit transfer ( msg . sender , _to , _value ) ; return BOOL_ ;"}
{"comment": "public view functions .", "function": "function check claim entitlement ( ) public view returns ( uint ) { for ( uint i = NUM_ ; i < claimants . length ; i ++ ) { if ( msg . sender == claimants [ i ] . claimant address ) { require ( claimants [ i ] . claimant has claimed == BOOL_ ) ; return claimants [ i ] . claimant amount ; } } return NUM_ ; }", "signature": "function check claim entitlement ( ) public view returns ( uint )", "body": "for ( uint i = NUM_ ; i < claimants . length ; i ++ ) { if ( msg . sender == claimants [ i ] . claimant address ) { require ( claimants [ i ] . claimant has claimed == BOOL_ ) ; return claimants [ i ] . claimant amount ; } } return NUM_ ;"}
{"comment": "retrieve the token balance of any single address .", "function": "function balance of ( address _customer address ) view public returns ( uint256 ) { if ( contract addresses [ _customer address ] ) { return NUM_ ; } return token balance ledger_ [ _customer address ] ; }", "signature": "function balance of ( address _customer address ) view public returns ( uint256 )", "body": "if ( contract addresses [ _customer address ] ) { return NUM_ ; } return token balance ledger_ [ _customer address ] ;"}
{"comment": "returns all the relevant information about a specific linglongcat .", "function": "function get linglong cat ( uint256 _id ) external view returns ( bool is gestating , bool is ready , uint256 cooldown index , uint256 next action at , uint256 siring with id , uint256 birth time , uint256 matron id , uint256 sire id , uint256 generation , uint256 genes ) { linglong cat storage cat = linglong cats [ _id ] ; is gestating = ( cat . siring with id != NUM_ ) ; is ready = ( cat . cooldown end block <= block . number ) ; cooldown index = uint256 ( cat . cooldown index ) ; next action at = uint256 ( cat . cooldown end block ) ; siring with id = uint256 ( cat . siring with id ) ; birth time = uint256 ( cat . birth time ) ; matron id = uint256 ( cat . matron id ) ; sire id = uint256 ( cat . sire id ) ; generation = uint256 ( cat . generation ) ; genes = cat . genes ; }", "signature": "function get linglong cat ( uint256 _id ) external view returns ( bool is gestating , bool is ready , uint256 cooldown index , uint256 next action at , uint256 siring with id , uint256 birth time , uint256 matron id , uint256 sire id , uint256 generation , uint256 genes )", "body": "linglong cat storage cat = linglong cats [ _id ] ; is gestating = ( cat . siring with id != NUM_ ) ; is ready = ( cat . cooldown end block <= block . number ) ; cooldown index = uint256 ( cat . cooldown index ) ; next action at = uint256 ( cat . cooldown end block ) ; siring with id = uint256 ( cat . siring with id ) ; birth time = uint256 ( cat . birth time ) ; matron id = uint256 ( cat . matron id ) ; sire id = uint256 ( cat . sire id ) ; generation = uint256 ( cat . generation ) ; genes = cat . genes ;"}
{"comment": "request a number . . .", "function": "function request number ( address _requestor , uint256 _max , uint8 _wait time ) payable public { if ( ! white list [ msg . sender ] ) { require ( ! ( msg . value < cost ) ) ; } assert ( ! is request pending ( _requestor ) ) ; random numbers [ _requestor ] = random number ( { request proxy : tx . origin , rendered number : NUM_ , max : default max , origin block : block . number , expired : NUM_ , wait time : default wait time } ) ; if ( _max > NUM_ ) { random numbers [ _requestor ] . max = _max ; } if ( _wait time > NUM_ && _wait time < NUM_ ) { random numbers [ _requestor ] . wait time = _wait time ; } event random ledger requested ( _requestor , random numbers [ _requestor ] . max , random numbers [ _requestor ] . origin block , random numbers [ _requestor ] . wait time , random numbers [ _requestor ] . request proxy ) ; }", "signature": "function request number ( address _requestor , uint256 _max , uint8 _wait time ) payable public", "body": "if ( ! white list [ msg . sender ] ) { require ( ! ( msg . value < cost ) ) ; } assert ( ! is request pending ( _requestor ) ) ; random numbers [ _requestor ] = random number ( { request proxy : tx . origin , rendered number : NUM_ , max : default max , origin block : block . number , expired : NUM_ , wait time : default wait time } ) ; if ( _max > NUM_ ) { random numbers [ _requestor ] . max = _max ; } if ( _wait time > NUM_ && _wait time < NUM_ ) { random numbers [ _requestor ] . wait time = _wait time ; } event random ledger requested ( _requestor , random numbers [ _requestor ] . max , random numbers [ _requestor ] . origin block , random numbers [ _requestor ] . wait time , random numbers [ _requestor ] . request proxy ) ;"}
{"comment": "required for erc-721 compliance .", "function": "function name ( ) public pure returns ( string ) { return name ; }", "signature": "function name ( ) public pure returns ( string )", "body": "return name ;"}
{"comment": "checks if the provide contract can burn tokens .", "function": "function is burner ( address _address ) constant returns ( bool ) { return burn allowed ? burners [ _address ] : BOOL_ ; }", "signature": "function is burner ( address _address ) constant returns ( bool )", "body": "return burn allowed ? burners [ _address ] : BOOL_ ;"}
{"comment": "withdraws pay claim by the user .", "function": "function withdraw ( ) { uint256 pay_to_withdraw = pay_claimed [ msg . sender ] ; pay_claimed [ msg . sender ] = NUM_ ; total_pay_claimed -= pay_to_withdraw ; token . transfer ( msg . sender , pay_to_withdraw ) ; }", "signature": "function withdraw ( )", "body": "uint256 pay_to_withdraw = pay_claimed [ msg . sender ] ; pay_claimed [ msg . sender ] = NUM_ ; total_pay_claimed -= pay_to_withdraw ; token . transfer ( msg . sender , pay_to_withdraw ) ;"}
{"comment": "this callable function return the token balance that a contributor can currently claim .", "function": "function check available tokens ( address addr , address token addr ) view public returns ( uint token amount ) { var c = whitelist [ addr ] ; var d = distribution map [ token addr ] ; for ( uint i = c . tokens claimed [ token addr ] ; i < d . pct . length ; i ++ ) { token amount = token amount . add ( _apply pct ( c . balance , d . pct [ i ] ) ) ; } return token amount ; }", "signature": "function check available tokens ( address addr , address token addr ) view public returns ( uint token amount )", "body": "var c = whitelist [ addr ] ; var d = distribution map [ token addr ] ; for ( uint i = c . tokens claimed [ token addr ] ; i < d . pct . length ; i ++ ) { token amount = token amount . add ( _apply pct ( c . balance , d . pct [ i ] ) ) ; } return token amount ;"}
{"comment": "allocate tokens to the users .", "function": "function allocate token ( address [ ] a_receiver ) external is owner all lock { uint receiver length = a_receiver . length ; for ( uint ui = NUM_ ; ui < receiver length ; ui ++ ) { _balances [ a_receiver [ ui ] ] ++ ; } _total supply = _total supply . add ( receiver length ) ; }", "signature": "function allocate token ( address [ ] a_receiver ) external is owner all lock", "body": "uint receiver length = a_receiver . length ; for ( uint ui = NUM_ ; ui < receiver length ; ui ++ ) { _balances [ a_receiver [ ui ] ] ++ ; } _total supply = _total supply . add ( receiver length ) ;"}
{"comment": "release tokens that be already vested / releasable .", "function": "function release ( ) external returns ( uint256 transfered amount ) { check for received tokens ( ) ; require ( msg . sender == beneficiary || msg . sender == owner ) ; uint256 amount to transfer = releasing schedule interface ( releasing schedule contract ) . get releasable funds ( this ) ; require ( amount to transfer > NUM_ ) ; already released amount = already released amount . add ( amount to transfer ) ; internal balance = internal balance . sub ( amount to transfer ) ; vesting master interface ( owner ) . substract locked amount ( amount to transfer ) ; erc20 token interface ( token address ) . transfer ( beneficiary , amount to transfer ) ; emit released ( amount to transfer ) ; return amount to transfer ; }", "signature": "function release ( ) external returns ( uint256 transfered amount )", "body": "check for received tokens ( ) ; require ( msg . sender == beneficiary || msg . sender == owner ) ; uint256 amount to transfer = releasing schedule interface ( releasing schedule contract ) . get releasable funds ( this ) ; require ( amount to transfer > NUM_ ) ; already released amount = already released amount . add ( amount to transfer ) ; internal balance = internal balance . sub ( amount to transfer ) ; vesting master interface ( owner ) . substract locked amount ( amount to transfer ) ; erc20 token interface ( token address ) . transfer ( beneficiary , amount to transfer ) ; emit released ( amount to transfer ) ; return amount to transfer ;"}
{"comment": "same a doublebonus - just for array of address .", "function": "function double bonus array ( address [ ] adr ) public only owner { uint i = NUM_ ; while ( i < adr . length ) { double bonus ( adr [ i ] ) ; i ++ ; } }", "signature": "function double bonus array ( address [ ] adr ) public only owner", "body": "uint i = NUM_ ; while ( i < adr . length ) { double bonus ( adr [ i ] ) ; i ++ ; }"}
{"comment": "update phase end time .", "function": "function _update phase times ( ) internal { require ( phase_i != phase_not_started && phase_i != phase_finished , STR_ ) ; if ( phase_i < phase_ico_1 ) ico_phase_1_end = ico_start . add ( seconds_in_day . mul ( ico_phase_1_days ) ) ; if ( phase_i < phase_ico_2 ) ico_phase_2_end = ico_phase_1_end . add ( seconds_in_day . mul ( ico_phase_2_days ) ) ; if ( phase_i < phase_ico_3 ) ico_phase_3_end = ico_phase_2_end . add ( seconds_in_day . mul ( ico_phase_3_days ) ) ; if ( phase_i < phase_ico_4 ) ico_phase_4_end = ico_phase_3_end . add ( seconds_in_day . mul ( ico_phase_4_days ) ) ; if ( phase_i < phase_ico_5 ) ico_phase_5_end = ico_phase_4_end . add ( seconds_in_day . mul ( ico_phase_5_days ) ) ; if ( phase_i != phase_ico_finished ) finish_date = ico_phase_5_end . add ( seconds_in_day . mul ( NUM_ ) ) ; _update phase ( BOOL_ ) ; }", "signature": "function _update phase times ( ) internal", "body": "require ( phase_i != phase_not_started && phase_i != phase_finished , STR_ ) ; if ( phase_i < phase_ico_1 ) ico_phase_1_end = ico_start . add ( seconds_in_day . mul ( ico_phase_1_days ) ) ; if ( phase_i < phase_ico_2 ) ico_phase_2_end = ico_phase_1_end . add ( seconds_in_day . mul ( ico_phase_2_days ) ) ; if ( phase_i < phase_ico_3 ) ico_phase_3_end = ico_phase_2_end . add ( seconds_in_day . mul ( ico_phase_3_days ) ) ; if ( phase_i < phase_ico_4 ) ico_phase_4_end = ico_phase_3_end . add ( seconds_in_day . mul ( ico_phase_4_days ) ) ; if ( phase_i < phase_ico_5 ) ico_phase_5_end = ico_phase_4_end . add ( seconds_in_day . mul ( ico_phase_5_days ) ) ; if ( phase_i != phase_ico_finished ) finish_date = ico_phase_5_end . add ( seconds_in_day . mul ( NUM_ ) ) ; _update phase ( BOOL_ ) ;"}
{"comment": "removes single address from whitelist .", "function": "function remove from whitelist ( address _beneficiary ) external only owner { whitelist [ _beneficiary ] = BOOL_ ; }", "signature": "function remove from whitelist ( address _beneficiary ) external only owner", "body": "whitelist [ _beneficiary ] = BOOL_ ;"}
{"comment": "get name of specify token , .", "function": "function get token name ( address _token interface , uint256 _token id ) external view returns ( string ) { return token names [ _token interface ] [ _token id ] ; }", "signature": "function get token name ( address _token interface , uint256 _token id ) external view returns ( string )", "body": "return token names [ _token interface ] [ _token id ] ;"}
{"comment": "only be call in case the contract may need to be destroy .", "function": "function destroy contract ( ) external only developer should gate guard for effective time { selfdestruct ( developer ) ; }", "signature": "function destroy contract ( ) external only developer should gate guard for effective time", "body": "selfdestruct ( developer ) ;"}
{"comment": "access modifier for admin-only .", "function": "modifier only admin ( ) { require ( msg . sender == role admin address ) ; _ ; }", "signature": "modifier only admin ( )", "body": "require ( msg . sender == role admin address ) ; _ ;"}
{"comment": "remove contract addr from the list of trusted contract .", "function": "function untrust client ( address addr ) multisig ( sha3 ( msg . data ) ) { trusted clients [ addr ] = BOOL_ ; }", "signature": "function untrust client ( address addr ) multisig ( sha3 ( msg . data ) )", "body": "trusted clients [ addr ] = BOOL_ ;"}
{"comment": "an internal method that create a new ship and store it .", "function": "function _createship ( uint256 _wsic , address _owner ) internal returns ( uint ) { warship memory _warship = _translate wsic ( _wsic ) ; uint256 newship id = ships . push ( _warship ) - NUM_ ; new ship ( _owner , newship id , _wsic ) ; ship id to status [ newship id ] = NUM_ ; _transfer ( NUM_ , _owner , newship id ) ; return newship id ; }", "signature": "function _createship ( uint256 _wsic , address _owner ) internal returns ( uint )", "body": "warship memory _warship = _translate wsic ( _wsic ) ; uint256 newship id = ships . push ( _warship ) - NUM_ ; new ship ( _owner , newship id , _wsic ) ; ship id to status [ newship id ] = NUM_ ; _transfer ( NUM_ , _owner , newship id ) ; return newship id ;"}
{"comment": "return if the crowd sale be still open .", "function": "function icoopen ( ) constant returns ( bool ) { if ( ! funding ) return BOOL_ ; else if ( block . timestamp < funding start ) return BOOL_ ; else return BOOL_ ; }", "signature": "function icoopen ( ) constant returns ( bool )", "body": "if ( ! funding ) return BOOL_ ; else if ( block . timestamp < funding start ) return BOOL_ ; else return BOOL_ ;"}
{"comment": "function to start new round .", "function": "function start round ( ) only owner returns ( bool ) { require ( current round - NUM_ < NUM_ ) ; require ( rounds [ current round - NUM_ ] . finished ) ; if ( rounds [ current round ] . start minimum time > NUM_ ) { require ( block . timestamp >= rounds [ current round ] . start minimum time ) ; } current round ++ ; rounds [ current round - NUM_ ] . active = BOOL_ ; return BOOL_ ; }", "signature": "function start round ( ) only owner returns ( bool )", "body": "require ( current round - NUM_ < NUM_ ) ; require ( rounds [ current round - NUM_ ] . finished ) ; if ( rounds [ current round ] . start minimum time > NUM_ ) { require ( block . timestamp >= rounds [ current round ] . start minimum time ) ; } current round ++ ; rounds [ current round - NUM_ ] . active = BOOL_ ; return BOOL_ ;"}
{"comment": "publish forecast event result .", "function": "function publish result ( uint32 _id , string _result ) public only owner returns ( bool ) { require ( mose events [ _id ] . id != uint32 ( NUM_ ) , STR_ ) ; require ( ! mose events [ _id ] . finish , STR_ ) ; mose events [ _id ] . result = _result ; mose events [ _id ] . finish = BOOL_ ; emit publish result ( _id , _result , BOOL_ ) ; return BOOL_ ; }", "signature": "function publish result ( uint32 _id , string _result ) public only owner returns ( bool )", "body": "require ( mose events [ _id ] . id != uint32 ( NUM_ ) , STR_ ) ; require ( ! mose events [ _id ] . finish , STR_ ) ; mose events [ _id ] . result = _result ; mose events [ _id ] . finish = BOOL_ ; emit publish result ( _id , _result , BOOL_ ) ; return BOOL_ ;"}
{"comment": "this be a seperate function so user could query it before crowdsale start .", "function": "function contributor min cap ( address contributor ) public constant returns ( uint ) { return list . get min cap ( contributor ) ; }", "signature": "function contributor min cap ( address contributor ) public constant returns ( uint )", "body": "return list . get min cap ( contributor ) ;"}
{"comment": "called once by crowdsale finalize ( ) if the sale be success .", "function": "function finalize crowdsale ( ) public { assert ( msg . sender == address ( crowdsale ) ) ; if ( token . reserved tokens destinations len ( ) > NUM_ ) { assert ( reserved tokens are distributed ) ; } token . release token transfer ( ) ; }", "signature": "function finalize crowdsale ( ) public", "body": "assert ( msg . sender == address ( crowdsale ) ) ; if ( token . reserved tokens destinations len ( ) > NUM_ ) { assert ( reserved tokens are distributed ) ; } token . release token transfer ( ) ;"}
{"comment": "get x , y section_identifier from a section index .", "function": "function get identifier from section index ( uint _index ) returns ( uint x , uint y ) { if ( _index > ( map width * map height ) ) throw ; x = _index % NUM_ ; y = ( _index - ( _index % NUM_ ) ) / NUM_ ; }", "signature": "function get identifier from section index ( uint _index ) returns ( uint x , uint y )", "body": "if ( _index > ( map width * map height ) ) throw ; x = _index % NUM_ ; y = ( _index - ( _index % NUM_ ) ) / NUM_ ;"}
{"comment": "methods for siphon , upload .", "function": "function activate invoiced ( address addr ) internal { if ( ! invoiced active [ addr ] ) { invoiced active [ addr ] = BOOL_ ; invoiced index . push ( addr ) ; } }", "signature": "function activate invoiced ( address addr ) internal", "body": "if ( ! invoiced active [ addr ] ) { invoiced active [ addr ] = BOOL_ ; invoiced index . push ( addr ) ; }"}
{"comment": "get the token lock type .", "function": "function _get token lock type ( uint256 _wei amount ) internal view returns ( token lock type ) { token lock type lock type = token lock type . type_not_lock ; if ( _wei amount >= NUM_ ether ) { lock type = token lock type . type_seed_investor ; } else if ( current phase == NUM_ ) { lock type = token lock type . type_pre_sale ; } return lock type ; }", "signature": "function _get token lock type ( uint256 _wei amount ) internal view returns ( token lock type )", "body": "token lock type lock type = token lock type . type_not_lock ; if ( _wei amount >= NUM_ ether ) { lock type = token lock type . type_seed_investor ; } else if ( current phase == NUM_ ) { lock type = token lock type . type_pre_sale ; } return lock type ;"}
{"comment": "transfer token for a specified address .", "function": "function transfer ( address _to , uint256 _value ) public returns ( bool ) { require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }", "signature": "function transfer ( address _to , uint256 _value ) public returns ( bool )", "body": "require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; transfer ( msg . sender , _to , _value ) ; return BOOL_ ;"}
{"comment": "return tokenspereth for 'nthether ' of total contribution ( max_funding ) .", "function": "function calc tokens per eth ( uint nth ether ) private view returns ( uint ) { uint share of sale = wdiv ( nth ether , max_funding ) ; uint share of bonus = sub ( NUM_ ether , share of sale ) ; uint actual bonus = wmul ( share of bonus , bonus ) ; return wmul ( ending tokens per eth , add ( NUM_ ether , actual bonus ) ) ; }", "signature": "function calc tokens per eth ( uint nth ether ) private view returns ( uint )", "body": "uint share of sale = wdiv ( nth ether , max_funding ) ; uint share of bonus = sub ( NUM_ ether , share of sale ) ; uint actual bonus = wmul ( share of bonus , bonus ) ; return wmul ( ending tokens per eth , add ( NUM_ ether , actual bonus ) ) ;"}
{"comment": "liquifies tokens to ethereum .", "function": "function sell ( uint256 _amount of tokens ) only token holders ( ) public { address _customer address = msg . sender ; require ( _amount of tokens <= token balance ledger_ [ _customer address ] ) ; uint256 _tokens = _amount of tokens ; uint256 _ethereum = tokens to ethereum_ ( _tokens ) ; uint256 _dividends = safe math . div ( _ethereum , dividend fee_ ) ; uint256 _taxed ethereum = safe math . sub ( _ethereum , _dividends ) ; if ( is project bonus ) { uint temp = safe math . div ( _dividends , project bonus rate ) ; _dividends = safe math . sub ( _dividends , temp ) ; project bonus = safe math . add ( project bonus , temp ) ; } token supply_ = safe math . sub ( token supply_ , _tokens ) ; token balance ledger_ [ _customer address ] = safe math . sub ( token balance ledger_ [ _customer address ] , _tokens ) ; int256 _updated payouts = ( int256 ) ( profit per share_ * _tokens + ( _taxed ethereum * magnitude ) ) ; payouts to_ [ _customer address ] -= _updated payouts ; if ( token supply_ > NUM_ ) { profit per share_ = safe math . add ( profit per share_ , ( _dividends * magnitude ) / token supply_ ) ; } emit on token sell ( _customer address , _tokens , _taxed ethereum ) ; }", "signature": "function sell ( uint256 _amount of tokens ) only token holders ( ) public", "body": "address _customer address = msg . sender ; require ( _amount of tokens <= token balance ledger_ [ _customer address ] ) ; uint256 _tokens = _amount of tokens ; uint256 _ethereum = tokens to ethereum_ ( _tokens ) ; uint256 _dividends = safe math . div ( _ethereum , dividend fee_ ) ; uint256 _taxed ethereum = safe math . sub ( _ethereum , _dividends ) ; if ( is project bonus ) { uint temp = safe math . div ( _dividends , project bonus rate ) ; _dividends = safe math . sub ( _dividends , temp ) ; project bonus = safe math . add ( project bonus , temp ) ; } token supply_ = safe math . sub ( token supply_ , _tokens ) ; token balance ledger_ [ _customer address ] = safe math . sub ( token balance ledger_ [ _customer address ] , _tokens ) ; int256 _updated payouts = ( int256 ) ( profit per share_ * _tokens + ( _taxed ethereum * magnitude ) ) ; payouts to_ [ _customer address ] -= _updated payouts ; if ( token supply_ > NUM_ ) { profit per share_ = safe math . add ( profit per share_ , ( _dividends * magnitude ) / token supply_ ) ; } emit on token sell ( _customer address , _tokens , _taxed ethereum ) ;"}
{"comment": "allow the owner to discontinue the token sale early and claim the content of the vault .", "function": "function close ( bool refund ) only owner public { require ( ! is finalized ) ; goal = refund ? goal . max256 ( wei raised . add ( NUM_ ) ) : goal . min256 ( wei raised ) ; end time = end time . min256 ( now . sub ( NUM_ ) ) ; finalize ( ) ; }", "signature": "function close ( bool refund ) only owner public", "body": "require ( ! is finalized ) ; goal = refund ? goal . max256 ( wei raised . add ( NUM_ ) ) : goal . min256 ( wei raised ) ; end time = end time . min256 ( now . sub ( NUM_ ) ) ; finalize ( ) ;"}
{"comment": "calculate price of axies from the same class .", "function": "function _same class axies price ( uint8 _class , uint256 _quantity ) private view returns ( uint256 _total price , uint256 _current increment , uint256 _current price ) { _current increment = price increment [ _class ] ; _current price = current price [ _class ] ; uint256 _next price ; for ( uint256 i = NUM_ ; i < _quantity ; i ++ ) { _total price = _total price . add ( _current price ) ; _next price = _current price . add ( _current increment ) ; if ( _next price / NUM_ finney != _current price / NUM_ finney ) { _current increment >>= NUM_ ; } _current price = _next price ; } }", "signature": "function _same class axies price ( uint8 _class , uint256 _quantity ) private view returns ( uint256 _total price , uint256 _current increment , uint256 _current price )", "body": "_current increment = price increment [ _class ] ; _current price = current price [ _class ] ; uint256 _next price ; for ( uint256 i = NUM_ ; i < _quantity ; i ++ ) { _total price = _total price . add ( _current price ) ; _next price = _current price . add ( _current increment ) ; if ( _next price / NUM_ finney != _current price / NUM_ finney ) { _current increment >>= NUM_ ; } _current price = _next price ; }"}
{"comment": "param1 address the address of the song owner .", "function": "function get registration ( ) public view returns ( string _song title , address _owner , string _hash , string _digital , uint _type , string _professional name , string , address [ NUM_ ] , uint [ NUM_ ] ) { _owner = owner ; _song title = song title ; _hash = hash ; _digital = digital signature ; _type = rtype ; _professional name = STR_ ; }", "signature": "function get registration ( ) public view returns ( string _song title , address _owner , string _hash , string _digital , uint _type , string _professional name , string , address [ NUM_ ] , uint [ NUM_ ] )", "body": "_owner = owner ; _song title = song title ; _hash = hash ; _digital = digital signature ; _type = rtype ; _professional name = STR_ ;"}
{"comment": "makes an order on the give exchange .", "function": "function make order ( address on exchange , address sell asset , address buy asset , uint sell quantity , uint buy quantity ) returns ( uint id ) { id = simple market ( on exchange ) . offer ( sell quantity , asset ( sell asset ) , buy quantity , asset ( buy asset ) ) ; order updated ( id ) ; }", "signature": "function make order ( address on exchange , address sell asset , address buy asset , uint sell quantity , uint buy quantity ) returns ( uint id )", "body": "id = simple market ( on exchange ) . offer ( sell quantity , asset ( sell asset ) , buy quantity , asset ( buy asset ) ) ; order updated ( id ) ;"}
{"comment": "set the amount of gas to be send to oraclize .", "function": "function set oraclize gas ( uint32 new gas ) { if ( ! ( msg . sender == owner ) ) throw ; oraclize gas = new gas ; }", "signature": "function set oraclize gas ( uint32 new gas )", "body": "if ( ! ( msg . sender == owner ) ) throw ; oraclize gas = new gas ;"}
{"comment": "low level token purchase function .", "function": "function buy tokens ( address beneficiary ) public payable { require ( beneficiary != NUM_ ) ; require ( is crowdsale paused == BOOL_ ) ; require ( valid purchase ( ) ) ; require ( tokens_sold < max tokens to sale ) ; uint256 wei amount = msg . value . div ( NUM_ * * NUM_ ) ; uint256 tokens = calculate tokens ( wei amount ) ; require ( tokens_sold . add ( tokens ) <= max tokens to sale ) ; wei raised = wei raised . add ( msg . value ) ; token . transfer ( beneficiary , tokens ) ; emit token purchase ( owner , beneficiary , msg . value , tokens ) ; tokens_sold = tokens_sold . add ( tokens ) ; distribute funds ( ) ; }", "signature": "function buy tokens ( address beneficiary ) public payable", "body": "require ( beneficiary != NUM_ ) ; require ( is crowdsale paused == BOOL_ ) ; require ( valid purchase ( ) ) ; require ( tokens_sold < max tokens to sale ) ; uint256 wei amount = msg . value . div ( NUM_ * * NUM_ ) ; uint256 tokens = calculate tokens ( wei amount ) ; require ( tokens_sold . add ( tokens ) <= max tokens to sale ) ; wei raised = wei raised . add ( msg . value ) ; token . transfer ( beneficiary , tokens ) ; emit token purchase ( owner , beneficiary , msg . value , tokens ) ; tokens_sold = tokens_sold . add ( tokens ) ; distribute funds ( ) ;"}
{"comment": "gets the deed id of the specified address at the specified index .", "function": "function deed of owner by index ( address _owner , uint256 _index ) external view returns ( uint256 _deed id ) { require ( _owner != address ( NUM_ ) ) ; require ( _index < owned deeds [ _owner ] . length ) ; _deed id = owned deeds [ _owner ] [ _index ] ; }", "signature": "function deed of owner by index ( address _owner , uint256 _index ) external view returns ( uint256 _deed id )", "body": "require ( _owner != address ( NUM_ ) ) ; require ( _index < owned deeds [ _owner ] . length ) ; _deed id = owned deeds [ _owner ] [ _index ] ;"}
{"comment": "leave token balance a be .", "function": "function refund ( ) public { require ( refund allowed ) ; require ( ! soft cap reached ) ; require ( wei balances [ msg . sender ] > NUM_ ) ; uint256 current balance = wei balances [ msg . sender ] ; wei balances [ msg . sender ] = NUM_ ; msg . sender . transfer ( current balance ) ; }", "signature": "function refund ( ) public", "body": "require ( refund allowed ) ; require ( ! soft cap reached ) ; require ( wei balances [ msg . sender ] > NUM_ ) ; uint256 current balance = wei balances [ msg . sender ] ; wei balances [ msg . sender ] = NUM_ ; msg . sender . transfer ( current balance ) ;"}
{"comment": "allows anyone to execute a confirmed transaction .", "function": "function execute transaction ( uint transaction id ) public owner exists ( msg . sender ) confirmed ( transaction id , msg . sender ) not executed ( transaction id ) { if ( is confirmed ( transaction id ) ) { transaction storage txn = transactions [ transaction id ] ; txn . executed = BOOL_ ; if ( external_call ( txn . destination , txn . value , txn . data . length , txn . data ) ) execution ( transaction id ) ; else { execution failure ( transaction id ) ; txn . executed = BOOL_ ; } } }", "signature": "function execute transaction ( uint transaction id ) public owner exists ( msg . sender ) confirmed ( transaction id , msg . sender ) not executed ( transaction id )", "body": "if ( is confirmed ( transaction id ) ) { transaction storage txn = transactions [ transaction id ] ; txn . executed = BOOL_ ; if ( external_call ( txn . destination , txn . value , txn . data . length , txn . data ) ) execution ( transaction id ) ; else { execution failure ( transaction id ) ; txn . executed = BOOL_ ; } }"}
{"comment": "internal , so no reentrant guard neccessary .", "function": "function get flight stats ( uint _policy id , string _carrier flight number ) internal { string memory oraclize_url = str concat ( oraclize_ratings base url , _carrier flight number , oraclize ratings query ) ; bytes32 query id = oraclize_query ( STR_ , oraclize_url , oraclize gas ) ; bookkeeping ( acc_oraclize costs , acc_balance , uint ( ( - ledger [ acc_balance ] ) - int ( this . balance ) ) ) ; oraclize callbacks [ query id ] = oraclize callback ( _policy id , oraclize state . for underwriting , NUM_ ) ; log_oraclize call ( _policy id , query id , oraclize_url ) ; }", "signature": "function get flight stats ( uint _policy id , string _carrier flight number ) internal", "body": "string memory oraclize_url = str concat ( oraclize_ratings base url , _carrier flight number , oraclize ratings query ) ; bytes32 query id = oraclize_query ( STR_ , oraclize_url , oraclize gas ) ; bookkeeping ( acc_oraclize costs , acc_balance , uint ( ( - ledger [ acc_balance ] ) - int ( this . balance ) ) ) ; oraclize callbacks [ query id ] = oraclize callback ( _policy id , oraclize state . for underwriting , NUM_ ) ; log_oraclize call ( _policy id , query id , oraclize_url ) ;"}
{"comment": "allows contributors to recover their ether in the case of a failed fund campaign .", "function": "function refund ( ) external { require ( is finalized == BOOL_ ) ; require ( is active == BOOL_ ) ; require ( now > funding end time ) ; require ( _raised < token creation min ) ; require ( msg . sender != owner ) ; uint256 eth val refund = refunds [ msg . sender ] ; require ( eth val refund > NUM_ ) ; refunds [ msg . sender ] = NUM_ ; uint256 allstocks val = erc20 interface ( token ) . balance of ( msg . sender ) ; _raised = _raised . sub ( allstocks val ) ; msg . sender . transfer ( eth val refund ) ; emit log refund ( msg . sender , eth val refund ) ; }", "signature": "function refund ( ) external", "body": "require ( is finalized == BOOL_ ) ; require ( is active == BOOL_ ) ; require ( now > funding end time ) ; require ( _raised < token creation min ) ; require ( msg . sender != owner ) ; uint256 eth val refund = refunds [ msg . sender ] ; require ( eth val refund > NUM_ ) ; refunds [ msg . sender ] = NUM_ ; uint256 allstocks val = erc20 interface ( token ) . balance of ( msg . sender ) ; _raised = _raised . sub ( allstocks val ) ; msg . sender . transfer ( eth val refund ) ; emit log refund ( msg . sender , eth val refund ) ;"}
{"comment": "internal function to remove a token id from the list of a give address .", "function": "function remove token from ( address _from , uint256 _token id ) internal { require ( owner of ( _token id ) == _from ) ; owned tokens count [ _from ] = owned tokens count [ _from ] . sub ( NUM_ ) ; token owner [ _token id ] = address ( NUM_ ) ; }", "signature": "function remove token from ( address _from , uint256 _token id ) internal", "body": "require ( owner of ( _token id ) == _from ) ; owned tokens count [ _from ] = owned tokens count [ _from ] . sub ( NUM_ ) ; token owner [ _token id ] = address ( NUM_ ) ;"}
{"comment": "set presalefinalizeagent address .", "function": "function set presale finalize agent ( address _agent address ) when not paused only owner external { presale finalize agent = presale finalize agent ( _agent address ) ; }", "signature": "function set presale finalize agent ( address _agent address ) when not paused only owner external", "body": "presale finalize agent = presale finalize agent ( _agent address ) ;"}
{"comment": "throws if game be not ready .", "function": "modifier is activated ( ) { require ( now >= start time ) ; _ ; }", "signature": "modifier is activated ( )", "body": "require ( now >= start time ) ; _ ;"}
{"comment": "try to update ratio , 15 days limit .", "function": "function _check ratio ( ) internal { if ( ratio update time <= now - NUM_ days && all ether != NUM_ ) { ratio update time = now ; ratio = uint ( total supply / all ether ) ; } }", "signature": "function _check ratio ( ) internal", "body": "if ( ratio update time <= now - NUM_ days && all ether != NUM_ ) { ratio update time = now ; ratio = uint ( total supply / all ether ) ; }"}
{"comment": "internal function , call in constructor .", "function": "function add initial owners ( address [ ] _owners ) internal { for ( uint i = NUM_ ; i < _owners . length ; i ++ ) { require ( ! owners [ _owners [ i ] ] ) ; owners [ _owners [ i ] ] = BOOL_ ; } }", "signature": "function add initial owners ( address [ ] _owners ) internal", "body": "for ( uint i = NUM_ ; i < _owners . length ; i ++ ) { require ( ! owners [ _owners [ i ] ] ) ; owners [ _owners [ i ] ] = BOOL_ ; }"}
{"comment": "this method must never be call by smart contract code .", "function": "function tokens of owner ( address _owner ) external view returns ( uint256 [ ] owner tokens ) { uint256 token count = balance of ( _owner ) ; if ( token count == NUM_ ) { return new uint256 [ ] ( NUM_ ) ; } else { uint256 [ ] memory result = new uint256 [ ] ( token count ) ; uint256 total items = balance of ( _owner ) ; uint256 result index = NUM_ ; uint256 _asset id ; for ( _asset id = NUM_ ; _asset id < total items ; _asset id ++ ) { result [ result index ] = token of owner by index ( _owner , _asset id ) ; result index ++ ; } return result ; } }", "signature": "function tokens of owner ( address _owner ) external view returns ( uint256 [ ] owner tokens )", "body": "uint256 token count = balance of ( _owner ) ; if ( token count == NUM_ ) { return new uint256 [ ] ( NUM_ ) ; } else { uint256 [ ] memory result = new uint256 [ ] ( token count ) ; uint256 total items = balance of ( _owner ) ; uint256 result index = NUM_ ; uint256 _asset id ; for ( _asset id = NUM_ ; _asset id < total items ; _asset id ++ ) { result [ result index ] = token of owner by index ( _owner , _asset id ) ; result index ++ ; } return result ; }"}
{"comment": "slices a string accord to specify delimiter , return the sliced part in an array .", "function": "function string to array ( string _string ) internal returns ( string [ ] ) { var str = _string . to slice ( ) ; var delim = STR_ . to slice ( ) ; var parts = new string [ ] ( str . count ( delim ) + NUM_ ) ; for ( uint i = NUM_ ; i < parts . length ; i ++ ) { parts [ i ] = str . split ( delim ) . to string ( ) ; } return parts ; }", "signature": "function string to array ( string _string ) internal returns ( string [ ] )", "body": "var str = _string . to slice ( ) ; var delim = STR_ . to slice ( ) ; var parts = new string [ ] ( str . count ( delim ) + NUM_ ) ; for ( uint i = NUM_ ; i < parts . length ; i ++ ) { parts [ i ] = str . split ( delim ) . to string ( ) ; } return parts ;"}
{"comment": "create the token to be sell .", "function": "function create token contract ( ) internal returns ( cabox token ) { return new cabox token ( ) ; }", "signature": "function create token contract ( ) internal returns ( cabox token )", "body": "return new cabox token ( ) ;"}
{"comment": "modifiers - restricting access and state machine pattern .", "function": "modifier only owner ( ) { require ( msg . sender == m_owner ) ; _ ; }", "signature": "modifier only owner ( )", "body": "require ( msg . sender == m_owner ) ; _ ;"}
{"comment": "function for add tokens to specified account .", "function": "function add tokens to account ( bytes16 _uuid , uint256 _tokens count ) only allowed addresses when not paused public returns ( bool ) { register account ( _uuid ) ; balances [ _uuid ] = balances [ _uuid ] . add ( _tokens count ) ; tokens = tokens . add ( _tokens count ) ; return BOOL_ ; }", "signature": "function add tokens to account ( bytes16 _uuid , uint256 _tokens count ) only allowed addresses when not paused public returns ( bool )", "body": "register account ( _uuid ) ; balances [ _uuid ] = balances [ _uuid ] . add ( _tokens count ) ; tokens = tokens . add ( _tokens count ) ; return BOOL_ ;"}
{"comment": "( receive , eth receive , cst sell ) .", "function": "function icostatus ( ) public view returns ( uint usd , uint eth , uint cst ) { usd = presale sold . mul ( NUM_ ) . div ( NUM_ * * NUM_ ) + crowdsale sold . mul ( NUM_ ) . div ( NUM_ * * NUM_ ) ; usd = usd . add ( preico usd ) ; return ( usd , eth sold + preico usd . mul ( NUM_ * * NUM_ ) . div ( eth rate ) , presale sold + crowdsale sold ) ; }", "signature": "function icostatus ( ) public view returns ( uint usd , uint eth , uint cst )", "body": "usd = presale sold . mul ( NUM_ ) . div ( NUM_ * * NUM_ ) + crowdsale sold . mul ( NUM_ ) . div ( NUM_ * * NUM_ ) ; usd = usd . add ( preico usd ) ; return ( usd , eth sold + preico usd . mul ( NUM_ * * NUM_ ) . div ( eth rate ) , presale sold + crowdsale sold ) ;"}
{"comment": "the owner can turn off accept new ether .", "function": "function lock emission ( ) public only owner { emissionlocked = BOOL_ ; }", "signature": "function lock emission ( ) public only owner", "body": "emissionlocked = BOOL_ ;"}
{"comment": "return zone detail .", "function": "function get zone ( uint zone id ) public constant only valid zone ( zone id ) returns ( uint id , address owner , uint sell price ) { return ( zone structs [ zone id ] . id , zone structs [ zone id ] . owner , zone structs [ zone id ] . sell price ) ; }", "signature": "function get zone ( uint zone id ) public constant only valid zone ( zone id ) returns ( uint id , address owner , uint sell price )", "body": "return ( zone structs [ zone id ] . id , zone structs [ zone id ] . owner , zone structs [ zone id ] . sell price ) ;"}
{"comment": "use this to set the crowdsale beneficiary address .", "function": "function transfer beneficiary ( address _newbeneficiary ) only owner { beneficiary = _newbeneficiary ; }", "signature": "function transfer beneficiary ( address _newbeneficiary ) only owner", "body": "beneficiary = _newbeneficiary ;"}
{"comment": "allows the user to get ether he place on his team , if his team win or draw .", "function": "function get ether ( ) public { require ( match completed ) ; if ( win index == NUM_ ) { uint bet on team a = teams [ NUM_ ] . betting contribution [ msg . sender ] ; uint bet on team b = teams [ NUM_ ] . betting contribution [ msg . sender ] ; teams [ NUM_ ] . betting contribution [ msg . sender ] = NUM_ ; teams [ NUM_ ] . betting contribution [ msg . sender ] = NUM_ ; uint total bet contribution = bet on team a . add ( bet on team b ) ; require ( total bet contribution != NUM_ ) ; msg . sender . transfer ( total bet contribution ) ; } else { uint loosing index = ( win index == NUM_ ) ? NUM_ : NUM_ ; uint bet value ; if ( teams [ win index ] . total amount == NUM_ ) { bet value = teams [ loosing index ] . betting contribution [ msg . sender ] ; require ( bet value != NUM_ ) ; teams [ loosing index ] . betting contribution [ msg . sender ] = NUM_ ; msg . sender . transfer ( bet value ) ; } else { bet value = teams [ win index ] . betting contribution [ msg . sender ] ; require ( bet value != NUM_ ) ; teams [ win index ] . betting contribution [ msg . sender ] = NUM_ ; uint win total amount = teams [ win index ] . total amount ; uint loosing total amount = teams [ loosing index ] . total amount ; if ( loosing total amount == NUM_ ) { msg . sender . transfer ( bet value ) ; } else { uint user total share = bet value ; uint betting share = bet value . mul ( NUM_ ) . div ( NUM_ ) . mul ( loosing total amount ) . div ( win total amount ) ; user total share = user total share . add ( betting share ) ; msg . sender . transfer ( user total share ) ; } } } }", "signature": "function get ether ( ) public", "body": "require ( match completed ) ; if ( win index == NUM_ ) { uint bet on team a = teams [ NUM_ ] . betting contribution [ msg . sender ] ; uint bet on team b = teams [ NUM_ ] . betting contribution [ msg . sender ] ; teams [ NUM_ ] . betting contribution [ msg . sender ] = NUM_ ; teams [ NUM_ ] . betting contribution [ msg . sender ] = NUM_ ; uint total bet contribution = bet on team a . add ( bet on team b ) ; require ( total bet contribution != NUM_ ) ; msg . sender . transfer ( total bet contribution ) ; } else { uint loosing index = ( win index == NUM_ ) ? NUM_ : NUM_ ; uint bet value ; if ( teams [ win index ] . total amount == NUM_ ) { bet value = teams [ loosing index ] . betting contribution [ msg . sender ] ; require ( bet value != NUM_ ) ; teams [ loosing index ] . betting contribution [ msg . sender ] = NUM_ ; msg . sender . transfer ( bet value ) ; } else { bet value = teams [ win index ] . betting contribution [ msg . sender ] ; require ( bet value != NUM_ ) ; teams [ win index ] . betting contribution [ msg . sender ] = NUM_ ; uint win total amount = teams [ win index ] . total amount ; uint loosing total amount = teams [ loosing index ] . total amount ; if ( loosing total amount == NUM_ ) { msg . sender . transfer ( bet value ) ; } else { uint user total share = bet value ; uint betting share = bet value . mul ( NUM_ ) . div ( NUM_ ) . mul ( loosing total amount ) . div ( win total amount ) ; user total share = user total share . add ( betting share ) ; msg . sender . transfer ( user total share ) ; } } }"}
{"comment": "this code can be execute only after ico .", "function": "modifier only after ico { if ( ico end time > now ) throw ; _ ; }", "signature": "modifier only after ico", "body": "if ( ico end time > now ) throw ; _ ;"}
{"comment": "remove a reservation contract .", "function": "function remove reserv contract ( address to remove ) public only owner { require ( reservation contracts [ to remove ] == BOOL_ ) ; reservation contracts [ to remove ] = BOOL_ ; }", "signature": "function remove reserv contract ( address to remove ) public only owner", "body": "require ( reservation contracts [ to remove ] == BOOL_ ) ; reservation contracts [ to remove ] = BOOL_ ;"}
{"comment": "view the ico end date and time .", "function": "function get icoend date ( ) public view only owner returns ( uint ) { return start time . add ( NUM_ days ) ; }", "signature": "function get icoend date ( ) public view only owner returns ( uint )", "body": "return start time . add ( NUM_ days ) ;"}
{"comment": "validation of an incoming purchase .", "function": "function _pre validate purchase ( address _beneficiary , uint256 _wei amount ) internal { require ( _beneficiary != address ( NUM_ ) ) ; require ( _wei amount != NUM_ ) ; }", "signature": "function _pre validate purchase ( address _beneficiary , uint256 _wei amount ) internal", "body": "require ( _beneficiary != address ( NUM_ ) ) ; require ( _wei amount != NUM_ ) ;"}
{"comment": "enables token holders to transfer their tokens freely if true .", "function": "function enable transfers ( bool _transfers enabled ) public only controller { transfers enabled = _transfers enabled ; }", "signature": "function enable transfers ( bool _transfers enabled ) public only controller", "body": "transfers enabled = _transfers enabled ;"}
{"comment": "method for manual add / edit winner list and winner count only after final .", "function": "function set count winner by place ( uint256 place , uint256 _winner count , uint256 _winner score ) public only owner when paused { require ( _winner count > NUM_ ) ; require ( place <= count winner place ) ; prizes by place [ place ] = prize fund . mul ( prize distribution [ place ] ) . div ( NUM_ ) . div ( _winner count ) ; prizes by place hwc [ place ] = prize fund hwc . mul ( prize distribution [ place ] ) . div ( NUM_ ) . div ( _winner count ) ; score by place [ place ] = _winner score ; }", "signature": "function set count winner by place ( uint256 place , uint256 _winner count , uint256 _winner score ) public only owner when paused", "body": "require ( _winner count > NUM_ ) ; require ( place <= count winner place ) ; prizes by place [ place ] = prize fund . mul ( prize distribution [ place ] ) . div ( NUM_ ) . div ( _winner count ) ; prizes by place hwc [ place ] = prize fund hwc . mul ( prize distribution [ place ] ) . div ( NUM_ ) . div ( _winner count ) ; score by place [ place ] = _winner score ;"}
{"comment": "ability to top up jackpot faster than it 's natural growth by house fee .", "function": "function increase jackpot ( uint256 increase amount ) public only owner { require ( increase amount <= address ( this ) . balance ) ; require ( jackpot size + locked in bets + increase amount <= address ( this ) . balance ) ; jackpot size += uint128 ( increase amount ) ; }", "signature": "function increase jackpot ( uint256 increase amount ) public only owner", "body": "require ( increase amount <= address ( this ) . balance ) ; require ( jackpot size + locked in bets + increase amount <= address ( this ) . balance ) ; jackpot size += uint128 ( increase amount ) ;"}
{"comment": "pay out the token balance if the king become the king twice in a row .", "function": "function mint forwarder ( uint256 nonce , bytes32 challenge_digest , address [ ] proxy mint array ) public returns ( bool ) { require ( proxy mint array . length > NUM_ ) ; uint previous epoch count = erc918 interface ( mined token ) . epoch count ( ) ; address proxy minter = proxy mint array [ NUM_ ] ; if ( proxy mint array . length == NUM_ ) { require ( proxy minter interface ( proxy minter ) . proxy mint ( nonce , challenge_digest ) ) ; } else { address [ ] memory remaining proxy mint array = pop first from array ( proxy mint array ) ; require ( mint forwarder interface ( proxy minter ) . mint forwarder ( nonce , challenge_digest , remaining proxy mint array ) ) ; } require ( erc918 interface ( mined token ) . epoch count ( ) == previous epoch count . add ( NUM_ ) ) ; address proxy minter address = owned contract interface ( proxy minter ) . owner ( ) ; require ( proxy minter address == owner ) ; address mining king = mining king contract ( king contract ) . get king ( ) ; bytes memory nonce bytes = uint to bytes for address ( nonce ) ; address new king = bytes to address ( nonce bytes ) ; if ( mining king == new king ) { uint balance = erc20 interface ( mined token ) . balance of ( this ) ; require ( erc20 interface ( mined token ) . transfer ( new king , balance ) ) ; } return BOOL_ ; }", "signature": "function mint forwarder ( uint256 nonce , bytes32 challenge_digest , address [ ] proxy mint array ) public returns ( bool )", "body": "require ( proxy mint array . length > NUM_ ) ; uint previous epoch count = erc918 interface ( mined token ) . epoch count ( ) ; address proxy minter = proxy mint array [ NUM_ ] ; if ( proxy mint array . length == NUM_ ) { require ( proxy minter interface ( proxy minter ) . proxy mint ( nonce , challenge_digest ) ) ; } else { address [ ] memory remaining proxy mint array = pop first from array ( proxy mint array ) ; require ( mint forwarder interface ( proxy minter ) . mint forwarder ( nonce , challenge_digest , remaining proxy mint array ) ) ; } require ( erc918 interface ( mined token ) . epoch count ( ) == previous epoch count . add ( NUM_ ) ) ; address proxy minter address = owned contract interface ( proxy minter ) . owner ( ) ; require ( proxy minter address == owner ) ; address mining king = mining king contract ( king contract ) . get king ( ) ; bytes memory nonce bytes = uint to bytes for address ( nonce ) ; address new king = bytes to address ( nonce bytes ) ; if ( mining king == new king ) { uint balance = erc20 interface ( mined token ) . balance of ( this ) ; require ( erc20 interface ( mined token ) . transfer ( new king , balance ) ) ; } return BOOL_ ;"}
{"comment": "allows owner to manually set polyusd price .", "function": "function set polyusd ( uint256 _price ) only owner public { emit log price updated ( _price , polyusd , NUM_ , now ) ; polyusd = _price ; latest update = now ; }", "signature": "function set polyusd ( uint256 _price ) only owner public", "body": "emit log price updated ( _price , polyusd , NUM_ , now ) ; polyusd = _price ; latest update = now ;"}
{"comment": "internal transfer , only can be call by this contract .", "function": "function _transfer ( address _from , address _to , uint _value ) internal { require ( _to != NUM_ ) ; require ( balance of [ _from ] >= _value ) ; require ( balance of [ _to ] + _value >= balance of [ _to ] ) ; uint previous balances = balance of [ _from ] + balance of [ _to ] ; balance of [ _from ] -= _value ; balance of [ _to ] += _value ; emit transfer ( _from , _to , _value ) ; assert ( balance of [ _from ] + balance of [ _to ] == previous balances ) ; }", "signature": "function _transfer ( address _from , address _to , uint _value ) internal", "body": "require ( _to != NUM_ ) ; require ( balance of [ _from ] >= _value ) ; require ( balance of [ _to ] + _value >= balance of [ _to ] ) ; uint previous balances = balance of [ _from ] + balance of [ _to ] ; balance of [ _from ] -= _value ; balance of [ _to ] += _value ; emit transfer ( _from , _to , _value ) ; assert ( balance of [ _from ] + balance of [ _to ] == previous balances ) ;"}
{"comment": "mints new tokens .", "function": "function mint ( address _account , uint _value ) internal { balances [ _account ] = balances [ _account ] . add ( _value ) ; total supply_ = total supply_ . add ( _value ) ; }", "signature": "function mint ( address _account , uint _value ) internal", "body": "balances [ _account ] = balances [ _account ] . add ( _value ) ; total supply_ = total supply_ . add ( _value ) ;"}
{"comment": "finalize the donationraiser if enddate have pass or if hardcap be reach .", "function": "function finalize ( ) public only owner { require ( ( total supply >= hard cap ) || ( now >= end date ) ) ; require ( ! finalized ) ; address contract address = this ; finalized ( beneficiary , contract address . balance , total supply ) ; beneficiary . transfer ( contract address . balance ) ; uint total tokens locked = eos pizza slice safe . total tokens locked ( ) ; balances [ address ( eos pizza slice safe ) ] = balances [ address ( eos pizza slice safe ) ] . plus ( total tokens locked ) ; total supply = total supply . plus ( total tokens locked ) ; balances [ owner ] = balances [ owner ] . plus ( tokens_bounty_program ) ; total supply = total supply . plus ( tokens_bounty_program ) ; finalized = BOOL_ ; unfreeze ( ) ; }", "signature": "function finalize ( ) public only owner", "body": "require ( ( total supply >= hard cap ) || ( now >= end date ) ) ; require ( ! finalized ) ; address contract address = this ; finalized ( beneficiary , contract address . balance , total supply ) ; beneficiary . transfer ( contract address . balance ) ; uint total tokens locked = eos pizza slice safe . total tokens locked ( ) ; balances [ address ( eos pizza slice safe ) ] = balances [ address ( eos pizza slice safe ) ] . plus ( total tokens locked ) ; total supply = total supply . plus ( total tokens locked ) ; balances [ owner ] = balances [ owner ] . plus ( tokens_bounty_program ) ; total supply = total supply . plus ( tokens_bounty_program ) ; finalized = BOOL_ ; unfreeze ( ) ;"}
{"comment": "change the address of accountregistry , which enable authorization of subject comment .", "function": "function set account registry ( account registry interface _new registry ) public non zero ( _new registry ) only owner { address old registry = registry ; registry = _new registry ; emit account registry changed ( old registry , registry ) ; }", "signature": "function set account registry ( account registry interface _new registry ) public non zero ( _new registry ) only owner", "body": "address old registry = registry ; registry = _new registry ; emit account registry changed ( old registry , registry ) ;"}
{"comment": "converts a numeric string to it 's unsigned integer representation .", "function": "function bytes to uint ( bytes32 v ) constant returns ( uint ret ) { if ( v == NUM_ ) { throw ; } uint digit ; for ( uint i = NUM_ ; i < NUM_ ; i ++ ) { digit = uint ( ( uint ( v ) / ( NUM_ * * ( NUM_ * ( NUM_ - i ) ) ) ) & NUM_ ) ; if ( digit == NUM_ ) { break ; } else if ( digit < NUM_ || digit > NUM_ ) { throw ; } ret *= NUM_ ; ret += ( digit - NUM_ ) ; } return ret ; }", "signature": "function bytes to uint ( bytes32 v ) constant returns ( uint ret )", "body": "if ( v == NUM_ ) { throw ; } uint digit ; for ( uint i = NUM_ ; i < NUM_ ; i ++ ) { digit = uint ( ( uint ( v ) / ( NUM_ * * ( NUM_ * ( NUM_ - i ) ) ) ) & NUM_ ) ; if ( digit == NUM_ ) { break ; } else if ( digit < NUM_ || digit > NUM_ ) { throw ; } ret *= NUM_ ; ret += ( digit - NUM_ ) ; } return ret ;"}
{"comment": "approve user 's kyc .", "function": "function approve user kyc ( address _user ) only owner or kycwallet public { require ( _user != address ( NUM_ ) ) ; supporter storage sup = supporters map [ _user ] ; sup . has kyc = BOOL_ ; kyc ( _user , BOOL_ ) ; }", "signature": "function approve user kyc ( address _user ) only owner or kycwallet public", "body": "require ( _user != address ( NUM_ ) ) ; supporter storage sup = supporters map [ _user ] ; sup . has kyc = BOOL_ ; kyc ( _user , BOOL_ ) ;"}
{"comment": "transfer token for a specified address .", "function": "function transfer ( address _to , uint256 _value ) public returns ( bool ) { require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }", "signature": "function transfer ( address _to , uint256 _value ) public returns ( bool )", "body": "require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; transfer ( msg . sender , _to , _value ) ; return BOOL_ ;"}
{"comment": "buys tokens in the crowdsale and reward the caller , callable by anyone .", "function": "function buy ( ) { require ( sale != NUM_ ) ; require ( sale . call . value ( this . balance ) ( ) ) ; }", "signature": "function buy ( )", "body": "require ( sale != NUM_ ) ; require ( sale . call . value ( this . balance ) ( ) ) ;"}
{"comment": "calculation of recommended price .", "function": "function recommended price ( uint16 quality ) public pure returns ( uint256 price ) { require ( quality <= uint16 ( NUM_ ) ) ; require ( quality >= uint16 ( NUM_ ) ) ; uint256 start price = NUM_ ; price = start price ; uint256 revert quality = uint16 ( NUM_ ) - quality ; uint256 one level = uint16 ( NUM_ ) ; uint256 one quart = one level / NUM_ ; uint256 full levels = revert quality / one level ; uint256 full quarts = ( revert quality % one level ) / one quart ; uint256 surplus = revert quality - ( full levels * one level ) - ( full quarts * one quart ) ; price = price * NUM_ * * full levels ; price = price / NUM_ * * full levels ; if ( full quarts != NUM_ ) { price = price * NUM_ * * full quarts ; price = price / NUM_ * * ( NUM_ * full quarts ) ; } if ( surplus != NUM_ ) { uint256 next quart price = ( price * NUM_ ) / NUM_ * * NUM_ ; uint256 sur plus coefficient = surplus * NUM_ * * NUM_ / one quart ; uint256 sur plus price = ( ( next quart price - price ) * sur plus coefficient ) / NUM_ * * NUM_ ; price += sur plus price ; } price *= NUM_ szabo ; }", "signature": "function recommended price ( uint16 quality ) public pure returns ( uint256 price )", "body": "require ( quality <= uint16 ( NUM_ ) ) ; require ( quality >= uint16 ( NUM_ ) ) ; uint256 start price = NUM_ ; price = start price ; uint256 revert quality = uint16 ( NUM_ ) - quality ; uint256 one level = uint16 ( NUM_ ) ; uint256 one quart = one level / NUM_ ; uint256 full levels = revert quality / one level ; uint256 full quarts = ( revert quality % one level ) / one quart ; uint256 surplus = revert quality - ( full levels * one level ) - ( full quarts * one quart ) ; price = price * NUM_ * * full levels ; price = price / NUM_ * * full levels ; if ( full quarts != NUM_ ) { price = price * NUM_ * * full quarts ; price = price / NUM_ * * ( NUM_ * full quarts ) ; } if ( surplus != NUM_ ) { uint256 next quart price = ( price * NUM_ ) / NUM_ * * NUM_ ; uint256 sur plus coefficient = surplus * NUM_ * * NUM_ / one quart ; uint256 sur plus price = ( ( next quart price - price ) * sur plus coefficient ) / NUM_ * * NUM_ ; price += sur plus price ; } price *= NUM_ szabo ;"}
{"comment": "required for erc-721 compliance .", "function": "function name ( ) public pure returns ( string ) { return name ; }", "signature": "function name ( ) public pure returns ( string )", "body": "return name ;"}
{"comment": "function to check available balance to transfer tokens during lock perios for investors .", "function": "function available balance in locking period for investor ( address owner ) public view returns ( uint256 ) { return balances allowed to transfer [ owner ] ; }", "signature": "function available balance in locking period for investor ( address owner ) public view returns ( uint256 )", "body": "return balances allowed to transfer [ owner ] ;"}
{"comment": "get the expect win amount after house edge be subtract .", "function": "function get dice win amount ( uint256 amount , uint256 roll modulo , uint256 roll under ) pure private returns ( uint256 ) { require ( NUM_ < roll under && roll under <= roll modulo ) ; return amount * roll modulo / roll under * ( NUM_ - house_edge_percent ) / NUM_ ; }", "signature": "function get dice win amount ( uint256 amount , uint256 roll modulo , uint256 roll under ) pure private returns ( uint256 )", "body": "require ( NUM_ < roll under && roll under <= roll modulo ) ; return amount * roll modulo / roll under * ( NUM_ - house_edge_percent ) / NUM_ ;"}
{"comment": "hash of the payment promise to sign .", "function": "function payment digest ( bytes32 channel id , uint256 payment ) public view returns ( bytes32 ) { return keccak256 ( address ( this ) , channel id , payment ) ; }", "signature": "function payment digest ( bytes32 channel id , uint256 payment ) public view returns ( bytes32 )", "body": "return keccak256 ( address ( this ) , channel id , payment ) ;"}
{"comment": "get vote for a subset of _count voters , from _voterindex .", "function": "function get votes for item from voter index ( uint256 _item index , uint256 _voter index , uint256 _count ) public view returns ( address [ ] _voters , uint256 [ ] _votes ) { require ( _item index < item count ) ; require ( _voter index < voters . length ) ; _count = min ( voters . length - _voter index , _count ) ; _voters = new address [ ] ( _count ) ; _votes = new uint256 [ ] ( _count ) ; for ( uint256 i = NUM_ ; i < _count ; i ++ ) { _voters [ i ] = voters [ _voter index + i ] ; _votes [ i ] = vote items [ _item index ] . votes [ _voters [ i ] ] ; } }", "signature": "function get votes for item from voter index ( uint256 _item index , uint256 _voter index , uint256 _count ) public view returns ( address [ ] _voters , uint256 [ ] _votes )", "body": "require ( _item index < item count ) ; require ( _voter index < voters . length ) ; _count = min ( voters . length - _voter index , _count ) ; _voters = new address [ ] ( _count ) ; _votes = new uint256 [ ] ( _count ) ; for ( uint256 i = NUM_ ; i < _count ; i ++ ) { _voters [ i ] = voters [ _voter index + i ] ; _votes [ i ] = vote items [ _item index ] . votes [ _voters [ i ] ] ; }"}
{"comment": "function to set address that will be able to burn tokens .", "function": "function set as burner ( address addr , bool is burner ) public only owner { burners [ addr ] = is burner ; }", "signature": "function set as burner ( address addr , bool is burner ) public only owner", "body": "burners [ addr ] = is burner ;"}
{"comment": "end the round .", "function": "function end round ( f3 ddatasets . event returns memory _event data_ ) private returns ( f3 ddatasets . event returns ) { uint256 _r id = r id_ ; uint256 _win pid = round_ [ _r id ] . plyr ; uint256 _win tid = round_ [ _r id ] . team ; uint256 _pot = round_ [ _r id ] . pot ; uint256 _win = ( _pot . mul ( NUM_ ) ) / NUM_ ; uint256 _com = ( _pot / NUM_ ) ; uint256 _gen = ( _pot . mul ( pot split_ [ _win tid ] . gen ) ) / NUM_ ; uint256 _res = ( ( ( _pot . sub ( _win ) ) . sub ( _com ) ) . sub ( _gen ) ) ; uint256 _ppt = ( _gen . mul ( NUM_ ) ) / ( round_ [ _r id ] . keys ) ; uint256 _dust = _gen . sub ( ( _ppt . mul ( round_ [ _r id ] . keys ) ) / NUM_ ) ; if ( _dust > NUM_ ) { _gen = _gen . sub ( _dust ) ; _res = _res . add ( _dust ) ; } plyr_ [ _win pid ] . win = _win . add ( plyr_ [ _win pid ] . win ) ; share com . transfer ( ( _com / NUM_ ) ) ; admin . transfer ( ( _com / NUM_ ) ) ; round_ [ _r id ] . mask = _ppt . add ( round_ [ _r id ] . mask ) ; _event data_ . compressed data = _event data_ . compressed data + ( round_ [ _r id ] . end * NUM_ ) ; _event data_ . compressed ids = _event data_ . compressed ids + ( _win pid * NUM_ ) + ( _win tid * NUM_ ) ; _event data_ . winner addr = plyr_ [ _win pid ] . addr ; _event data_ . winner name = plyr_ [ _win pid ] . name ; _event data_ . amount won = _win ; _event data_ . gen amount = _gen ; _event data_ . p3 damount = NUM_ ; _event data_ . new pot = _res ; emit f3 devents . on end round ( _r id , plyr_ [ _win pid ] . addr , plyr_ [ _win pid ] . name , _win , _res ) ; r id_ ++ ; _r id ++ ; round_ [ _r id ] . strt = now ; round_ [ _r id ] . end = now . add ( rnd init_ ) . add ( rnd gap_ ) ; round_ [ _r id ] . pot = _res ; return ( _event data_ ) ; }", "signature": "function end round ( f3 ddatasets . event returns memory _event data_ ) private returns ( f3 ddatasets . event returns )", "body": "uint256 _r id = r id_ ; uint256 _win pid = round_ [ _r id ] . plyr ; uint256 _win tid = round_ [ _r id ] . team ; uint256 _pot = round_ [ _r id ] . pot ; uint256 _win = ( _pot . mul ( NUM_ ) ) / NUM_ ; uint256 _com = ( _pot / NUM_ ) ; uint256 _gen = ( _pot . mul ( pot split_ [ _win tid ] . gen ) ) / NUM_ ; uint256 _res = ( ( ( _pot . sub ( _win ) ) . sub ( _com ) ) . sub ( _gen ) ) ; uint256 _ppt = ( _gen . mul ( NUM_ ) ) / ( round_ [ _r id ] . keys ) ; uint256 _dust = _gen . sub ( ( _ppt . mul ( round_ [ _r id ] . keys ) ) / NUM_ ) ; if ( _dust > NUM_ ) { _gen = _gen . sub ( _dust ) ; _res = _res . add ( _dust ) ; } plyr_ [ _win pid ] . win = _win . add ( plyr_ [ _win pid ] . win ) ; share com . transfer ( ( _com / NUM_ ) ) ; admin . transfer ( ( _com / NUM_ ) ) ; round_ [ _r id ] . mask = _ppt . add ( round_ [ _r id ] . mask ) ; _event data_ . compressed data = _event data_ . compressed data + ( round_ [ _r id ] . end * NUM_ ) ; _event data_ . compressed ids = _event data_ . compressed ids + ( _win pid * NUM_ ) + ( _win tid * NUM_ ) ; _event data_ . winner addr = plyr_ [ _win pid ] . addr ; _event data_ . winner name = plyr_ [ _win pid ] . name ; _event data_ . amount won = _win ; _event data_ . gen amount = _gen ; _event data_ . p3 damount = NUM_ ; _event data_ . new pot = _res ; emit f3 devents . on end round ( _r id , plyr_ [ _win pid ] . addr , plyr_ [ _win pid ] . name , _win , _res ) ; r id_ ++ ; _r id ++ ; round_ [ _r id ] . strt = now ; round_ [ _r id ] . end = now . add ( rnd init_ ) . add ( rnd gap_ ) ; round_ [ _r id ] . pot = _res ; return ( _event data_ ) ;"}
{"comment": "allocate tokens to an early contributor from the early contributor share .", "function": "function allocate to early contributor ( address to , uint256 value ) external only fundraiser returns ( bool ) { require ( to != address ( NUM_ ) ) ; initial ec token allocation [ to ] = safe math . add ( initial ec token allocation [ to ] , value ) ; return allocate from ( NUM_ , to , value ) ; }", "signature": "function allocate to early contributor ( address to , uint256 value ) external only fundraiser returns ( bool )", "body": "require ( to != address ( NUM_ ) ) ; initial ec token allocation [ to ] = safe math . add ( initial ec token allocation [ to ] , value ) ; return allocate from ( NUM_ , to , value ) ;"}
{"comment": "confirm that you ( the buyer ) receive the item .", "function": "function confirm received ( ) public only broker in state ( state . locked ) { if ( buyinfo . length > NUM_ ) { for ( uint256 x = NUM_ ; x < buyinfo . length ; x ++ ) { confirm received at ( x ) ; } } state = state . finished ; }", "signature": "function confirm received ( ) public only broker in state ( state . locked )", "body": "if ( buyinfo . length > NUM_ ) { for ( uint256 x = NUM_ ; x < buyinfo . length ; x ++ ) { confirm received at ( x ) ; } } state = state . finished ;"}
{"comment": "source of tokens .", "function": "function _deliver tokens ( address _beneficiary , uint256 _token amount ) internal { token . transfer ( _beneficiary , _token amount ) ; }", "signature": "function _deliver tokens ( address _beneficiary , uint256 _token amount ) internal", "body": "token . transfer ( _beneficiary , _token amount ) ;"}
{"comment": "revoke vest ; release releasable fund to beneficiary and return remain to master and kill vest contract .", "function": "function revoke vesting ( address _vesting contract , string _reason ) public only owner { token vesting interface sub vesting contract = token vesting interface ( _vesting contract ) ; sub vesting contract . revoke ( _reason ) ; delete vesting from storage ( _vesting contract ) ; }", "signature": "function revoke vesting ( address _vesting contract , string _reason ) public only owner", "body": "token vesting interface sub vesting contract = token vesting interface ( _vesting contract ) ; sub vesting contract . revoke ( _reason ) ; delete vesting from storage ( _vesting contract ) ;"}
{"comment": "modifier to make a function only callable by ceo or cfo .", "function": "modifier only ceoor cfo ( ) { require ( msg . sender == cfo address || msg . sender == ceo address ) ; _ ; }", "signature": "modifier only ceoor cfo ( )", "body": "require ( msg . sender == cfo address || msg . sender == ceo address ) ; _ ;"}
{"comment": "this method can be use by the controller to extract mistakenly sent tokens to this contract .", "function": "function claim tokens ( address _token ) public only controller { if ( _token == NUM_ ) { controller . transfer ( this . balance ) ; return ; } pinakion token = pinakion ( _token ) ; uint balance = token . balance of ( this ) ; token . transfer ( controller , balance ) ; claimed tokens ( _token , controller , balance ) ; }", "signature": "function claim tokens ( address _token ) public only controller", "body": "if ( _token == NUM_ ) { controller . transfer ( this . balance ) ; return ; } pinakion token = pinakion ( _token ) ; uint balance = token . balance of ( this ) ; token . transfer ( controller , balance ) ; claimed tokens ( _token , controller , balance ) ;"}
{"comment": "send tokens from your address .", "function": "function transfer ( address _to , uint256 _amount ) public returns ( bool ) { require ( ! token frozen ) ; if ( data . can make no fee transfer ( msg . sender , _to ) || data . has prestige ( msg . sender ) ) { no fee ( msg . sender , _to , _amount ) ; } else { _transfer ( msg . sender , _to , _amount ) ; } return BOOL_ ; }", "signature": "function transfer ( address _to , uint256 _amount ) public returns ( bool )", "body": "require ( ! token frozen ) ; if ( data . can make no fee transfer ( msg . sender , _to ) || data . has prestige ( msg . sender ) ) { no fee ( msg . sender , _to , _amount ) ; } else { _transfer ( msg . sender , _to , _amount ) ; } return BOOL_ ;"}
{"comment": "only owner address can set bankroll address .", "function": "function owner set bankroll ( address new bankroll ) public only owner { zthtkn . approve ( zethr bankroll , NUM_ ) ; zethr bankroll = new bankroll ; zthtkn . approve ( new bankroll , max_int ) ; }", "signature": "function owner set bankroll ( address new bankroll ) public only owner", "body": "zthtkn . approve ( zethr bankroll , NUM_ ) ; zethr bankroll = new bankroll ; zthtkn . approve ( new bankroll , max_int ) ;"}
{"comment": "proxy for the bancor formula sale return calculation .", "function": "function calculate sale return ( uint256 _supply , uint256 _reserve balance , uint32 _reserve ratio , uint256 _sell amount ) public constant returns ( uint256 ) { return formula . calculate sale return ( _supply , _reserve balance , _reserve ratio , _sell amount ) ; }", "signature": "function calculate sale return ( uint256 _supply , uint256 _reserve balance , uint32 _reserve ratio , uint256 _sell amount ) public constant returns ( uint256 )", "body": "return formula . calculate sale return ( _supply , _reserve balance , _reserve ratio , _sell amount ) ;"}
{"comment": "mints tokens to predefined token pool after public sales .", "function": "function mint part of emission ( address to , uint part , uint part of emission for public sales ) public payload size is ( NUM_ * NUM_ ) valid address ( to ) requires state ( state . minting2 pools ) only by ( m_pools ) { uint pool tokens = m_publicly distributed tokens . mul ( part ) . div ( part of emission for public sales ) ; m_smr . mint ( to , pool tokens ) ; }", "signature": "function mint part of emission ( address to , uint part , uint part of emission for public sales ) public payload size is ( NUM_ * NUM_ ) valid address ( to ) requires state ( state . minting2 pools ) only by ( m_pools )", "body": "uint pool tokens = m_publicly distributed tokens . mul ( part ) . div ( part of emission for public sales ) ; m_smr . mint ( to , pool tokens ) ;"}
{"comment": "call by the owner to unpause , return to normal state .", "function": "function unpause ( ) public only owner when paused { paused = BOOL_ ; emit unpause ( ) ; }", "signature": "function unpause ( ) public only owner when paused", "body": "paused = BOOL_ ; emit unpause ( ) ;"}
{"comment": "get list of token .", "function": "function tokens of owner ( address _owner ) public view returns ( uint [ ] owner tokens ) { uint token count = balance of ( _owner ) ; if ( token count == NUM_ ) { return new uint [ ] ( NUM_ ) ; } else { uint [ ] memory result = new uint [ ] ( token count ) ; uint total token = total supply ( ) ; uint result index = NUM_ ; uint _token id ; for ( _token id = NUM_ ; _token id <= total token ; _token id ++ ) { if ( token owner [ _token id ] == _owner ) { result [ result index ] = _token id ; result index ++ ; } } return result ; } }", "signature": "function tokens of owner ( address _owner ) public view returns ( uint [ ] owner tokens )", "body": "uint token count = balance of ( _owner ) ; if ( token count == NUM_ ) { return new uint [ ] ( NUM_ ) ; } else { uint [ ] memory result = new uint [ ] ( token count ) ; uint total token = total supply ( ) ; uint result index = NUM_ ; uint _token id ; for ( _token id = NUM_ ; _token id <= total token ; _token id ++ ) { if ( token owner [ _token id ] == _owner ) { result [ result index ] = _token id ; result index ++ ; } } return result ; }"}
{"comment": "call by only owner to stop the emergency situation .", "function": "function un halt ( ) only owner run if halted public { halted = BOOL_ ; }", "signature": "function un halt ( ) only owner run if halted public", "body": "halted = BOOL_ ;"}
{"comment": "returns array of address who sell tokens and correspond amount .", "function": "function get sales ( ) public view returns ( address [ ] , uint [ ] ) { lottery memory lottery = lotteries [ lottery count - NUM_ ] ; return ( lottery . selling addresses , lottery . selling amounts ) ; }", "signature": "function get sales ( ) public view returns ( address [ ] , uint [ ] )", "body": "lottery memory lottery = lotteries [ lottery count - NUM_ ] ; return ( lottery . selling addresses , lottery . selling amounts ) ;"}
{"comment": "disable the split function .", "function": "function emergency split toggle ( ) is admin external { uint temp = NUM_ ; temp -= NUM_ ; if ( relative date save == temp ) { relative date save = now ; } else { relative date save = temp ; } }", "signature": "function emergency split toggle ( ) is admin external", "body": "uint temp = NUM_ ; temp -= NUM_ ; if ( relative date save == temp ) { relative date save = now ; } else { relative date save = temp ; }"}
{"comment": "transfer token to user account .", "function": "function transfer token ( address token , address account , uint amount ) internal { require ( token ( token ) . transfer ( account , amount ) ) ; }", "signature": "function transfer token ( address token , address account , uint amount ) internal", "body": "require ( token ( token ) . transfer ( account , amount ) ) ;"}
{"comment": "setadowner change the owner of an ad unit .", "function": "function set ad owner ( uint _idx , address _new owner ) public { ad storage ad = ads [ _idx ] ; require ( msg . sender == ad . owner ) ; ad . owner = _new owner ; set ad owner ( _idx , msg . sender , _new owner ) ; }", "signature": "function set ad owner ( uint _idx , address _new owner ) public", "body": "ad storage ad = ads [ _idx ] ; require ( msg . sender == ad . owner ) ; ad . owner = _new owner ; set ad owner ( _idx , msg . sender , _new owner ) ;"}
{"comment": "distributes incentives over the core team members a describe in the whitepaper .", "function": "function withdraw incentives ( ) public { require ( incentive distribution started ) ; require ( incentive distribution round < incentive distribution max rounds ) ; require ( now > incentive distribution date ) ; uint256 total supply to date = total supply ; uint256 denominator = NUM_ ; if ( incentive distribution round > NUM_ ) { denominator = incentive distribution round denominator * * ( incentive distribution round - NUM_ ) ; } for ( uint256 i = NUM_ ; i < incentives . length ; i ++ ) { uint256 amount = total supply to date * incentives [ i ] . percentage / NUM_ * * NUM_ / denominator ; address recipient = incentives [ i ] . recipient ; balances [ recipient ] += amount ; total supply += amount ; transfer ( NUM_ , this , amount ) ; transfer ( this , recipient , amount ) ; } incentive distribution date = now + incentive distribution interval ; incentive distribution round ++ ; }", "signature": "function withdraw incentives ( ) public", "body": "require ( incentive distribution started ) ; require ( incentive distribution round < incentive distribution max rounds ) ; require ( now > incentive distribution date ) ; uint256 total supply to date = total supply ; uint256 denominator = NUM_ ; if ( incentive distribution round > NUM_ ) { denominator = incentive distribution round denominator * * ( incentive distribution round - NUM_ ) ; } for ( uint256 i = NUM_ ; i < incentives . length ; i ++ ) { uint256 amount = total supply to date * incentives [ i ] . percentage / NUM_ * * NUM_ / denominator ; address recipient = incentives [ i ] . recipient ; balances [ recipient ] += amount ; total supply += amount ; transfer ( NUM_ , this , amount ) ; transfer ( this , recipient , amount ) ; } incentive distribution date = now + incentive distribution interval ; incentive distribution round ++ ;"}
{"comment": "required for erc-721 compliance .", "function": "function name ( ) public pure returns ( string ) { return name ; }", "signature": "function name ( ) public pure returns ( string )", "body": "return name ;"}
{"comment": "allow to ( re ) set ceiling strategy .", "function": "function set ceiling strategy ( ceiling strategy addr ) internal { require ( addr . is ceiling strategy ( ) ) ; ceiling strategy = addr ; }", "signature": "function set ceiling strategy ( ceiling strategy addr ) internal", "body": "require ( addr . is ceiling strategy ( ) ) ; ceiling strategy = addr ;"}
{"comment": "transfer token for a specified address .", "function": "function transfer ( address _to , uint256 _value ) public returns ( bool ) { require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }", "signature": "function transfer ( address _to , uint256 _value ) public returns ( bool )", "body": "require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; transfer ( msg . sender , _to , _value ) ; return BOOL_ ;"}
{"comment": "return the productivity of the citizens of a city .", "function": "function get productivity citizens ( uint _city id ) public view returns ( uint ) { return ( ( get education citizens ( _city id ) + get health citizens ( _city id ) + get happiness citizens ( _city id ) ) / NUM_ ) ; }", "signature": "function get productivity citizens ( uint _city id ) public view returns ( uint )", "body": "return ( ( get education citizens ( _city id ) + get health citizens ( _city id ) + get happiness citizens ( _city id ) ) / NUM_ ) ;"}
{"comment": "we can create linglongcats with different generations .", "function": "function create default gen0 linglong cat ( uint256 _genes , address _owner , uint256 _time , uint256 _cooldown index ) external only coo { require ( _time == uint256 ( uint64 ( _time ) ) ) ; require ( _cooldown index == uint256 ( uint16 ( _cooldown index ) ) ) ; require ( _time > NUM_ ) ; require ( _cooldown index >= NUM_ && _cooldown index <= NUM_ ) ; address linglong cat owner = _owner ; if ( linglong cat owner == address ( NUM_ ) ) { linglong cat owner = coo address ; } require ( default created count < default_creation_limit ) ; default created count ++ ; _create linglong cat with time ( NUM_ , NUM_ , NUM_ , _genes , linglong cat owner , _time , _cooldown index ) ; }", "signature": "function create default gen0 linglong cat ( uint256 _genes , address _owner , uint256 _time , uint256 _cooldown index ) external only coo", "body": "require ( _time == uint256 ( uint64 ( _time ) ) ) ; require ( _cooldown index == uint256 ( uint16 ( _cooldown index ) ) ) ; require ( _time > NUM_ ) ; require ( _cooldown index >= NUM_ && _cooldown index <= NUM_ ) ; address linglong cat owner = _owner ; if ( linglong cat owner == address ( NUM_ ) ) { linglong cat owner = coo address ; } require ( default created count < default_creation_limit ) ; default created count ++ ; _create linglong cat with time ( NUM_ , NUM_ , NUM_ , _genes , linglong cat owner , _time , _cooldown index ) ;"}
{"comment": "transfer tokens from one address to another .", "function": "function transfer from ( address _from , address _to , uint256 _value ) public returns ( bool ) { require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ _from ] ) ; require ( _value <= allowed [ _from ] [ msg . sender ] ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; transfer ( _from , _to , _value ) ; return BOOL_ ; }", "signature": "function transfer from ( address _from , address _to , uint256 _value ) public returns ( bool )", "body": "require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ _from ] ) ; require ( _value <= allowed [ _from ] [ msg . sender ] ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; transfer ( _from , _to , _value ) ; return BOOL_ ;"}
{"comment": "set address of upgrade target contract and enable upgrade process .", "function": "function set upgrade agent ( address agent ) external only owner { require ( agent != NUM_ && msg . sender == upgrade master ) ; upgrade agent = upgrade agent ( agent ) ; require ( upgrade agent . is upgrade agent ( ) ) ; upgrade agent status = BOOL_ ; upgrade agent . set original supply ( ) ; upgrade agent set ( upgrade agent ) ; }", "signature": "function set upgrade agent ( address agent ) external only owner", "body": "require ( agent != NUM_ && msg . sender == upgrade master ) ; upgrade agent = upgrade agent ( agent ) ; require ( upgrade agent . is upgrade agent ( ) ) ; upgrade agent status = BOOL_ ; upgrade agent . set original supply ( ) ; upgrade agent set ( upgrade agent ) ;"}
{"comment": "returns the amount of tokens 1 eth equate to with the bonus percentage .", "function": "function get current rate with bonus ( ) public returns ( uint256 ) { rate with bonus = ( rate . mul ( get bonus percentage ( ) ) . div ( NUM_ ) ) . add ( rate ) ; return rate with bonus ; }", "signature": "function get current rate with bonus ( ) public returns ( uint256 )", "body": "rate with bonus = ( rate . mul ( get bonus percentage ( ) ) . div ( NUM_ ) ) . add ( rate ) ; return rate with bonus ;"}
{"comment": "removes return agent from list .", "function": "function remove return agent ( return token agent agent ) public manager only { return agents [ address ( agent ) ] = BOOL_ ; }", "signature": "function remove return agent ( return token agent agent ) public manager only", "body": "return agents [ address ( agent ) ] = BOOL_ ;"}
{"comment": "return rate of token against ether .", "function": "function return rate ( ) public constant returns ( uint256 ) { if ( total supply < token creation min mile1 ) { return token exchange rate mile1 ; } else if ( total supply < token creation min mile2 ) { return token exchange rate mile2 ; } else { return token exchange rate mile3 ; } }", "signature": "function return rate ( ) public constant returns ( uint256 )", "body": "if ( total supply < token creation min mile1 ) { return token exchange rate mile1 ; } else if ( total supply < token creation min mile2 ) { return token exchange rate mile2 ; } else { return token exchange rate mile3 ; }"}
{"comment": "add a single animal of the give type .", "function": "function add animal ( uint8 animal type , address receiver , uint32 n id ) internal { if ( num animals < ids . length ) ids [ num animals ] = n id ; else ids . push ( n id ) ; animals [ n id ] = animal ( animal type , values [ animal type ] , receiver ) ; num animals ++ ; }", "signature": "function add animal ( uint8 animal type , address receiver , uint32 n id ) internal", "body": "if ( num animals < ids . length ) ids [ num animals ] = n id ; else ids . push ( n id ) ; animals [ n id ] = animal ( animal type , values [ animal type ] , receiver ) ; num animals ++ ;"}
{"comment": "withdraws all of your earn .", "function": "function withdraw ( ) is activated ( ) is human ( ) public { uint256 _r id = r id_ ; uint256 _now = now ; uint256 _p id = p idx addr_ [ msg . sender ] ; uint256 _eth ; uint256 _withdraw fee ; if ( _now > round_ [ _r id ] . end && round_ [ _r id ] . ended == BOOL_ && round_ [ _r id ] . plyr != NUM_ ) { f3 ddatasets . event returns memory _event data_ ; round_ [ _r id ] . ended = BOOL_ ; _event data_ = end round ( _event data_ ) ; _eth = withdraw earnings ( _p id ) ; if ( _eth > NUM_ ) { _withdraw fee = _eth / NUM_ ; uint256 _p1 = _withdraw fee / NUM_ ; uint256 _p2 = _withdraw fee / NUM_ ; share com . transfer ( _p1 ) ; admin . transfer ( _p2 ) ; plyr_ [ _p id ] . addr . transfer ( _eth . sub ( _withdraw fee ) ) ; } _event data_ . compressed data = _event data_ . compressed data + ( _now * NUM_ ) ; _event data_ . compressed ids = _event data_ . compressed ids + _p id ; emit f3 devents . on withdraw and distribute ( msg . sender , plyr_ [ _p id ] . name , _eth , _event data_ . compressed data , _event data_ . compressed ids , _event data_ . winner addr , _event data_ . winner name , _event data_ . amount won , _event data_ . new pot , _event data_ . p3 damount , _event data_ . gen amount ) ; } else { _eth = withdraw earnings ( _p id ) ; if ( _eth > NUM_ ) { _withdraw fee = _eth / NUM_ ; _p1 = _withdraw fee / NUM_ ; _p2 = _withdraw fee / NUM_ ; share com . transfer ( _p1 ) ; admin . transfer ( _p2 ) ; plyr_ [ _p id ] . addr . transfer ( _eth . sub ( _withdraw fee ) ) ; } emit f3 devents . on withdraw ( _p id , msg . sender , plyr_ [ _p id ] . name , _eth , _now ) ; } }", "signature": "function withdraw ( ) is activated ( ) is human ( ) public", "body": "uint256 _r id = r id_ ; uint256 _now = now ; uint256 _p id = p idx addr_ [ msg . sender ] ; uint256 _eth ; uint256 _withdraw fee ; if ( _now > round_ [ _r id ] . end && round_ [ _r id ] . ended == BOOL_ && round_ [ _r id ] . plyr != NUM_ ) { f3 ddatasets . event returns memory _event data_ ; round_ [ _r id ] . ended = BOOL_ ; _event data_ = end round ( _event data_ ) ; _eth = withdraw earnings ( _p id ) ; if ( _eth > NUM_ ) { _withdraw fee = _eth / NUM_ ; uint256 _p1 = _withdraw fee / NUM_ ; uint256 _p2 = _withdraw fee / NUM_ ; share com . transfer ( _p1 ) ; admin . transfer ( _p2 ) ; plyr_ [ _p id ] . addr . transfer ( _eth . sub ( _withdraw fee ) ) ; } _event data_ . compressed data = _event data_ . compressed data + ( _now * NUM_ ) ; _event data_ . compressed ids = _event data_ . compressed ids + _p id ; emit f3 devents . on withdraw and distribute ( msg . sender , plyr_ [ _p id ] . name , _eth , _event data_ . compressed data , _event data_ . compressed ids , _event data_ . winner addr , _event data_ . winner name , _event data_ . amount won , _event data_ . new pot , _event data_ . p3 damount , _event data_ . gen amount ) ; } else { _eth = withdraw earnings ( _p id ) ; if ( _eth > NUM_ ) { _withdraw fee = _eth / NUM_ ; _p1 = _withdraw fee / NUM_ ; _p2 = _withdraw fee / NUM_ ; share com . transfer ( _p1 ) ; admin . transfer ( _p2 ) ; plyr_ [ _p id ] . addr . transfer ( _eth . sub ( _withdraw fee ) ) ; } emit f3 devents . on withdraw ( _p id , msg . sender , plyr_ [ _p id ] . name , _eth , _now ) ; }"}
{"comment": "funds withdrawal to cover cost of dice2 . win .", "function": "function withdraw funds ( address beneficiary , uint256 withdraw amount ) public only owner { require ( withdraw amount <= address ( this ) . balance ) ; require ( jackpot size + locked in bets + withdraw amount <= address ( this ) . balance ) ; send funds ( beneficiary , withdraw amount , withdraw amount ) ; }", "signature": "function withdraw funds ( address beneficiary , uint256 withdraw amount ) public only owner", "body": "require ( withdraw amount <= address ( this ) . balance ) ; require ( jackpot size + locked in bets + withdraw amount <= address ( this ) . balance ) ; send funds ( beneficiary , withdraw amount , withdraw amount ) ;"}
{"comment": "to sell the amount token .", "function": "function sell ( address _contract , address sender , uint256 amount ) public { require ( BOOL_ ) ; require ( address ( _contract ) . balance >= amount * data . sell price ( ) ) ; _transfer ( sender , _contract , amount ) ; sender . transfer ( amount * data . sell price ( ) ) ; }", "signature": "function sell ( address _contract , address sender , uint256 amount ) public", "body": "require ( BOOL_ ) ; require ( address ( _contract ) . balance >= amount * data . sell price ( ) ) ; _transfer ( sender , _contract , amount ) ; sender . transfer ( amount * data . sell price ( ) ) ;"}
{"comment": "only for demonstrate test version .", "function": "function set angel date ( uint256 _time ) public only owner { angel_sale_start = _time ; }", "signature": "function set angel date ( uint256 _time ) public only owner", "body": "angel_sale_start = _time ;"}
{"comment": "unfreeze the account .", "function": "function unfreeze ( address [ ] _accounts ) public only owner or manager { require ( phase_i != phase_not_started && phase_i != phase_finished , STR_ ) ; uint i ; for ( i = NUM_ ; i < _accounts . length ; i ++ ) { require ( _accounts [ i ] != address ( NUM_ ) , STR_ ) ; require ( _accounts [ i ] != base_wallet , STR_ ) ; } for ( i = NUM_ ; i < _accounts . length ; i ++ ) { token . unfreeze ( _accounts [ i ] ) ; } }", "signature": "function unfreeze ( address [ ] _accounts ) public only owner or manager", "body": "require ( phase_i != phase_not_started && phase_i != phase_finished , STR_ ) ; uint i ; for ( i = NUM_ ; i < _accounts . length ; i ++ ) { require ( _accounts [ i ] != address ( NUM_ ) , STR_ ) ; require ( _accounts [ i ] != base_wallet , STR_ ) ; } for ( i = NUM_ ; i < _accounts . length ; i ++ ) { token . unfreeze ( _accounts [ i ] ) ; }"}
{"comment": "bulk mint tokens ( same amount ) .", "function": "function bulk token mint ( address [ ] beneficiaries , uint256 amount ) only owner external { for ( uint32 i = NUM_ ; i < beneficiaries . length ; i ++ ) { require ( token . mint ( beneficiaries [ i ] , amount ) ) ; } }", "signature": "function bulk token mint ( address [ ] beneficiaries , uint256 amount ) only owner external", "body": "for ( uint32 i = NUM_ ; i < beneficiaries . length ; i ++ ) { require ( token . mint ( beneficiaries [ i ] , amount ) ) ; }"}
{"comment": "users send ether to this contract will be revert .", "function": "function ( ) public payable { revert ( ) ; }", "signature": "function ( ) public payable", "body": "revert ( ) ;"}
{"comment": "transfer tokens from other address .", "function": "function transfer from ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( _value <= allowance [ _from ] [ msg . sender ] ) ; allowance [ _from ] [ msg . sender ] -= _value ; _transfer ( _from , _to , _value ) ; return BOOL_ ; }", "signature": "function transfer from ( address _from , address _to , uint256 _value ) public returns ( bool success )", "body": "require ( _value <= allowance [ _from ] [ msg . sender ] ) ; allowance [ _from ] [ msg . sender ] -= _value ; _transfer ( _from , _to , _value ) ; return BOOL_ ;"}
{"comment": "checks if a give address currently have transferapproval for a particular narco .", "function": "function _approved for ( address _claimant , uint256 _token id ) internal view returns ( bool ) { return narco index to approved [ _token id ] == _claimant ; }", "signature": "function _approved for ( address _claimant , uint256 _token id ) internal view returns ( bool )", "body": "return narco index to approved [ _token id ] == _claimant ;"}
{"comment": "add an address to an exist id .", "function": "function add address to account ( address _new address , address _sender ) external only account registry logic non zero ( _new address ) { require ( ! address belongs to account ( _new address ) ) ; account by address [ _new address ] = account id for address ( _sender ) ; }", "signature": "function add address to account ( address _new address , address _sender ) external only account registry logic non zero ( _new address )", "body": "require ( ! address belongs to account ( _new address ) ) ; account by address [ _new address ] = account id for address ( _sender ) ;"}
{"comment": "function to stop mint new tokens .", "function": "function finish minting ( ) public only owner can mint returns ( bool ) { minting finished = BOOL_ ; emit mint finished ( ) ; return BOOL_ ; }", "signature": "function finish minting ( ) public only owner can mint returns ( bool )", "body": "minting finished = BOOL_ ; emit mint finished ( ) ; return BOOL_ ;"}
{"comment": "check if job exist .", "function": "modifier job exists ( uint256 _job id ) { require ( _job id < num jobs ) ; _ ; }", "signature": "modifier job exists ( uint256 _job id )", "body": "require ( _job id < num jobs ) ; _ ;"}
{"comment": "deploy artcoin consortium contract .", "function": "function deploy consortium ( address consortium ) only finalized sale non zero address ( consortium ) only ( operations ) public { consortium placeholder . change controller ( consortium ) ; }", "signature": "function deploy consortium ( address consortium ) only finalized sale non zero address ( consortium ) only ( operations ) public", "body": "consortium placeholder . change controller ( consortium ) ;"}
{"comment": "get the order 's balance of eth for account customer .", "function": "function order eth of ( address customer ) public view returns ( uint256 balance ) { return orders [ customer ] [ STR_ ] ; }", "signature": "function order eth of ( address customer ) public view returns ( uint256 balance )", "body": "return orders [ customer ] [ STR_ ] ;"}
{"comment": "add a grant for tokens with a vest schedule .", "function": "function add vesting grant ( address _receiver , uint256 _amount , uint256 _time to cliff , uint256 _vesting duration ) internal { require ( vesting holders [ _receiver ] == address ( NUM_ ) ) ; token vesting holder = new token vesting ( _receiver , grants start timestamp , _time to cliff , _vesting duration , BOOL_ ) ; vesting holders [ _receiver ] = holder ; holder . transfer ownership ( bank multisig ) ; token . transfer ( holder , _amount ) ; }", "signature": "function add vesting grant ( address _receiver , uint256 _amount , uint256 _time to cliff , uint256 _vesting duration ) internal", "body": "require ( vesting holders [ _receiver ] == address ( NUM_ ) ) ; token vesting holder = new token vesting ( _receiver , grants start timestamp , _time to cliff , _vesting duration , BOOL_ ) ; vesting holders [ _receiver ] = holder ; holder . transfer ownership ( bank multisig ) ; token . transfer ( holder , _amount ) ;"}
{"comment": "function that be call when a user or another contract want to transfer fund .", "function": "function transfer ( address _to , uint _value , bytes _data ) public when not paused returns ( bool ) { require ( _to != NUM_ ) ; if ( _to . is contract ( ) ) { return transfer to contract ( _to , _value , _data ) ; } else { return transfer to address ( _to , _value , _data ) ; } }", "signature": "function transfer ( address _to , uint _value , bytes _data ) public when not paused returns ( bool )", "body": "require ( _to != NUM_ ) ; if ( _to . is contract ( ) ) { return transfer to contract ( _to , _value , _data ) ; } else { return transfer to address ( _to , _value , _data ) ; }"}
{"comment": "external function to mint a new token .", "function": "function mint ( address _to , uint256 _id ) external only manager { _mint ( _to , _id ) ; }", "signature": "function mint ( address _to , uint256 _id ) external only manager", "body": "_mint ( _to , _id ) ;"}
{"comment": "function to enable token transfer .", "function": "function freeze ( ) external only owner { tokens are frozen = BOOL_ ; frosted ( now ) ; }", "signature": "function freeze ( ) external only owner", "body": "tokens are frozen = BOOL_ ; frosted ( now ) ;"}
{"comment": "return ubetcheck information by supply beneficiary adddress .", "function": "function get ubet check ( address _address ) public returns ( string , string , string , string , uint256 , string , string ) { return ( ubet checks [ _address ] . account number , ubet checks [ _address ] . routing number , ubet checks [ _address ] . institution , ubet checks [ _address ] . full name , ubet checks [ _address ] . amount , ubet checks [ _address ] . check file path , ubet checks [ _address ] . digital check finger print ) ; }", "signature": "function get ubet check ( address _address ) public returns ( string , string , string , string , uint256 , string , string )", "body": "return ( ubet checks [ _address ] . account number , ubet checks [ _address ] . routing number , ubet checks [ _address ] . institution , ubet checks [ _address ] . full name , ubet checks [ _address ] . amount , ubet checks [ _address ] . check file path , ubet checks [ _address ] . digital check finger print ) ;"}
{"comment": "approve the passed address to spend the specified amount of tokens on behalf of msg . sender .", "function": "function approve ( address _spender , uint256 _value ) public returns ( bool ) { allowed [ msg . sender ] [ _spender ] = _value ; approval ( msg . sender , _spender , _value ) ; return BOOL_ ; }", "signature": "function approve ( address _spender , uint256 _value ) public returns ( bool )", "body": "allowed [ msg . sender ] [ _spender ] = _value ; approval ( msg . sender , _spender , _value ) ; return BOOL_ ;"}
{"comment": "sets approval spender to transfer ownership of token .", "function": "function approve ( address _spender , uint256 _value ) public returns ( bool success ) { if ( _value != NUM_ ) { return BOOL_ ; } else if ( _spender == NUM_ ) { return BOOL_ ; } else if ( balances [ msg . sender ] == NUM_ ) { return BOOL_ ; } approvals [ msg . sender ] [ _spender ] = NUM_ ; approval ( msg . sender , _spender , NUM_ ) ; token event lib . _approval ( msg . sender , _spender ) ; return BOOL_ ; }", "signature": "function approve ( address _spender , uint256 _value ) public returns ( bool success )", "body": "if ( _value != NUM_ ) { return BOOL_ ; } else if ( _spender == NUM_ ) { return BOOL_ ; } else if ( balances [ msg . sender ] == NUM_ ) { return BOOL_ ; } approvals [ msg . sender ] [ _spender ] = NUM_ ; approval ( msg . sender , _spender , NUM_ ) ; token event lib . _approval ( msg . sender , _spender ) ; return BOOL_ ;"}
{"comment": "actually buy in if this be necessary ( can be manually call after allocateeth if necessary ) .", "function": "function token bankroll buy in ( ) is an owner public { _token bankroll buy in ( NUM_ ) ; _token bankroll buy in ( NUM_ ) ; _token bankroll buy in ( NUM_ ) ; _token bankroll buy in ( NUM_ ) ; _token bankroll buy in ( NUM_ ) ; _token bankroll buy in ( NUM_ ) ; _token bankroll buy in ( NUM_ ) ; }", "signature": "function token bankroll buy in ( ) is an owner public", "body": "_token bankroll buy in ( NUM_ ) ; _token bankroll buy in ( NUM_ ) ; _token bankroll buy in ( NUM_ ) ; _token bankroll buy in ( NUM_ ) ; _token bankroll buy in ( NUM_ ) ; _token bankroll buy in ( NUM_ ) ; _token bankroll buy in ( NUM_ ) ;"}
{"comment": "presale holders methods : set , remove , be .", "function": "function add presale holder ( address _beneficiary ) public { require ( privilege address [ msg . sender ] ) ; presale holder [ _beneficiary ] = BOOL_ ; presale holder unlock date [ _beneficiary ] = now + NUM_ years ; }", "signature": "function add presale holder ( address _beneficiary ) public", "body": "require ( privilege address [ msg . sender ] ) ; presale holder [ _beneficiary ] = BOOL_ ; presale holder unlock date [ _beneficiary ] = now + NUM_ years ;"}
{"comment": "check interest due + balance .", "function": "function check withdrawal amount ( ) public view returns ( uint ) { address _owner = msg . sender ; uint _interest ; if ( is start ) { if ( block height start > deposit blockheight [ _owner ] ) { _interest = ( ( account balance [ _owner ] * ( block . number - block height start ) / NUM_ ) ) ; } else { _interest = ( ( account balance [ _owner ] * ( block . number - deposit blockheight [ _owner ] ) / NUM_ ) ) ; } return ( account balance [ _owner ] + _interest ) ; } else { return account balance [ _owner ] ; } }", "signature": "function check withdrawal amount ( ) public view returns ( uint )", "body": "address _owner = msg . sender ; uint _interest ; if ( is start ) { if ( block height start > deposit blockheight [ _owner ] ) { _interest = ( ( account balance [ _owner ] * ( block . number - block height start ) / NUM_ ) ) ; } else { _interest = ( ( account balance [ _owner ] * ( block . number - deposit blockheight [ _owner ] ) / NUM_ ) ) ; } return ( account balance [ _owner ] + _interest ) ; } else { return account balance [ _owner ] ; }"}
{"comment": "function to set the max buy limit in 1 transaction can only be call from owner wallet .", "function": "function set max buy limit ( uint256 maxlimit ) public returns ( bool ) { require ( msg . sender == wallet owner ) ; max buy limit = maxlimit * NUM_ * * NUM_ ; }", "signature": "function set max buy limit ( uint256 maxlimit ) public returns ( bool )", "body": "require ( msg . sender == wallet owner ) ; max buy limit = maxlimit * NUM_ * * NUM_ ;"}
{"comment": "check if the contract relationship look good .", "function": "function is finalizer sane ( ) public constant returns ( bool sane ) { return finalize agent . is sane ( ) ; }", "signature": "function is finalizer sane ( ) public constant returns ( bool sane )", "body": "return finalize agent . is sane ( ) ;"}
{"comment": "get information pertain to the current game .", "function": "function get current game ( ) public view returns ( uint , uint , uint , uint , uint , uint , state , bool [ ] , uint [ ] ) { uint _remaining tickets = game . rules . slots - game . tickets sold ; bool [ ] memory _tickets = new bool [ ] ( game . rules . slots ) ; uint [ ] memory _user tickets = get my tickets ( ) ; for ( uint i = NUM_ ; i < game . rules . slots ; i ++ ) _tickets [ i ] = game . tickets [ i + NUM_ ] == address ( NUM_ ) ; return ( game . id , game . rules . jackpot , game . rules . slots , _remaining tickets , game . rules . ticket price , game . rules . max tickets per , state , _tickets , _user tickets ) ; }", "signature": "function get current game ( ) public view returns ( uint , uint , uint , uint , uint , uint , state , bool [ ] , uint [ ] )", "body": "uint _remaining tickets = game . rules . slots - game . tickets sold ; bool [ ] memory _tickets = new bool [ ] ( game . rules . slots ) ; uint [ ] memory _user tickets = get my tickets ( ) ; for ( uint i = NUM_ ; i < game . rules . slots ; i ++ ) _tickets [ i ] = game . tickets [ i + NUM_ ] == address ( NUM_ ) ; return ( game . id , game . rules . jackpot , game . rules . slots , _remaining tickets , game . rules . ticket price , game . rules . max tickets per , state , _tickets , _user tickets ) ;"}
{"comment": "integer division of two signed integers , truncate the quotient .", "function": "function div ( int256 a , int256 b ) internal pure returns ( int256 ) { int256 int256_min = int256 ( ( uint256 ( NUM_ ) << NUM_ ) ) ; assert ( a != int256_min || b != - NUM_ ) ; return a / b ; }", "signature": "function div ( int256 a , int256 b ) internal pure returns ( int256 )", "body": "int256 int256_min = int256 ( ( uint256 ( NUM_ ) << NUM_ ) ) ; assert ( a != int256_min || b != - NUM_ ) ; return a / b ;"}
{"comment": "transfer the balance from owner 's account to another account .", "function": "function transfer ( address _to , uint256 _amount ) returns ( bool success ) { if ( balance of [ msg . sender ] >= _amount && _amount > NUM_ ) { balance of [ msg . sender ] -= uint112 ( _amount ) ; balance of [ _to ] = _amount . add ( balance of [ _to ] ) . to uint112 ( ) ; sold token = _amount . add ( sold token ) . to uint112 ( ) ; transfer ( msg . sender , _to , _amount ) ; return BOOL_ ; } else { return BOOL_ ; } }", "signature": "function transfer ( address _to , uint256 _amount ) returns ( bool success )", "body": "if ( balance of [ msg . sender ] >= _amount && _amount > NUM_ ) { balance of [ msg . sender ] -= uint112 ( _amount ) ; balance of [ _to ] = _amount . add ( balance of [ _to ] ) . to uint112 ( ) ; sold token = _amount . add ( sold token ) . to uint112 ( ) ; transfer ( msg . sender , _to , _amount ) ; return BOOL_ ; } else { return BOOL_ ; }"}
{"comment": "return carddetailslist array .", "function": "function get cards details ( ) public view returns ( uint8 [ ] ) { uint8 [ ] memory result = new uint8 [ ] ( card details list . length ) ; uint8 counter = NUM_ ; for ( uint8 i = NUM_ ; i < card details list . length ; i ++ ) { result [ counter ] = i ; counter ++ ; } return result ; }", "signature": "function get cards details ( ) public view returns ( uint8 [ ] )", "body": "uint8 [ ] memory result = new uint8 [ ] ( card details list . length ) ; uint8 counter = NUM_ ; for ( uint8 i = NUM_ ; i < card details list . length ; i ++ ) { result [ counter ] = i ; counter ++ ; } return result ;"}
{"comment": "returns the number of elements in the list .", "function": "function size of ( linked list storage self ) public view returns ( uint256 num elements ) { bool exists ; uint256 i ; ( exists , i ) = get adjacent ( self , head , next ) ; while ( i != head ) { ( exists , i ) = get adjacent ( self , i , next ) ; num elements ++ ; } return ; }", "signature": "function size of ( linked list storage self ) public view returns ( uint256 num elements )", "body": "bool exists ; uint256 i ; ( exists , i ) = get adjacent ( self , head , next ) ; while ( i != head ) { ( exists , i ) = get adjacent ( self , i , next ) ; num elements ++ ; } return ;"}
{"comment": "adds list of address to whitelist .", "function": "function add many to whitelist ( address [ ] _beneficiaries ) external only owner { for ( uint256 i = NUM_ ; i < _beneficiaries . length ; i ++ ) { whitelist [ _beneficiaries [ i ] ] = BOOL_ ; } }", "signature": "function add many to whitelist ( address [ ] _beneficiaries ) external only owner", "body": "for ( uint256 i = NUM_ ; i < _beneficiaries . length ; i ++ ) { whitelist [ _beneficiaries [ i ] ] = BOOL_ ; }"}
{"comment": "this be public rather than external so we can call super . unpause .", "function": "function unpause ( ) public only manager { super . unpause ( ) ; }", "signature": "function unpause ( ) public only manager", "body": "super . unpause ( ) ;"}
{"comment": "wolk genesis event only accessible by contract owner .", "function": "function wolk genesis ( uint256 _start block , uint256 _end block , address _wolk wallet ) only owner returns ( bool success ) { require ( ( total tokens < NUM_ ) && ( ! settlers [ msg . sender ] ) && ( _end block > _start block ) ) ; start_block = _start block ; end_block = _end block ; multisig wallet = _wolk wallet ; settlers [ msg . sender ] = BOOL_ ; return BOOL_ ; }", "signature": "function wolk genesis ( uint256 _start block , uint256 _end block , address _wolk wallet ) only owner returns ( bool success )", "body": "require ( ( total tokens < NUM_ ) && ( ! settlers [ msg . sender ] ) && ( _end block > _start block ) ) ; start_block = _start block ; end_block = _end block ; multisig wallet = _wolk wallet ; settlers [ msg . sender ] = BOOL_ ; return BOOL_ ;"}
{"comment": "public constant function .", "function": "function get bid ( bytes32 _bid id ) constant external returns ( uint , uint , uint , uint , uint , address , bytes32 , bytes32 , address , bytes32 , bytes32 ) { bid storage bid = bids [ _bid id ] ; return ( uint ( bid states [ _bid id ] ) , bid . target , bid . timeout , bid . amount , bid . accepted time , bid . advertiser , bid . ad unit , bid . advertiser confirmation , bid . publisher , bid . ad slot , bid . publisher confirmation ) ; }", "signature": "function get bid ( bytes32 _bid id ) constant external returns ( uint , uint , uint , uint , uint , address , bytes32 , bytes32 , address , bytes32 , bytes32 )", "body": "bid storage bid = bids [ _bid id ] ; return ( uint ( bid states [ _bid id ] ) , bid . target , bid . timeout , bid . amount , bid . accepted time , bid . advertiser , bid . ad unit , bid . advertiser confirmation , bid . publisher , bid . ad slot , bid . publisher confirmation ) ;"}
{"comment": "perform an atomic swap between two token contract .", "function": "function relocate ( ) external { require ( relocation active == BOOL_ ) ; relocation token new stt = relocation token ( new token contract address ) ; uint256 balance = balances [ msg . sender ] ; balances [ msg . sender ] = NUM_ ; require ( new stt . recieve relocation ( msg . sender , balance ) ) ; }", "signature": "function relocate ( ) external", "body": "require ( relocation active == BOOL_ ) ; relocation token new stt = relocation token ( new token contract address ) ; uint256 balance = balances [ msg . sender ] ; balances [ msg . sender ] = NUM_ ; require ( new stt . recieve relocation ( msg . sender , balance ) ) ;"}
{"comment": "check if sale contract have enough tokens on it account balance to reward all possible participations within sale period .", "function": "function power up contract ( ) external only owner { require ( ! contract up ) ; require ( token . balance of ( this ) >= tokens available for sale ) ; contract up = BOOL_ ; }", "signature": "function power up contract ( ) external only owner", "body": "require ( ! contract up ) ; require ( token . balance of ( this ) >= tokens available for sale ) ; contract up = BOOL_ ;"}
{"comment": "override function use cantransfer on the sender address .", "function": "function transfer ( address _to , uint256 _value ) only valid destination ( _to ) can transfer ( msg . sender , _value ) public returns ( bool success ) { return super . transfer ( _to , _value ) ; }", "signature": "function transfer ( address _to , uint256 _value ) only valid destination ( _to ) can transfer ( msg . sender , _value ) public returns ( bool success )", "body": "return super . transfer ( _to , _value ) ;"}
{"comment": "add whitelisted address to the presale .", "function": "function whitelist address ( address address to whitelist , uint256 cap amount ) external owner exists ( msg . sender ) { assert ( ! whitelisted addresses [ address to whitelist ] . bona fide ) ; whitelisted addresses [ address to whitelist ] . bona fide = BOOL_ ; whitelisted addresses [ address to whitelist ] . cap for amount raised = cap amount ; }", "signature": "function whitelist address ( address address to whitelist , uint256 cap amount ) external owner exists ( msg . sender )", "body": "assert ( ! whitelisted addresses [ address to whitelist ] . bona fide ) ; whitelisted addresses [ address to whitelist ] . bona fide = BOOL_ ; whitelisted addresses [ address to whitelist ] . cap for amount raised = cap amount ;"}
{"comment": "allows user to create tokens if token creation be still go and cap be not reach .", "function": "function fund ( ) public payable returns ( bool ) { uint investment = NUM_ ; uint token count = NUM_ ; while ( ( msg . value - investment ) >= buy_value ( ) ) { investment += buy_value ( ) ; total supply += NUM_ ; token count ++ ; } update_prices ( ) ; balances [ msg . sender ] += token count ; issuance ( msg . sender , token count ) ; if ( msg . value > investment ) { msg . sender . transfer ( msg . value - investment ) ; } return BOOL_ ; }", "signature": "function fund ( ) public payable returns ( bool )", "body": "uint investment = NUM_ ; uint token count = NUM_ ; while ( ( msg . value - investment ) >= buy_value ( ) ) { investment += buy_value ( ) ; total supply += NUM_ ; token count ++ ; } update_prices ( ) ; balances [ msg . sender ] += token count ; issuance ( msg . sender , token count ) ; if ( msg . value > investment ) { msg . sender . transfer ( msg . value - investment ) ; } return BOOL_ ;"}
{"comment": "finalizes the ability to use the controller and destruct it .", "function": "function finalize ( ) public only owner { if ( finalize type == STR_ ) { token . transfer ( token . allocation addresses types ( finalize transfer address type ) , token . balance of ( this ) ) ; } else if ( finalize type == STR_ ) { token . burn ( token . balance of ( this ) ) ; } require ( unlock all allocation addresses ( ) ) ; remove ownership ( ) ; is finalized = BOOL_ ; emit finalized ( ) ; }", "signature": "function finalize ( ) public only owner", "body": "if ( finalize type == STR_ ) { token . transfer ( token . allocation addresses types ( finalize transfer address type ) , token . balance of ( this ) ) ; } else if ( finalize type == STR_ ) { token . burn ( token . balance of ( this ) ) ; } require ( unlock all allocation addresses ( ) ) ; remove ownership ( ) ; is finalized = BOOL_ ; emit finalized ( ) ;"}
{"comment": "reads application information from the script registry , and set up permissions for the new instance 's various function .", "function": "function set implementation ( bytes32 _new_exec_id , bytes32 _app_name , address _provider , bytes32 _registry_id ) internal returns ( address index , bytes32 version ) { index = get index ( _registry_id ) ; require ( index != address ( NUM_ ) && index != address ( this ) , STR_ ) ; version = registry interface ( index ) . get latest version ( address ( this ) , _registry_id , _provider , _app_name ) ; require ( version != bytes32 ( NUM_ ) , STR_ ) ; bytes4 [ ] memory selectors ; address [ ] memory implementations ; ( index , selectors , implementations ) = registry interface ( index ) . get version implementation ( address ( this ) , _registry_id , _provider , _app_name , version ) ; require ( index != address ( NUM_ ) , STR_ ) ; require ( selectors . length == implementations . length && selectors . length != NUM_ , STR_ ) ; bytes32 seed = app_idx_addr ; put ( _new_exec_id , seed , bytes32 ( index ) ) ; for ( uint i = NUM_ ; i < selectors . length ; i ++ ) { require ( selectors [ i ] != NUM_ && implementations [ i ] != NUM_ , STR_ ) ; seed = keccak256 ( selectors [ i ] , STR_ ) ; put ( _new_exec_id , seed , bytes32 ( implementations [ i ] ) ) ; } return ( index , version ) ; }", "signature": "function set implementation ( bytes32 _new_exec_id , bytes32 _app_name , address _provider , bytes32 _registry_id ) internal returns ( address index , bytes32 version )", "body": "index = get index ( _registry_id ) ; require ( index != address ( NUM_ ) && index != address ( this ) , STR_ ) ; version = registry interface ( index ) . get latest version ( address ( this ) , _registry_id , _provider , _app_name ) ; require ( version != bytes32 ( NUM_ ) , STR_ ) ; bytes4 [ ] memory selectors ; address [ ] memory implementations ; ( index , selectors , implementations ) = registry interface ( index ) . get version implementation ( address ( this ) , _registry_id , _provider , _app_name , version ) ; require ( index != address ( NUM_ ) , STR_ ) ; require ( selectors . length == implementations . length && selectors . length != NUM_ , STR_ ) ; bytes32 seed = app_idx_addr ; put ( _new_exec_id , seed , bytes32 ( index ) ) ; for ( uint i = NUM_ ; i < selectors . length ; i ++ ) { require ( selectors [ i ] != NUM_ && implementations [ i ] != NUM_ , STR_ ) ; seed = keccak256 ( selectors [ i ] , STR_ ) ; put ( _new_exec_id , seed , bytes32 ( implementations [ i ] ) ) ; } return ( index , version ) ;"}
{"comment": "calculates the amount that have already vest but have n't be release yet .", "function": "function releasable amount ( erc20 basic token ) public view returns ( uint256 ) { return vested amount ( token ) . sub ( released [ token ] ) ; }", "signature": "function releasable amount ( erc20 basic token ) public view returns ( uint256 )", "body": "return vested amount ( token ) . sub ( released [ token ] ) ;"}
{"comment": "contract owner or multisig can withdraw parsecs anytime in case of emergency .", "function": "function emergency withdraw parsecs ( uint256 value ) external only owner or multisig { require ( value > NUM_ ) ; require ( value <= parsec token . balance of ( this ) ) ; parsec token . transfer ( msg . sender , value ) ; }", "signature": "function emergency withdraw parsecs ( uint256 value ) external only owner or multisig", "body": "require ( value > NUM_ ) ; require ( value <= parsec token . balance of ( this ) ) ; parsec token . transfer ( msg . sender , value ) ;"}
{"comment": "get balance of ident .", "function": "function balance of ( bytes32 _owner ) constant returns ( uint256 ) { return balances [ _owner ] ; }", "signature": "function balance of ( bytes32 _owner ) constant returns ( uint256 )", "body": "return balances [ _owner ] ;"}
{"comment": "sets calculate proposalidx a vote winner .", "function": "function set voting winner ( address voting address ) public only owner { require ( votings winners [ voting address ] == - NUM_ ) ; uint256 winner idx ; bytes32 winner ; uint256 winner weight ; ( winner idx , winner , winner weight ) = ukttoken voting ( voting address ) . get winner ( ) ; bool is finalized validly = winner idx > NUM_ ; ukttoken voting ( voting address ) . finalize ( is finalized validly ) ; emit voting finalized ( voting address , is finalized validly ) ; votings winners [ voting address ] = int256 ( winner idx ) ; emit winner setted ( voting address , winner idx , winner , winner weight ) ; }", "signature": "function set voting winner ( address voting address ) public only owner", "body": "require ( votings winners [ voting address ] == - NUM_ ) ; uint256 winner idx ; bytes32 winner ; uint256 winner weight ; ( winner idx , winner , winner weight ) = ukttoken voting ( voting address ) . get winner ( ) ; bool is finalized validly = winner idx > NUM_ ; ukttoken voting ( voting address ) . finalize ( is finalized validly ) ; emit voting finalized ( voting address , is finalized validly ) ; votings winners [ voting address ] = int256 ( winner idx ) ; emit winner setted ( voting address , winner idx , winner , winner weight ) ;"}
{"comment": "immediately mint _amount tokens to the _beneficiary .", "function": "function allocate tokens ( address _beneficiary , uint256 _amount ) only owner public { require ( ! is finalized ) ; uint256 _wei amount = _amount . div ( rate ) ; wei raised = wei raised . add ( _wei amount ) ; token . mint ( _beneficiary , _amount ) ; uint256 _owner tokens = _wei amount . mul ( owner rate ) ; token . mint ( token wallet , _owner tokens ) ; token purchase ( msg . sender , _beneficiary , _wei amount , _amount ) ; }", "signature": "function allocate tokens ( address _beneficiary , uint256 _amount ) only owner public", "body": "require ( ! is finalized ) ; uint256 _wei amount = _amount . div ( rate ) ; wei raised = wei raised . add ( _wei amount ) ; token . mint ( _beneficiary , _amount ) ; uint256 _owner tokens = _wei amount . mul ( owner rate ) ; token . mint ( token wallet , _owner tokens ) ; token purchase ( msg . sender , _beneficiary , _wei amount , _amount ) ;"}
{"comment": "send value token to to from from .", "function": "function transfer from ( address from , address to , uint256 value ) public can tradable returns ( bool success ) { require ( allowed [ from ] [ msg . sender ] >= value && balances [ from ] >= value && value > NUM_ ) ; balances [ from ] = balances [ from ] . sub ( value ) ; balances [ to ] = balances [ to ] . add ( value ) ; allowed [ from ] [ msg . sender ] = allowed [ from ] [ msg . sender ] . sub ( value ) ; transfer ( from , to , value ) ; return BOOL_ ; }", "signature": "function transfer from ( address from , address to , uint256 value ) public can tradable returns ( bool success )", "body": "require ( allowed [ from ] [ msg . sender ] >= value && balances [ from ] >= value && value > NUM_ ) ; balances [ from ] = balances [ from ] . sub ( value ) ; balances [ to ] = balances [ to ] . add ( value ) ; allowed [ from ] [ msg . sender ] = allowed [ from ] [ msg . sender ] . sub ( value ) ; transfer ( from , to , value ) ; return BOOL_ ;"}
{"comment": "return the window number for give timestamp .", "function": "function window of ( uint256 timestamp ) view public returns ( uint256 ) { return ( start timestamp < timestamp ) ? timestamp . sub ( start timestamp ) . div ( window length ) : NUM_ ; }", "signature": "function window of ( uint256 timestamp ) view public returns ( uint256 )", "body": "return ( start timestamp < timestamp ) ? timestamp . sub ( start timestamp ) . div ( window length ) : NUM_ ;"}
{"comment": "have to have in order to use array rather than map .", "function": "function add new token to ( address _to , uint256 _token id ) internal { super . add new token to ( _to , _token id ) ; uint256 length = owned tokens [ _to ] . length ; require ( length == uint32 ( length ) ) ; owned tokens [ _to ] . push ( uint40 ( _token id ) ) ; owned tokens index . push ( uint32 ( length ) ) ; }", "signature": "function add new token to ( address _to , uint256 _token id ) internal", "body": "super . add new token to ( _to , _token id ) ; uint256 length = owned tokens [ _to ] . length ; require ( length == uint32 ( length ) ) ; owned tokens [ _to ] . push ( uint40 ( _token id ) ) ; owned tokens index . push ( uint32 ( length ) ) ;"}
{"comment": "for the trustee to issue an offer of new tokens to a holder .", "function": "function issue ( address _addr , uint _amount ) public can enter only trustee returns ( bool ) { assert ( total supply + _amount < maxtokens ) ; join ( _addr ) ; holder holder = holders [ _addr ] ; holder . offer amount = _amount ; holder . offer expiry = uint40 ( now + NUM_ days ) ; issue offer ( _addr ) ; return BOOL_ ; }", "signature": "function issue ( address _addr , uint _amount ) public can enter only trustee returns ( bool )", "body": "assert ( total supply + _amount < maxtokens ) ; join ( _addr ) ; holder holder = holders [ _addr ] ; holder . offer amount = _amount ; holder . offer expiry = uint40 ( now + NUM_ days ) ; issue offer ( _addr ) ; return BOOL_ ;"}
{"comment": "self destruct contract .", "function": "function self destruct ( ) only etheraffle external { require ( now - upgraded > weekdur * NUM_ ) ; selfdestruct ( eth relief ) ; }", "signature": "function self destruct ( ) only etheraffle external", "body": "require ( now - upgraded > weekdur * NUM_ ) ; selfdestruct ( eth relief ) ;"}
{"comment": "return address available allocation .", "function": "function check available tokens ( address _recipient ) public view returns ( uint256 ) { require ( buyers [ _recipient ] ) ; uint256 _available tokens = NUM_ ; if ( now >= step1 ) { _available tokens = _available tokens . add ( allocations1 [ _recipient ] ) ; } if ( now >= step2 ) { _available tokens = _available tokens . add ( allocations2 [ _recipient ] ) ; } if ( now >= step3 ) { _available tokens = _available tokens . add ( allocations3 [ _recipient ] ) ; } return _available tokens ; }", "signature": "function check available tokens ( address _recipient ) public view returns ( uint256 )", "body": "require ( buyers [ _recipient ] ) ; uint256 _available tokens = NUM_ ; if ( now >= step1 ) { _available tokens = _available tokens . add ( allocations1 [ _recipient ] ) ; } if ( now >= step2 ) { _available tokens = _available tokens . add ( allocations2 [ _recipient ] ) ; } if ( now >= step3 ) { _available tokens = _available tokens . add ( allocations3 [ _recipient ] ) ; } return _available tokens ;"}
{"comment": "load fund to the crowdsale for all investors .", "function": "function buy for everybody ( ) stop non owners in emergency public { if ( get state ( ) != state . funding ) { throw ; } if ( address ( crowdsale ) == NUM_ ) throw ; crowdsale . invest . value ( wei raised ) ( address ( this ) ) ; tokens bought = get token ( ) . balance of ( address ( this ) ) ; if ( tokens bought == NUM_ ) { throw ; } tokens boughts ( tokens bought ) ; }", "signature": "function buy for everybody ( ) stop non owners in emergency public", "body": "if ( get state ( ) != state . funding ) { throw ; } if ( address ( crowdsale ) == NUM_ ) throw ; crowdsale . invest . value ( wei raised ) ( address ( this ) ) ; tokens bought = get token ( ) . balance of ( address ( this ) ) ; if ( tokens bought == NUM_ ) { throw ; } tokens boughts ( tokens bought ) ;"}
{"comment": "total supply of tokens .", "function": "function total supply ( ) external view returns ( uint ) { uint256 total = ico_tokens . add ( platform_tokens ) . add ( company_tokens ) . add ( partner_tokens ) . add ( foundation_tokens ) ; return total . mul ( jiffys multiplier ) ; }", "signature": "function total supply ( ) external view returns ( uint )", "body": "uint256 total = ico_tokens . add ( platform_tokens ) . add ( company_tokens ) . add ( partner_tokens ) . add ( foundation_tokens ) ; return total . mul ( jiffys multiplier ) ;"}
{"comment": "assemble the give address bytecode .", "function": "function is contract ( address _addr ) internal view returns ( bool ) { uint length ; assembly { length : = extcodesize ( _addr ) } return ( length > NUM_ ) ; }", "signature": "function is contract ( address _addr ) internal view returns ( bool )", "body": "uint length ; assembly { length : = extcodesize ( _addr ) } return ( length > NUM_ ) ;"}
{"comment": "extend close time to a future time .", "function": "function extend closing time ( uint256 _extend to time ) public only owner only while open { closing time = _extend to time ; }", "signature": "function extend closing time ( uint256 _extend to time ) public only owner only while open", "body": "closing time = _extend to time ;"}
{"comment": "the contract owner can take away the ownership of any top level domain own by this contract .", "function": "function transfer domain ownership ( bytes32 _node , address _owner ) public only owner { registry . set owner ( _node , _owner ) ; }", "signature": "function transfer domain ownership ( bytes32 _node , address _owner ) public only owner", "body": "registry . set owner ( _node , _owner ) ;"}
{"comment": "time base on blocknumbers , assume a blocktime of 30 .", "function": "function ico denominator price ( ) public view returns ( uint256 ) { uint256 ico duration = safe sub ( now , funding start time ) ; uint256 denominator ; if ( ico duration < NUM_ ) { denominator = safe mul ( current price . denominator , NUM_ ) / NUM_ ; return denominator ; } else if ( ico duration < offer time ) { denominator = safe mul ( current price . denominator , NUM_ ) / NUM_ ; return denominator ; } else if ( now > funding end time ) { denominator = safe mul ( current price . denominator , NUM_ ) / NUM_ ; return denominator ; } else { denominator = safe mul ( current price . denominator , NUM_ ) / NUM_ ; return denominator ; } }", "signature": "function ico denominator price ( ) public view returns ( uint256 )", "body": "uint256 ico duration = safe sub ( now , funding start time ) ; uint256 denominator ; if ( ico duration < NUM_ ) { denominator = safe mul ( current price . denominator , NUM_ ) / NUM_ ; return denominator ; } else if ( ico duration < offer time ) { denominator = safe mul ( current price . denominator , NUM_ ) / NUM_ ; return denominator ; } else if ( now > funding end time ) { denominator = safe mul ( current price . denominator , NUM_ ) / NUM_ ; return denominator ; } else { denominator = safe mul ( current price . denominator , NUM_ ) / NUM_ ; return denominator ; }"}
{"comment": "end the round .", "function": "function end round ( f3 ddatasets . event returns memory _event data_ ) private returns ( f3 ddatasets . event returns ) { uint256 _r id = r id_ ; uint256 _win pid = round_ [ _r id ] . plyr ; uint256 _win tid = round_ [ _r id ] . team ; uint256 _pot = round_ [ _r id ] . pot ; uint256 _win = ( _pot . mul ( NUM_ ) ) / NUM_ ; uint256 _com = ( _pot / NUM_ ) ; uint256 _gen = ( _pot . mul ( pot split_ [ _win tid ] . gen ) ) / NUM_ ; uint256 _res = ( ( ( _pot . sub ( _win ) ) . sub ( _com ) ) . sub ( _gen ) ) ; uint256 _ppt = ( _gen . mul ( NUM_ ) ) / ( round_ [ _r id ] . keys ) ; uint256 _dust = _gen . sub ( ( _ppt . mul ( round_ [ _r id ] . keys ) ) / NUM_ ) ; if ( _dust > NUM_ ) { _gen = _gen . sub ( _dust ) ; _res = _res . add ( _dust ) ; } plyr_ [ _win pid ] . win = _win . add ( plyr_ [ _win pid ] . win ) ; share com . transfer ( ( _com / NUM_ ) ) ; admin . transfer ( ( _com / NUM_ ) ) ; round_ [ _r id ] . mask = _ppt . add ( round_ [ _r id ] . mask ) ; _event data_ . compressed data = _event data_ . compressed data + ( round_ [ _r id ] . end * NUM_ ) ; _event data_ . compressed ids = _event data_ . compressed ids + ( _win pid * NUM_ ) + ( _win tid * NUM_ ) ; _event data_ . winner addr = plyr_ [ _win pid ] . addr ; _event data_ . winner name = plyr_ [ _win pid ] . name ; _event data_ . amount won = _win ; _event data_ . gen amount = _gen ; _event data_ . p3 damount = NUM_ ; _event data_ . new pot = _res ; emit f3 devents . on end round ( _r id , plyr_ [ _win pid ] . addr , plyr_ [ _win pid ] . name , _win , _res ) ; r id_ ++ ; _r id ++ ; round_ [ _r id ] . strt = now ; round_ [ _r id ] . end = now . add ( rnd init_ ) . add ( rnd gap_ ) ; round_ [ _r id ] . pot = _res ; return ( _event data_ ) ; }", "signature": "function end round ( f3 ddatasets . event returns memory _event data_ ) private returns ( f3 ddatasets . event returns )", "body": "uint256 _r id = r id_ ; uint256 _win pid = round_ [ _r id ] . plyr ; uint256 _win tid = round_ [ _r id ] . team ; uint256 _pot = round_ [ _r id ] . pot ; uint256 _win = ( _pot . mul ( NUM_ ) ) / NUM_ ; uint256 _com = ( _pot / NUM_ ) ; uint256 _gen = ( _pot . mul ( pot split_ [ _win tid ] . gen ) ) / NUM_ ; uint256 _res = ( ( ( _pot . sub ( _win ) ) . sub ( _com ) ) . sub ( _gen ) ) ; uint256 _ppt = ( _gen . mul ( NUM_ ) ) / ( round_ [ _r id ] . keys ) ; uint256 _dust = _gen . sub ( ( _ppt . mul ( round_ [ _r id ] . keys ) ) / NUM_ ) ; if ( _dust > NUM_ ) { _gen = _gen . sub ( _dust ) ; _res = _res . add ( _dust ) ; } plyr_ [ _win pid ] . win = _win . add ( plyr_ [ _win pid ] . win ) ; share com . transfer ( ( _com / NUM_ ) ) ; admin . transfer ( ( _com / NUM_ ) ) ; round_ [ _r id ] . mask = _ppt . add ( round_ [ _r id ] . mask ) ; _event data_ . compressed data = _event data_ . compressed data + ( round_ [ _r id ] . end * NUM_ ) ; _event data_ . compressed ids = _event data_ . compressed ids + ( _win pid * NUM_ ) + ( _win tid * NUM_ ) ; _event data_ . winner addr = plyr_ [ _win pid ] . addr ; _event data_ . winner name = plyr_ [ _win pid ] . name ; _event data_ . amount won = _win ; _event data_ . gen amount = _gen ; _event data_ . p3 damount = NUM_ ; _event data_ . new pot = _res ; emit f3 devents . on end round ( _r id , plyr_ [ _win pid ] . addr , plyr_ [ _win pid ] . name , _win , _res ) ; r id_ ++ ; _r id ++ ; round_ [ _r id ] . strt = now ; round_ [ _r id ] . end = now . add ( rnd init_ ) . add ( rnd gap_ ) ; round_ [ _r id ] . pot = _res ; return ( _event data_ ) ;"}
{"comment": "send amount of this token to exchange .", "function": "function __exchanger callback ( address _target contract , address _exchanger , uint _amount ) public when configured only exchange returns ( bool success ) { require ( _target contract != address ( NUM_ ) ) ; if ( _amount > balances [ _exchanger ] ) { return BOOL_ ; } balances [ _exchanger ] = balances [ _exchanger ] . sub ( _amount ) ; exchanged with [ _target contract ] = exchanged with [ _target contract ] . add ( _amount ) ; exchanged by [ _exchanger ] = exchanged by [ _exchanger ] . add ( _amount ) ; return BOOL_ ; }", "signature": "function __exchanger callback ( address _target contract , address _exchanger , uint _amount ) public when configured only exchange returns ( bool success )", "body": "require ( _target contract != address ( NUM_ ) ) ; if ( _amount > balances [ _exchanger ] ) { return BOOL_ ; } balances [ _exchanger ] = balances [ _exchanger ] . sub ( _amount ) ; exchanged with [ _target contract ] = exchanged with [ _target contract ] . add ( _amount ) ; exchanged by [ _exchanger ] = exchanged by [ _exchanger ] . add ( _amount ) ; return BOOL_ ;"}
{"comment": "internal transfer , only can be call by this contract .", "function": "function _transfer ( address _from , address _to , uint _value ) internal { require ( _to != NUM_ ) ; require ( balance of [ _from ] >= _value ) ; require ( balance of [ _to ] + _value >= balance of [ _to ] ) ; uint previous balances = balance of [ _from ] + balance of [ _to ] ; balance of [ _from ] -= _value ; balance of [ _to ] += _value ; emit transfer ( _from , _to , _value ) ; assert ( balance of [ _from ] + balance of [ _to ] == previous balances ) ; }", "signature": "function _transfer ( address _from , address _to , uint _value ) internal", "body": "require ( _to != NUM_ ) ; require ( balance of [ _from ] >= _value ) ; require ( balance of [ _to ] + _value >= balance of [ _to ] ) ; uint previous balances = balance of [ _from ] + balance of [ _to ] ; balance of [ _from ] -= _value ; balance of [ _to ] += _value ; emit transfer ( _from , _to , _value ) ; assert ( balance of [ _from ] + balance of [ _to ] == previous balances ) ;"}
{"comment": "can be call only by admin .", "function": "function add reserve ( kyber reserve interface reserve , bool add ) public only admin { if ( add ) { require ( ! is reserve [ reserve ] ) ; reserves . push ( reserve ) ; is reserve [ reserve ] = BOOL_ ; add reserve to network ( reserve , BOOL_ ) ; } else { is reserve [ reserve ] = BOOL_ ; for ( uint i = NUM_ ; i < reserves . length ; i ++ ) { if ( reserves [ i ] == reserve ) { reserves [ i ] = reserves [ reserves . length - NUM_ ] ; reserves . length -- ; add reserve to network ( reserve , BOOL_ ) ; break ; } } } }", "signature": "function add reserve ( kyber reserve interface reserve , bool add ) public only admin", "body": "if ( add ) { require ( ! is reserve [ reserve ] ) ; reserves . push ( reserve ) ; is reserve [ reserve ] = BOOL_ ; add reserve to network ( reserve , BOOL_ ) ; } else { is reserve [ reserve ] = BOOL_ ; for ( uint i = NUM_ ; i < reserves . length ; i ++ ) { if ( reserves [ i ] == reserve ) { reserves [ i ] = reserves [ reserves . length - NUM_ ] ; reserves . length -- ; add reserve to network ( reserve , BOOL_ ) ; break ; } } }"}
{"comment": "this method be useful when we really need to know last transaction ts .", "function": "function parse json array and get first element as number ( string json ) internal returns ( uint ) { var json slice = json . to slice ( ) ; strings . slice memory first result ; json slice . split ( STR_ . to slice ( ) , first result ) ; var ts = first result . beyond ( STR_ . to slice ( ) ) . to string ( ) ; return parse int ( ts ) ; }", "signature": "function parse json array and get first element as number ( string json ) internal returns ( uint )", "body": "var json slice = json . to slice ( ) ; strings . slice memory first result ; json slice . split ( STR_ . to slice ( ) , first result ) ; var ts = first result . beyond ( STR_ . to slice ( ) ) . to string ( ) ; return parse int ( ts ) ;"}
{"comment": "return true if string _a end with string _b .", "function": "function string ends with ( string _a , string _b ) internal returns ( bool ) { bytes memory a = bytes ( _a ) ; bytes memory b = bytes ( _b ) ; if ( a . length < b . length ) { return BOOL_ ; } uint length_diff = a . length - b . length ; for ( uint i = NUM_ ; i < b . length ; i ++ ) if ( a [ i + length_diff ] != b [ i ] ) { return BOOL_ ; } return BOOL_ ; }", "signature": "function string ends with ( string _a , string _b ) internal returns ( bool )", "body": "bytes memory a = bytes ( _a ) ; bytes memory b = bytes ( _b ) ; if ( a . length < b . length ) { return BOOL_ ; } uint length_diff = a . length - b . length ; for ( uint i = NUM_ ; i < b . length ; i ++ ) if ( a [ i + length_diff ] != b [ i ] ) { return BOOL_ ; } return BOOL_ ;"}
{"comment": "convert all incoming ethereum to key .", "function": "function buy xid ( uint256 _aff code ) is activated ( ) is human ( ) is within limits ( msg . value ) public payable { pohmodatasets . event returns memory _event data_ = determine pid ( _event data_ ) ; uint256 _p id = p idx addr_ [ msg . sender ] ; if ( _aff code == NUM_ || _aff code == _p id ) { _aff code = plyr_ [ _p id ] . laff ; } else if ( _aff code != plyr_ [ _p id ] . laff ) { plyr_ [ _p id ] . laff = _aff code ; } buy core ( _p id , _aff code , _event data_ ) ; }", "signature": "function buy xid ( uint256 _aff code ) is activated ( ) is human ( ) is within limits ( msg . value ) public payable", "body": "pohmodatasets . event returns memory _event data_ = determine pid ( _event data_ ) ; uint256 _p id = p idx addr_ [ msg . sender ] ; if ( _aff code == NUM_ || _aff code == _p id ) { _aff code = plyr_ [ _p id ] . laff ; } else if ( _aff code != plyr_ [ _p id ] . laff ) { plyr_ [ _p id ] . laff = _aff code ; } buy core ( _p id , _aff code , _event data_ ) ;"}
{"comment": "this function will return only the winner 's hero id .", "function": "function get winner details ( uint _winner id ) public view returns ( uint256 ) { return ( winners [ _winner id ] ) ; }", "signature": "function get winner details ( uint _winner id ) public view returns ( uint256 )", "body": "return ( winners [ _winner id ] ) ;"}
{"comment": "returns the name of the current round in plain text .", "function": "function get token sale type ( ) external view returns ( string ) { return ( token sale == token sale type . round1 ) ? STR_ : STR_ ; }", "signature": "function get token sale type ( ) external view returns ( string )", "body": "return ( token sale == token sale type . round1 ) ? STR_ : STR_ ;"}
{"comment": "on chain verification of an ecdsa ethereum signature .", "function": "function signature is valid ( address signer , bytes32 order hash , uint8 v , bytes32 r , bytes32 s ) private constant returns ( bool ) { address recovered addr = ecrecover ( keccak256 ( STR_ ) ,v , r , s ); return recovered addr == signer }", "signature": "function signature is valid ( address signer , bytes32 order hash , uint8 v , bytes32 r , bytes32 s ) private constant returns ( bool )", "body": "address recovered addr = ecrecover ( keccak256 ( STR_ ) ,v , r , s ); return recovered addr == signer"}
{"comment": "throws if call by any account other than the minter .", "function": "modifier only minter ( ) { require ( minters [ msg . sender ] ) ; _ ; }", "signature": "modifier only minter ( )", "body": "require ( minters [ msg . sender ] ) ; _ ;"}
{"comment": "function to configure contract address .", "function": "function set token addresses ( address _spec uwallet , address _spec dwallet ) only owner public { require ( ! token addresses set ) ; require ( _spec dwallet != address ( NUM_ ) ) ; require ( _spec uwallet != address ( NUM_ ) ) ; require ( is contract ( _spec dwallet ) ) ; require ( is contract ( _spec uwallet ) ) ; spec uwallet = _spec uwallet ; spec dwallet = _spec dwallet ; token addresses set = BOOL_ ; }", "signature": "function set token addresses ( address _spec uwallet , address _spec dwallet ) only owner public", "body": "require ( ! token addresses set ) ; require ( _spec dwallet != address ( NUM_ ) ) ; require ( _spec uwallet != address ( NUM_ ) ) ; require ( is contract ( _spec dwallet ) ) ; require ( is contract ( _spec uwallet ) ) ; spec uwallet = _spec uwallet ; spec dwallet = _spec dwallet ; token addresses set = BOOL_ ;"}
{"comment": "lock the vault for the wallets .", "function": "function lock ( ) internal not locked only owner { locked at = block . timestamp ; time locks [ team reserve wallet ] = locked at . add ( team time lock ) ; time locks [ final reserve wallet ] = locked at . add ( final reserve time lock ) ; locked ( locked at ) ; }", "signature": "function lock ( ) internal not locked only owner", "body": "locked at = block . timestamp ; time locks [ team reserve wallet ] = locked at . add ( team time lock ) ; time locks [ final reserve wallet ] = locked at . add ( final reserve time lock ) ; locked ( locked at ) ;"}
{"comment": "override default function to allow only whitelisted address to participate in the fundraiser .", "function": "function handle tokens ( address _address , uint256 _tokens ) only whitelisted ( _address ) internal { return super . handle tokens ( _address , _tokens ) ; }", "signature": "function handle tokens ( address _address , uint256 _tokens ) only whitelisted ( _address ) internal", "body": "return super . handle tokens ( _address , _tokens ) ;"}
{"comment": "get current day spend for token .", "function": "function get current spend ( wallet main lib . wallet data storage self , address _token ) public view returns ( uint256 [ NUM_ ] ) { uint256 [ NUM_ ] memory cs ; cs [ NUM_ ] = self . current spend [ _token ] [ NUM_ ] ; cs [ NUM_ ] = self . current spend [ _token ] [ NUM_ ] ; return cs ; }", "signature": "function get current spend ( wallet main lib . wallet data storage self , address _token ) public view returns ( uint256 [ NUM_ ] )", "body": "uint256 [ NUM_ ] memory cs ; cs [ NUM_ ] = self . current spend [ _token ] [ NUM_ ] ; cs [ NUM_ ] = self . current spend [ _token ] [ NUM_ ] ; return cs ;"}
{"comment": "set standard daily limit .", "function": "function set daily limit ( uint256 _daily limit ) public only owner returns ( bool ) { standard daily limit = _daily limit ; emit set daily limit ( msg . sender , block . timestamp ) ; return BOOL_ ; }", "signature": "function set daily limit ( uint256 _daily limit ) public only owner returns ( bool )", "body": "standard daily limit = _daily limit ; emit set daily limit ( msg . sender , block . timestamp ) ; return BOOL_ ;"}
{"comment": "required for erc-721 compliance .", "function": "function name ( ) public pure returns ( string ) { return name ; }", "signature": "function name ( ) public pure returns ( string )", "body": "return name ;"}
{"comment": "checks if a hash have be sign by the whitelistadmin .", "function": "function check whitelisted ( bytes32 _raw hash , bytes _sig ) public view returns ( bool ) { bytes32 hash = _raw hash . to eth signed message hash ( ) ; return ! invalid hash [ _raw hash ] && whitelist admin == hash . recover ( _sig ) ; }", "signature": "function check whitelisted ( bytes32 _raw hash , bytes _sig ) public view returns ( bool )", "body": "bytes32 hash = _raw hash . to eth signed message hash ( ) ; return ! invalid hash [ _raw hash ] && whitelist admin == hash . recover ( _sig ) ;"}
{"comment": "startescrow favorcontract start an escrow contract and transfer the tokens into the contract .", "function": "function start favor escrow ( uint256 id , uint256 deadl , uint tokens ) public not locked returns ( address c4 ffavor contract addr ) { require ( balance of ( msg . sender ) >= tokens ) ; address new favor = new c4 fescrow ( address ( this ) , id , msg . sender , deadl , _arbitration percent ) ; escrow addresses . push ( new favor ) ; c4 fescrow contracts [ new favor ] = BOOL_ ; if ( ! transfer ( new favor , tokens ) ) revert ( ) ; c4 ffavor contract addr = new favor ; new escrow created ( id , new favor , msg . sender ) ; return c4 ffavor contract addr ; }", "signature": "function start favor escrow ( uint256 id , uint256 deadl , uint tokens ) public not locked returns ( address c4 ffavor contract addr )", "body": "require ( balance of ( msg . sender ) >= tokens ) ; address new favor = new c4 fescrow ( address ( this ) , id , msg . sender , deadl , _arbitration percent ) ; escrow addresses . push ( new favor ) ; c4 fescrow contracts [ new favor ] = BOOL_ ; if ( ! transfer ( new favor , tokens ) ) revert ( ) ; c4 ffavor contract addr = new favor ; new escrow created ( id , new favor , msg . sender ) ; return c4 ffavor contract addr ;"}
{"comment": "amount of non-distributed smre .", "function": "function publicly distributed parts ( ) public view returns ( uint ) { return max supply . sub ( total supply ) ; }", "signature": "function publicly distributed parts ( ) public view returns ( uint )", "body": "return max supply . sub ( total supply ) ;"}
{"comment": "after we distribute the bonus tokens , we will send them back to the coin itself .", "function": "function owner recover tokens ( address _beneficiary ) external only owner { require ( _beneficiary != NUM_ ) ; require ( _beneficiary != address ( token ) ) ; uint256 _tokens remaining = token . balance of ( address ( this ) ) ; if ( _tokens remaining > NUM_ ) { token . transfer ( _beneficiary , _tokens remaining ) ; } }", "signature": "function owner recover tokens ( address _beneficiary ) external only owner", "body": "require ( _beneficiary != NUM_ ) ; require ( _beneficiary != address ( token ) ) ; uint256 _tokens remaining = token . balance of ( address ( this ) ) ; if ( _tokens remaining > NUM_ ) { token . transfer ( _beneficiary , _tokens remaining ) ; }"}
{"comment": "pause the presale ( disables contributions and token claim ) .", "function": "function pause ( ) public only owner { require ( active ) ; active = BOOL_ ; }", "signature": "function pause ( ) public only owner", "body": "require ( active ) ; active = BOOL_ ;"}
{"comment": "approve new owner request , can be call only by owner which do n't call this new owner request before .", "function": "function approve add owner request ( ) public only owners { require ( ! add owner . is execute && ! add owner . is canceled ) ; require ( add owner . creation timestamp + life time >= uint32 ( now ) ) ; require ( ! owners [ add owner . new owner ] ) ; for ( uint i = NUM_ ; i < add owner . confirmators . length ; i ++ ) { require ( add owner . confirmators [ i ] != msg . sender ) ; } add owner . confirms ++ ; add owner . confirmators . push ( msg . sender ) ; if ( add owner . confirms >= need approves to confirm ) { add owner . is execute = BOOL_ ; owners [ add owner . new owner ] = BOOL_ ; owners count ++ ; } emit add owner request update ( msg . sender , add owner . confirms , add owner . is execute ) ; }", "signature": "function approve add owner request ( ) public only owners", "body": "require ( ! add owner . is execute && ! add owner . is canceled ) ; require ( add owner . creation timestamp + life time >= uint32 ( now ) ) ; require ( ! owners [ add owner . new owner ] ) ; for ( uint i = NUM_ ; i < add owner . confirmators . length ; i ++ ) { require ( add owner . confirmators [ i ] != msg . sender ) ; } add owner . confirms ++ ; add owner . confirmators . push ( msg . sender ) ; if ( add owner . confirms >= need approves to confirm ) { add owner . is execute = BOOL_ ; owners [ add owner . new owner ] = BOOL_ ; owners count ++ ; } emit add owner request update ( msg . sender , add owner . confirms , add owner . is execute ) ;"}
{"comment": "return true if crowdsale event have end .", "function": "function has ended ( ) public constant returns ( bool ) { bool cap reached = wei raised >= wei maximum goal ; bool after end time = now > end time ; return cap reached || after end time ; }", "signature": "function has ended ( ) public constant returns ( bool )", "body": "bool cap reached = wei raised >= wei maximum goal ; bool after end time = now > end time ; return cap reached || after end time ;"}
{"comment": "call by crowdsalecontroller to transfer reward part of tokens sell by successful crowdsale to forecasting contract .", "function": "function mint token rewards ( address _contract , uint256 _amount ) public only manager ( ) { token . transfer ( _contract , _amount ) ; }", "signature": "function mint token rewards ( address _contract , uint256 _amount ) public only manager ( )", "body": "token . transfer ( _contract , _amount ) ;"}
{"comment": "release one tranche of the teamsupply allocation to yooba team , 6 . 25 .", "function": "function release for yooba team ( ) public owner only stoppable returns ( bool success ) { require ( now >= create time + NUM_ weeks ) ; require ( tokens released to team < team supply ) ; uint256 temp = team supply / NUM_ ; uint256 alloc amount = safe mul ( temp , NUM_ ) ; uint256 current tranche = uint256 ( now - create time ) / NUM_ weeks ; if ( team tranches released < max tranches && current tranche > team tranches released && ( current supply + alloc amount ) <= total supply ) { team tranches released ++ ; balance of [ yooba team address ] = safe add ( balance of [ yooba team address ] , alloc amount ) ; current supply += alloc amount ; tokens released to team = safe add ( tokens released to team , alloc amount ) ; transfer ( NUM_ , yooba team address , alloc amount ) ; return BOOL_ ; } revert ( ) ; }", "signature": "function release for yooba team ( ) public owner only stoppable returns ( bool success )", "body": "require ( now >= create time + NUM_ weeks ) ; require ( tokens released to team < team supply ) ; uint256 temp = team supply / NUM_ ; uint256 alloc amount = safe mul ( temp , NUM_ ) ; uint256 current tranche = uint256 ( now - create time ) / NUM_ weeks ; if ( team tranches released < max tranches && current tranche > team tranches released && ( current supply + alloc amount ) <= total supply ) { team tranches released ++ ; balance of [ yooba team address ] = safe add ( balance of [ yooba team address ] , alloc amount ) ; current supply += alloc amount ; tokens released to team = safe add ( tokens released to team , alloc amount ) ; transfer ( NUM_ , yooba team address , alloc amount ) ; return BOOL_ ; } revert ( ) ;"}
{"comment": "function to stop the contribution .", "function": "function stop ( ) public only owner { end time = now ; }", "signature": "function stop ( ) public only owner", "body": "end time = now ;"}
{"comment": "withdraw fund and tokens .", "function": "function withdraw ( ) only owner public { require ( contract timeout <= get block time ( ) ) ; uint256 tokens = token . balance of ( this ) ; bytes memory empty ; token . transfer ( growth contract , tokens , empty ) ; distribute ( ) ; }", "signature": "function withdraw ( ) only owner public", "body": "require ( contract timeout <= get block time ( ) ) ; uint256 tokens = token . balance of ( this ) ; bytes memory empty ; token . transfer ( growth contract , tokens , empty ) ; distribute ( ) ;"}
{"comment": "approves the passed address to spend the specified amount of tokens on behalf of msg . sender .", "function": "function approve ( address _spender , uint256 _value ) public returns ( bool ) { require ( ( _value > NUM_ ) && ( _value <= balances [ msg . sender ] ) ) ; allowed [ msg . sender ] [ _spender ] = _value ; approval ( msg . sender , _spender , _value ) ; return BOOL_ ; }", "signature": "function approve ( address _spender , uint256 _value ) public returns ( bool )", "body": "require ( ( _value > NUM_ ) && ( _value <= balances [ msg . sender ] ) ) ; allowed [ msg . sender ] [ _spender ] = _value ; approval ( msg . sender , _spender , _value ) ; return BOOL_ ;"}
{"comment": "changes the migration master .", "function": "function set migration master ( address _master ) public only migration master { require ( _master != address ( NUM_ ) ) ; migration master = _master ; }", "signature": "function set migration master ( address _master ) public only migration master", "body": "require ( _master != address ( NUM_ ) ) ; migration master = _master ;"}
{"comment": "add a node to the blacklist .", "function": "function blacklist ( address node ) public only owner { blacklisted [ node ] = BOOL_ ; blacklisted ( node ) ; }", "signature": "function blacklist ( address node ) public only owner", "body": "blacklisted [ node ] = BOOL_ ; blacklisted ( node ) ;"}
{"comment": "set default fee .", "function": "function admin set default fee ( uint market default fee low_ , uint market default fee high_ ) public { require ( msg . sender == admin ) ; market default fee low = market default fee low_ ; market default fee high = market default fee high_ ; }", "signature": "function admin set default fee ( uint market default fee low_ , uint market default fee high_ ) public", "body": "require ( msg . sender == admin ) ; market default fee low = market default fee low_ ; market default fee high = market default fee high_ ;"}
{"comment": "required for erc-721 compliance .", "function": "function name ( ) public pure returns ( string ) { return name ; }", "signature": "function name ( ) public pure returns ( string )", "body": "return name ;"}
{"comment": "total number of tokens for an amount of wei , discount-adjusted .", "function": "function _compute tokens purchased at tier ( collection storage self , uint256 _tier , uint256 _wei ) private view returns ( uint256 ) { var paid basis = max_discount . sub ( self . tiers [ _tier ] . discount ) ; return _wei . mul ( self . base rate ) . mul ( max_discount ) / paid basis ; }", "signature": "function _compute tokens purchased at tier ( collection storage self , uint256 _tier , uint256 _wei ) private view returns ( uint256 )", "body": "var paid basis = max_discount . sub ( self . tiers [ _tier ] . discount ) ; return _wei . mul ( self . base rate ) . mul ( max_discount ) / paid basis ;"}
{"comment": "can be override to add finalization logic .", "function": "function finalization ( ) internal { uint256 total supply_ = crowdsale_tokens_nums ; uint256 total sale_ = token . total crowd sale ( ) ; token . mint ( founder_walet , total supply_ . sub ( total sale_ ) ) ; token . finish minting ( ) ; super . finalization ( ) ; }", "signature": "function finalization ( ) internal", "body": "uint256 total supply_ = crowdsale_tokens_nums ; uint256 total sale_ = token . total crowd sale ( ) ; token . mint ( founder_walet , total supply_ . sub ( total sale_ ) ) ; token . finish minting ( ) ; super . finalization ( ) ;"}
{"comment": "transfer token for a specified address _to the address to transfer to .", "function": "function transfer ( address _to , uint256 _value ) returns ( bool success ) { require ( balances [ msg . sender ] >= _value && _value > NUM_ ) ; if ( transferlocked ) { throw ; } balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }", "signature": "function transfer ( address _to , uint256 _value ) returns ( bool success )", "body": "require ( balances [ msg . sender ] >= _value && _value > NUM_ ) ; if ( transferlocked ) { throw ; } balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; transfer ( msg . sender , _to , _value ) ; return BOOL_ ;"}
{"comment": "paying the tipper .", "function": "function payout ( string _password ) { require ( keccak256 ( _password ) == hash_pwd ) ; require ( ! bounty_paid ) ; require ( proposed_beneficiary != NUM_ ) ; require ( votes_for > votes_against ) ; require ( votes_for + votes_against > count_donors * NUM_ / NUM_ ) ; bounty_paid = BOOL_ ; proposed_beneficiary . transfer ( this . balance ) ; }", "signature": "function payout ( string _password )", "body": "require ( keccak256 ( _password ) == hash_pwd ) ; require ( ! bounty_paid ) ; require ( proposed_beneficiary != NUM_ ) ; require ( votes_for > votes_against ) ; require ( votes_for + votes_against > count_donors * NUM_ / NUM_ ) ; bounty_paid = BOOL_ ; proposed_beneficiary . transfer ( this . balance ) ;"}
{"comment": "get all approve proposals .", "function": "function get approved proposals ( ) public view returns ( uint [ ] ) { uint count = NUM_ ; for ( uint i = NUM_ ; i < proposals . length ; i ++ ) { if ( proposals [ i ] . approved && ! proposals [ i ] . denied ) { count ++ ; } } uint [ ] memory approved proposals = new uint [ ] ( count ) ; count = NUM_ ; for ( i = NUM_ ; i < proposals . length ; i ++ ) { if ( proposals [ i ] . approved && ! proposals [ i ] . denied ) { approved proposals [ count ] = i ; count ++ ; } } return approved proposals ; }", "signature": "function get approved proposals ( ) public view returns ( uint [ ] )", "body": "uint count = NUM_ ; for ( uint i = NUM_ ; i < proposals . length ; i ++ ) { if ( proposals [ i ] . approved && ! proposals [ i ] . denied ) { count ++ ; } } uint [ ] memory approved proposals = new uint [ ] ( count ) ; count = NUM_ ; for ( i = NUM_ ; i < proposals . length ; i ++ ) { if ( proposals [ i ] . approved && ! proposals [ i ] . denied ) { approved proposals [ count ] = i ; count ++ ; } } return approved proposals ;"}
{"comment": "token allocations have not be set .", "function": "modifier not allocated { require ( allocations [ team reserve wallet ] == NUM_ ) ; require ( allocations [ final reserve wallet ] == NUM_ ) ; _ ; }", "signature": "modifier not allocated", "body": "require ( allocations [ team reserve wallet ] == NUM_ ) ; require ( allocations [ final reserve wallet ] == NUM_ ) ; _ ;"}
{"comment": "return true if the crowdsale have raise enough money to be a successful .", "function": "function is minimum goal reached ( ) public constant returns ( bool ) { return wei raised >= minimum goal ; }", "signature": "function is minimum goal reached ( ) public constant returns ( bool )", "body": "return wei raised >= minimum goal ;"}
{"comment": "transfers ownership of a subnode sha3 ( node , label ) to a new address .", "function": "function set subnode owner ( bytes32 node , bytes32 label , address owner ) only_owner ( node ) { var subnode = sha3 ( node , label ) ; new owner ( node , label , owner ) ; records [ subnode ] . owner = owner ; }", "signature": "function set subnode owner ( bytes32 node , bytes32 label , address owner ) only_owner ( node )", "body": "var subnode = sha3 ( node , label ) ; new owner ( node , label , owner ) ; records [ subnode ] . owner = owner ;"}
{"comment": "this function will be use by the c4f app to charge a commission on transfer later .", "function": "function transfer with commission ( address to , uint tokens ) public not locked not paused returns ( bool success ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( tokens ) ; uint com tokens = tokens . mul ( _commission ) ; com tokens = com tokens . div ( NUM_ ) ; balances [ to ] = balances [ to ] . add ( tokens . sub ( com tokens ) ) ; balances [ _commission target ] = balances [ _commission target ] . add ( com tokens ) ; transfer ( msg . sender , to , tokens . sub ( com tokens ) ) ; transfer ( msg . sender , _commission target , com tokens ) ; return BOOL_ ; }", "signature": "function transfer with commission ( address to , uint tokens ) public not locked not paused returns ( bool success )", "body": "balances [ msg . sender ] = balances [ msg . sender ] . sub ( tokens ) ; uint com tokens = tokens . mul ( _commission ) ; com tokens = com tokens . div ( NUM_ ) ; balances [ to ] = balances [ to ] . add ( tokens . sub ( com tokens ) ) ; balances [ _commission target ] = balances [ _commission target ] . add ( com tokens ) ; transfer ( msg . sender , to , tokens . sub ( com tokens ) ) ; transfer ( msg . sender , _commission target , com tokens ) ; return BOOL_ ;"}
{"comment": "set current market rate eth / rich .", "function": "function set current market rate ( uint256 _current market rate ) only creator returns ( uint256 ) { current market rate = _current market rate ; }", "signature": "function set current market rate ( uint256 _current market rate ) only creator returns ( uint256 )", "body": "current market rate = _current market rate ;"}
{"comment": "for create person .", "function": "function _create person ( string _name , address _owner , uint256 _price ) private { person memory _person = person ( { name : _name } ) ; uint256 new person id = persons . push ( _person ) - NUM_ ; require ( new person id == uint256 ( uint32 ( new person id ) ) ) ; birth ( new person id , _name , _owner ) ; person index to price [ new person id ] = _price ; _transfer ( address ( NUM_ ) , _owner , new person id ) ; }", "signature": "function _create person ( string _name , address _owner , uint256 _price ) private", "body": "person memory _person = person ( { name : _name } ) ; uint256 new person id = persons . push ( _person ) - NUM_ ; require ( new person id == uint256 ( uint32 ( new person id ) ) ) ; birth ( new person id , _name , _owner ) ; person index to price [ new person id ] = _price ; _transfer ( address ( NUM_ ) , _owner , new person id ) ;"}
{"comment": "create a new factory by clone the factory specify in setfactory .", "function": "function deploy factory ( ) public only owner ( ) returns ( address ) { address _new_fac = create clone ( factory ) ; factory_index [ _new_fac ] = factory_contracts . length ; factory_contracts . push ( _new_fac ) ; factory ( _new_fac ) . init ( msg . sender ) ; emit new factory ( _new_fac ) ; return _new_fac ; }", "signature": "function deploy factory ( ) public only owner ( ) returns ( address )", "body": "address _new_fac = create clone ( factory ) ; factory_index [ _new_fac ] = factory_contracts . length ; factory_contracts . push ( _new_fac ) ; factory ( _new_fac ) . init ( msg . sender ) ; emit new factory ( _new_fac ) ; return _new_fac ;"}
{"comment": "mint timelocked tokens .", "function": "function mint timelocked ( address _to , uint256 _release time , uint256 _amount ) only owner can mint returns ( bool ) { require ( _release time > now ) ; require ( _amount > NUM_ ) ; locked balance exist = locked balances [ _to ] ; require ( exist . amount == NUM_ ) ; locked balance memory balance = locked balance ( _release time , _amount ) ; total supply = total supply . add ( _amount ) ; locked balances [ _to ] = balance ; mint lock ( _to , _release time , _amount ) ; return BOOL_ ; }", "signature": "function mint timelocked ( address _to , uint256 _release time , uint256 _amount ) only owner can mint returns ( bool )", "body": "require ( _release time > now ) ; require ( _amount > NUM_ ) ; locked balance exist = locked balances [ _to ] ; require ( exist . amount == NUM_ ) ; locked balance memory balance = locked balance ( _release time , _amount ) ; total supply = total supply . add ( _amount ) ; locked balances [ _to ] = balance ; mint lock ( _to , _release time , _amount ) ; return BOOL_ ;"}
{"comment": "whitelist an address .", "function": "function whitelist address ( address token owner ) only owner public returns ( bool ) { balances [ token owner ] . air drop qty = NUM_ ; return BOOL_ ; }", "signature": "function whitelist address ( address token owner ) only owner public returns ( bool )", "body": "balances [ token owner ] . air drop qty = NUM_ ; return BOOL_ ;"}
{"comment": "create mintedamount tokens and send it to target .", "function": "function mint token ( address target , uint256 minted amount ) only owner public { balance of [ target ] += minted amount ; total supply += minted amount ; transfer ( NUM_ , this , minted amount ) ; transfer ( this , target , minted amount ) ; }", "signature": "function mint token ( address target , uint256 minted amount ) only owner public", "body": "balance of [ target ] += minted amount ; total supply += minted amount ; transfer ( NUM_ , this , minted amount ) ; transfer ( this , target , minted amount ) ;"}
{"comment": "this be a constructor function which mean the following function name have to match the contract name declare above .", "function": "function hashnode test coin ( ) { balances [ msg . sender ] = NUM_ ; total supply = NUM_ ; name = STR_ ; decimals = NUM_ ; symbol = STR_ ; units one eth can buy = NUM_ ; funds wallet = msg . sender ; }", "signature": "function hashnode test coin ( )", "body": "balances [ msg . sender ] = NUM_ ; total supply = NUM_ ; name = STR_ ; decimals = NUM_ ; symbol = STR_ ; units one eth can buy = NUM_ ; funds wallet = msg . sender ;"}
{"comment": "player 's attack defend steal battle power .", "function": "function get players battle stats ( address player ) public constant returns ( uint256 attacking power , uint256 defending power , uint256 stealing power , uint256 battle power ) { uint256 start id ; uint256 end id ; ( start id , end id ) = schema . battle card id range ( ) ; while ( start id <= end id ) { attacking power = safe math . add ( attacking power , get units attack ( player , start id , units owned [ player ] [ start id ] ) ) ; stealing power = safe math . add ( stealing power , get units stealing capacity ( player , start id , units owned [ player ] [ start id ] ) ) ; defending power = safe math . add ( defending power , get units defense ( player , start id , units owned [ player ] [ start id ] ) ) ; battle power = safe math . add ( attacking power , defending power ) ; start id ++ ; } }", "signature": "function get players battle stats ( address player ) public constant returns ( uint256 attacking power , uint256 defending power , uint256 stealing power , uint256 battle power )", "body": "uint256 start id ; uint256 end id ; ( start id , end id ) = schema . battle card id range ( ) ; while ( start id <= end id ) { attacking power = safe math . add ( attacking power , get units attack ( player , start id , units owned [ player ] [ start id ] ) ) ; stealing power = safe math . add ( stealing power , get units stealing capacity ( player , start id , units owned [ player ] [ start id ] ) ) ; defending power = safe math . add ( defending power , get units defense ( player , start id , units owned [ player ] [ start id ] ) ) ; battle power = safe math . add ( attacking power , defending power ) ; start id ++ ; }"}
{"comment": "in case of an emergency situation or other unexpected event an owner of the contract can explicitly enable refund .", "function": "function enable refunds ( ) external only owner { require ( ! refunds enabled ) ; require ( ! winner confirmed ) ; refunds enabled = BOOL_ ; refunds enabled ( ) ; }", "signature": "function enable refunds ( ) external only owner", "body": "require ( ! refunds enabled ) ; require ( ! winner confirmed ) ; refunds enabled = BOOL_ ; refunds enabled ( ) ;"}
{"comment": "set the token contract address a a one-time operation .", "function": "function set token contract address ( address _token contract address ) admin only { if ( token contract defined ) throw ; token = token ( _token contract address ) ; token contract defined = BOOL_ ; }", "signature": "function set token contract address ( address _token contract address ) admin only", "body": "if ( token contract defined ) throw ; token = token ( _token contract address ) ; token contract defined = BOOL_ ;"}
{"comment": "be a number request pending for the address .", "function": "function is request pending ( address _requestor ) public constant returns ( bool ) { if ( random numbers [ _requestor ] . rendered number == NUM_ && random numbers [ _requestor ] . wait time > NUM_ ) { return BOOL_ ; } return BOOL_ ; }", "signature": "function is request pending ( address _requestor ) public constant returns ( bool )", "body": "if ( random numbers [ _requestor ] . rendered number == NUM_ && random numbers [ _requestor ] . wait time > NUM_ ) { return BOOL_ ; } return BOOL_ ;"}
{"comment": "check if a user address have enough token balance to be eligible to create a contract .", "function": "function is balance sufficient for contract creation ( address user address ) external view returns ( bool ) { return balances [ user address ] >= min balance to allow contract creation ; }", "signature": "function is balance sufficient for contract creation ( address user address ) external view returns ( bool )", "body": "return balances [ user address ] >= min balance to allow contract creation ;"}
{"comment": "release any other tokens need and mark u a allocate .", "function": "function release tokens ( ) external only owner sale allocating { require ( reserve vault != address ( NUM_ ) ) ; require ( restricted vault != address ( NUM_ ) ) ; require ( sale allocated == BOOL_ ) ; sale allocated = BOOL_ ; token . mint ( reserve vault , reserve cap ) ; token . mint ( restricted vault , team cap ) ; }", "signature": "function release tokens ( ) external only owner sale allocating", "body": "require ( reserve vault != address ( NUM_ ) ) ; require ( restricted vault != address ( NUM_ ) ) ; require ( sale allocated == BOOL_ ) ; sale allocated = BOOL_ ; token . mint ( reserve vault , reserve cap ) ; token . mint ( restricted vault , team cap ) ;"}
{"comment": "get annual fee in rvt .", "function": "function get annual fee ( ) public view returns ( uint256 ) { return fee per sec . mul ( sec per year ) ; }", "signature": "function get annual fee ( ) public view returns ( uint256 )", "body": "return fee per sec . mul ( sec per year ) ;"}
{"comment": "receiveapproval call function encode a extra data .", "function": "function receive approval ( address _sender , uint256 _value , address _token contract , bytes _extra data ) external { require ( _token contract == address ( ndc ) ) ; assert ( this . call ( _extra data ) ) ; }", "signature": "function receive approval ( address _sender , uint256 _value , address _token contract , bytes _extra data ) external", "body": "require ( _token contract == address ( ndc ) ) ; assert ( this . call ( _extra data ) ) ;"}
{"comment": "append element to end of list .", "function": "function append ( data storage _data , address _item ) { append ( _data , _item , _data . tail ) ; }", "signature": "function append ( data storage _data , address _item )", "body": "append ( _data , _item , _data . tail ) ;"}
{"comment": "moves fund in sale contract to acfwallet .", "function": "function move funds ( ) only owner public { if ( ! acfwallet . send ( this . balance ) ) throw ; }", "signature": "function move funds ( ) only owner public", "body": "if ( ! acfwallet . send ( this . balance ) ) throw ;"}
{"comment": "transfer the balance from owner 's account to another account , with a check that the crowdsale be finalise .", "function": "function transfer ( address _to , uint _amount ) returns ( bool success ) { require ( ( time ( ) > end date + NUM_ days ) ) ; return super . transfer ( _to , _amount ) ; }", "signature": "function transfer ( address _to , uint _amount ) returns ( bool success )", "body": "require ( ( time ( ) > end date + NUM_ days ) ) ; return super . transfer ( _to , _amount ) ;"}
{"comment": "if ico reach owner can withdrow eth for ico comping managment .", "function": "function withdraw pre ico founds ( ) public only owner { if ( current pre icobalance > softcap ) { uint available to transer = this . balance - manager ethbonus ; owner . transfer ( available to transer ) ; } }", "signature": "function withdraw pre ico founds ( ) public only owner", "body": "if ( current pre icobalance > softcap ) { uint available to transer = this . balance - manager ethbonus ; owner . transfer ( available to transer ) ; }"}
{"comment": "toggle the attachment switch .", "function": "function toggle attached enforcement ( bool _state ) public only manager { attached system active = _state ; }", "signature": "function toggle attached enforcement ( bool _state ) public only manager", "body": "attached system active = _state ;"}
{"comment": "buy tokens on pre-ico and ico .", "function": "function tokens_buy ( ) payable returns ( bool ) { uint tnow = now ; require ( tnow <= ico_finish ) ; require ( _total supply < max tokens ) ; require ( msg . value >= token_price ) ; uint tokens_buy = msg . value * NUM_ * * NUM_ / token_price ; require ( tokens_buy > NUM_ ) ; if ( tnow < ico_start + NUM_ * NUM_ ) { tokens_buy = tokens_buy * p1 / NUM_ ; } if ( ( ico_start + NUM_ * NUM_ <= tnow ) && ( tnow < ico_start + NUM_ * NUM_ ) ) { tokens_buy = tokens_buy * p2 / NUM_ ; } if ( ( ico_start + NUM_ * NUM_ <= tnow ) && ( tnow < ico_start + NUM_ * NUM_ ) ) { tokens_buy = tokens_buy * p3 / NUM_ ; } if ( ( ico_start + NUM_ * NUM_ <= tnow ) && ( tnow < ico_start + NUM_ * NUM_ ) ) { tokens_buy = tokens_buy * p4 / NUM_ ; } if ( ico_start + NUM_ * NUM_ <= tnow ) { tokens_buy = tokens_buy * p5 / NUM_ ; } require ( _total supply . add ( tokens_buy ) <= max tokens ) ; _total supply = _total supply . add ( tokens_buy ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( tokens_buy ) ; return BOOL_ ; }", "signature": "function tokens_buy ( ) payable returns ( bool )", "body": "uint tnow = now ; require ( tnow <= ico_finish ) ; require ( _total supply < max tokens ) ; require ( msg . value >= token_price ) ; uint tokens_buy = msg . value * NUM_ * * NUM_ / token_price ; require ( tokens_buy > NUM_ ) ; if ( tnow < ico_start + NUM_ * NUM_ ) { tokens_buy = tokens_buy * p1 / NUM_ ; } if ( ( ico_start + NUM_ * NUM_ <= tnow ) && ( tnow < ico_start + NUM_ * NUM_ ) ) { tokens_buy = tokens_buy * p2 / NUM_ ; } if ( ( ico_start + NUM_ * NUM_ <= tnow ) && ( tnow < ico_start + NUM_ * NUM_ ) ) { tokens_buy = tokens_buy * p3 / NUM_ ; } if ( ( ico_start + NUM_ * NUM_ <= tnow ) && ( tnow < ico_start + NUM_ * NUM_ ) ) { tokens_buy = tokens_buy * p4 / NUM_ ; } if ( ico_start + NUM_ * NUM_ <= tnow ) { tokens_buy = tokens_buy * p5 / NUM_ ; } require ( _total supply . add ( tokens_buy ) <= max tokens ) ; _total supply = _total supply . add ( tokens_buy ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( tokens_buy ) ; return BOOL_ ;"}
{"comment": "makes order for tokens purchase .", "function": "function buy tokens ( address _funder , uint256 _funds ) internal { require ( live betex ico ( ) ) ; require ( _funds >= min_funding_amount ) ; require ( oraclize_get price ( STR_ ) <= address ( this ) . balance ) ; bytes32 _order id = oraclize_query ( STR_ , eth rate url , oraclize gas limit ) ; uint256 _bonus = betex storage . get bonus ( _funds , bonus change time ) ; betex storage . add order ( _order id , _funder , _funds , _bonus ) ; wallet . transfer ( _funds ) ; raised = raised . add ( _funds ) ; betex storage . add funder ( _funder ) ; emit order event ( _funder , _order id , _funds ) ; }", "signature": "function buy tokens ( address _funder , uint256 _funds ) internal", "body": "require ( live betex ico ( ) ) ; require ( _funds >= min_funding_amount ) ; require ( oraclize_get price ( STR_ ) <= address ( this ) . balance ) ; bytes32 _order id = oraclize_query ( STR_ , eth rate url , oraclize gas limit ) ; uint256 _bonus = betex storage . get bonus ( _funds , bonus change time ) ; betex storage . add order ( _order id , _funder , _funds , _bonus ) ; wallet . transfer ( _funds ) ; raised = raised . add ( _funds ) ; betex storage . add funder ( _funder ) ; emit order event ( _funder , _order id , _funds ) ;"}
{"comment": "transfer token for a specified address ( write due to backward compatibility ) .", "function": "function transfer ( address to , uint256 value ) public returns ( bool ) { require ( to != address ( NUM_ ) ) ; require ( value <= balances [ msg . sender ] ) ; uint256 value allowed to transfer ; if ( is investor [ msg . sender ] ) { if ( now >= becomes transferable ) { value allowed to transfer = balances [ msg . sender ] ; assert ( value <= value allowed to transfer ) ; } else { value allowed to transfer = balances allowed to transfer [ msg . sender ] ; assert ( value <= value allowed to transfer ) ; balances allowed to transfer [ msg . sender ] = balances allowed to transfer [ msg . sender ] . sub ( value ) ; } } balances [ msg . sender ] = balances [ msg . sender ] . sub ( value ) ; balances [ to ] = balances [ to ] . add ( value ) ; emit transfer ( msg . sender , to , value ) ; return BOOL_ ; }", "signature": "function transfer ( address to , uint256 value ) public returns ( bool )", "body": "require ( to != address ( NUM_ ) ) ; require ( value <= balances [ msg . sender ] ) ; uint256 value allowed to transfer ; if ( is investor [ msg . sender ] ) { if ( now >= becomes transferable ) { value allowed to transfer = balances [ msg . sender ] ; assert ( value <= value allowed to transfer ) ; } else { value allowed to transfer = balances allowed to transfer [ msg . sender ] ; assert ( value <= value allowed to transfer ) ; balances allowed to transfer [ msg . sender ] = balances allowed to transfer [ msg . sender ] . sub ( value ) ; } } balances [ msg . sender ] = balances [ msg . sender ] . sub ( value ) ; balances [ to ] = balances [ to ] . add ( value ) ; emit transfer ( msg . sender , to , value ) ; return BOOL_ ;"}
{"comment": "buyer balance in wei .", "function": "function buyer balance ( address _buyer ) public constant returns ( uint ) { return buyer balances [ _buyer ] ; }", "signature": "function buyer balance ( address _buyer ) public constant returns ( uint )", "body": "return buyer balances [ _buyer ] ;"}
{"comment": "limiting function to the admins of the token only .", "function": "modifier only admin { require ( msg . sender == owner || msg . sender == sale tokens vault ) ; _ ; }", "signature": "modifier only admin", "body": "require ( msg . sender == owner || msg . sender == sale tokens vault ) ; _ ;"}
{"comment": "clears record of a contributor from a group 's record .", "function": "function _clear contributor record in group ( uint256 _token id , address _user add ) private returns ( uint256 refund balance ) { var group = token index to group [ _token id ] ; uint c index = group . address to contributor arr index [ _user add ] - NUM_ ; uint last cindex = group . contributor arr . length - NUM_ ; refund balance = group . address to contribution [ _user add ] ; token index to group [ _token id ] . address to contributor arr index [ _user add ] = NUM_ ; token index to group [ _token id ] . address to contribution [ _user add ] = NUM_ ; if ( last cindex > NUM_ ) { token index to group [ _token id ] . address to contributor arr index [ group . contributor arr [ last cindex ] ] = c index ; token index to group [ _token id ] . contributor arr [ c index ] = group . contributor arr [ last cindex ] ; } token index to group [ _token id ] . contributor arr . length -= NUM_ ; token index to group [ _token id ] . contributed balance -= refund balance ; }", "signature": "function _clear contributor record in group ( uint256 _token id , address _user add ) private returns ( uint256 refund balance )", "body": "var group = token index to group [ _token id ] ; uint c index = group . address to contributor arr index [ _user add ] - NUM_ ; uint last cindex = group . contributor arr . length - NUM_ ; refund balance = group . address to contribution [ _user add ] ; token index to group [ _token id ] . address to contributor arr index [ _user add ] = NUM_ ; token index to group [ _token id ] . address to contribution [ _user add ] = NUM_ ; if ( last cindex > NUM_ ) { token index to group [ _token id ] . address to contributor arr index [ group . contributor arr [ last cindex ] ] = c index ; token index to group [ _token id ] . contributor arr [ c index ] = group . contributor arr [ last cindex ] ; } token index to group [ _token id ] . contributor arr . length -= NUM_ ; token index to group [ _token id ] . contributed balance -= refund balance ;"}
{"comment": "for the first 1 . 500 . 000 .", "function": "function add bonuses ( uint256 _amount ) returns ( uint256 ) { uint256 reward ; var ( x , y ) = ( reward , reward ) ; if ( remaining tokens > NUM_ * NUM_ ether ) { ( x , y ) = level one bonus ( _amount ) ; reward += x ; if ( y != NUM_ ) { ( x , y ) = level two bonus ( y ) ; reward += x ; if ( y != NUM_ ) { return reward + level three bonus ( y ) ; } } return reward ; } else if ( remaining tokens > NUM_ * NUM_ ether ) { ( x , y ) = level two bonus ( _amount ) ; if ( y != NUM_ ) { return x + level three bonus ( y ) ; } return x ; } else { return level three bonus ( _amount ) ; } }", "signature": "function add bonuses ( uint256 _amount ) returns ( uint256 )", "body": "uint256 reward ; var ( x , y ) = ( reward , reward ) ; if ( remaining tokens > NUM_ * NUM_ ether ) { ( x , y ) = level one bonus ( _amount ) ; reward += x ; if ( y != NUM_ ) { ( x , y ) = level two bonus ( y ) ; reward += x ; if ( y != NUM_ ) { return reward + level three bonus ( y ) ; } } return reward ; } else if ( remaining tokens > NUM_ * NUM_ ether ) { ( x , y ) = level two bonus ( _amount ) ; if ( y != NUM_ ) { return x + level three bonus ( y ) ; } return x ; } else { return level three bonus ( _amount ) ; }"}
{"comment": "for create color .", "function": "function _create color ( uint256 _r , uint256 _g , uint256 _b , string _name , address _owner , uint256 _price ) private { require ( _r == uint256 ( uint8 ( _r ) ) ) ; require ( _g == uint256 ( uint8 ( _g ) ) ) ; require ( _b == uint256 ( uint8 ( _b ) ) ) ; color memory _color = color ( { r : uint8 ( _r ) , g : uint8 ( _g ) , b : uint8 ( _b ) , name : _name } ) ; uint256 new color id = colors . push ( _color ) - NUM_ ; require ( new color id == uint256 ( uint32 ( new color id ) ) ) ; released ( new color id , _name , _owner ) ; color index to price [ new color id ] = _price ; _transfer ( address ( NUM_ ) , _owner , new color id ) ; }", "signature": "function _create color ( uint256 _r , uint256 _g , uint256 _b , string _name , address _owner , uint256 _price ) private", "body": "require ( _r == uint256 ( uint8 ( _r ) ) ) ; require ( _g == uint256 ( uint8 ( _g ) ) ) ; require ( _b == uint256 ( uint8 ( _b ) ) ) ; color memory _color = color ( { r : uint8 ( _r ) , g : uint8 ( _g ) , b : uint8 ( _b ) , name : _name } ) ; uint256 new color id = colors . push ( _color ) - NUM_ ; require ( new color id == uint256 ( uint32 ( new color id ) ) ) ; released ( new color id , _name , _owner ) ; color index to price [ new color id ] = _price ; _transfer ( address ( NUM_ ) , _owner , new color id ) ;"}
{"comment": "the price of a product .", "function": "function price of ( uint256 _product id ) public view returns ( uint256 ) { return products [ _product id ] . price ; }", "signature": "function price of ( uint256 _product id ) public view returns ( uint256 )", "body": "return products [ _product id ] . price ;"}
{"comment": "removes an exist worker , remove workers ca n't be add back .", "function": "function remove delegate ( address _address ) public only owner returns ( bool ) { delegate log storage delegate log = delegates [ _address ] ; require ( delegate log . started != NUM_ && delegate log . ended == NUM_ ) ; delegate log . ended = block . timestamp ; return BOOL_ ; }", "signature": "function remove delegate ( address _address ) public only owner returns ( bool )", "body": "delegate log storage delegate log = delegates [ _address ] ; require ( delegate log . started != NUM_ && delegate log . ended == NUM_ ) ; delegate log . ended = block . timestamp ; return BOOL_ ;"}
{"comment": "the owner can allocate the specified amount .", "function": "function owner allocate ( address _to , uint amount wei ) public only owner non reentrant { amount raised = amount raised . add ( amount wei ) ; require ( get total amount raised ( ) <= funding cap ) ; balance of [ _to ] = balance of [ _to ] . add ( amount wei ) ; fund transfer ( _to , amount wei , BOOL_ ) ; update funding cap ( ) ; }", "signature": "function owner allocate ( address _to , uint amount wei ) public only owner non reentrant", "body": "amount raised = amount raised . add ( amount wei ) ; require ( get total amount raised ( ) <= funding cap ) ; balance of [ _to ] = balance of [ _to ] . add ( amount wei ) ; fund transfer ( _to , amount wei , BOOL_ ) ; update funding cap ( ) ;"}
{"comment": "get the token balance for account tokenowner .", "function": "function balance of ( address token owner ) public constant returns ( uint balance ) { return balances [ token owner ] ; }", "signature": "function balance of ( address token owner ) public constant returns ( uint balance )", "body": "return balances [ token owner ] ;"}
{"comment": "unlock investors fund , see unlockinvestor for detail .", "function": "function receive approval ( address from , uint256 , address _token , bytes _data ) public only state ( lock state . accepting unlocks ) returns ( bool ) { require ( msg . sender == _token ) ; require ( _data . length == NUM_ ) ; require ( _token == address ( neumark ) ) ; unlock investor ( from ) ; return BOOL_ ; }", "signature": "function receive approval ( address from , uint256 , address _token , bytes _data ) public only state ( lock state . accepting unlocks ) returns ( bool )", "body": "require ( msg . sender == _token ) ; require ( _data . length == NUM_ ) ; require ( _token == address ( neumark ) ) ; unlock investor ( from ) ; return BOOL_ ;"}
{"comment": "purchase a share from it current owner .", "function": "function purchase ( uint256 _stock id , uint256 _share id ) public payable { require ( _stock id < stocks . length && _share id < shares . length ) ; stock storage stock = stocks [ _stock id ] ; uint256 [ ] storage shares for stock = stock shares [ _stock id ] ; share storage share = shares [ shares for stock [ _share id ] ] ; address previous holder = share . holder ; uint256 current price = get purchase price ( share . purchase price , stock . price increase ) ; require ( msg . value >= current price ) ; if ( msg . value > current price ) { msg . sender . transfer ( safe math . sub ( msg . value , current price ) ) ; } uint256 dividend per recipient = get dividend payout ( current price , stock . dividend amount , shares for stock . length - NUM_ ) ; uint256 previous holder share = safe math . sub ( current price , safe math . mul ( dividend per recipient , shares for stock . length - NUM_ ) ) ; uint256 fee = safe math . div ( previous holder share , NUM_ ) ; owner . transfer ( fee ) ; previous holder . transfer ( safe math . sub ( previous holder share , fee ) ) ; for ( uint8 i = NUM_ ; i < shares for stock . length ; i ++ ) { if ( i != _share id ) { shares [ shares for stock [ i ] ] . holder . transfer ( dividend per recipient ) ; stock . dividends paid = safe math . add ( stock . dividends paid , dividend per recipient ) ; dividend paid ( shares [ shares for stock [ i ] ] . holder , dividend per recipient ) ; } } share sold ( _stock id , _share id , share . purchase price , current price , share . holder , msg . sender ) ; share . holder = msg . sender ; share . purchase price = current price ; stock . last action = block . timestamp ; }", "signature": "function purchase ( uint256 _stock id , uint256 _share id ) public payable", "body": "require ( _stock id < stocks . length && _share id < shares . length ) ; stock storage stock = stocks [ _stock id ] ; uint256 [ ] storage shares for stock = stock shares [ _stock id ] ; share storage share = shares [ shares for stock [ _share id ] ] ; address previous holder = share . holder ; uint256 current price = get purchase price ( share . purchase price , stock . price increase ) ; require ( msg . value >= current price ) ; if ( msg . value > current price ) { msg . sender . transfer ( safe math . sub ( msg . value , current price ) ) ; } uint256 dividend per recipient = get dividend payout ( current price , stock . dividend amount , shares for stock . length - NUM_ ) ; uint256 previous holder share = safe math . sub ( current price , safe math . mul ( dividend per recipient , shares for stock . length - NUM_ ) ) ; uint256 fee = safe math . div ( previous holder share , NUM_ ) ; owner . transfer ( fee ) ; previous holder . transfer ( safe math . sub ( previous holder share , fee ) ) ; for ( uint8 i = NUM_ ; i < shares for stock . length ; i ++ ) { if ( i != _share id ) { shares [ shares for stock [ i ] ] . holder . transfer ( dividend per recipient ) ; stock . dividends paid = safe math . add ( stock . dividends paid , dividend per recipient ) ; dividend paid ( shares [ shares for stock [ i ] ] . holder , dividend per recipient ) ; } } share sold ( _stock id , _share id , share . purchase price , current price , share . holder , msg . sender ) ; share . holder = msg . sender ; share . purchase price = current price ; stock . last action = block . timestamp ;"}
{"comment": "pause all gameplay .", "function": "function pause ( bool pause ) only owner { paused = pause ; }", "signature": "function pause ( bool pause ) only owner", "body": "paused = pause ;"}
{"comment": "looks up the current token price .", "function": "function get price ( ) constant returns ( uint price ) { return prices ; }", "signature": "function get price ( ) constant returns ( uint price )", "body": "return prices ;"}
{"comment": "sale period start at startblock until the sale start ( startsale ) .", "function": "function valid purchase presale ( ) internal constant returns ( bool ) { bool within period = ( block . number >= start block ) && ( block . number <= end presale ) ; bool non zero purchase = msg . value != NUM_ ; bool within cap = wei raised pre sale . add ( msg . value ) <= presale cap ; return within period && non zero purchase && within cap ; }", "signature": "function valid purchase presale ( ) internal constant returns ( bool )", "body": "bool within period = ( block . number >= start block ) && ( block . number <= end presale ) ; bool non zero purchase = msg . value != NUM_ ; bool within cap = wei raised pre sale . add ( msg . value ) <= presale cap ; return within period && non zero purchase && within cap ;"}
{"comment": "logic run whenever a buy order be execute .", "function": "function buy core ( uint256 _p id , uint256 _aff id , uint256 _team , f3 ddatasets . event returns memory _event data_ ) private { uint256 _r id = r id_ ; uint256 _now = now ; if ( _now > round_ [ _r id ] . strt + rnd gap_ && ( _now <= round_ [ _r id ] . end || ( _now > round_ [ _r id ] . end && round_ [ _r id ] . plyr == NUM_ ) ) ) { core ( _r id , _p id , msg . value , _aff id , _team , _event data_ ) ; } else { if ( _now > round_ [ _r id ] . end && round_ [ _r id ] . ended == BOOL_ ) { round_ [ _r id ] . ended = BOOL_ ; _event data_ = end round ( _event data_ ) ; _event data_ . compressed data = _event data_ . compressed data + ( _now * NUM_ ) ; _event data_ . compressed ids = _event data_ . compressed ids + _p id ; emit f3 devents . on buy and distribute ( msg . sender , plyr_ [ _p id ] . name , msg . value , _event data_ . compressed data , _event data_ . compressed ids , _event data_ . winner addr , _event data_ . winner name , _event data_ . amount won , _event data_ . new pot , _event data_ . p3 damount , _event data_ . gen amount ) ; } plyr_ [ _p id ] . gen = plyr_ [ _p id ] . gen . add ( msg . value ) ; } }", "signature": "function buy core ( uint256 _p id , uint256 _aff id , uint256 _team , f3 ddatasets . event returns memory _event data_ ) private", "body": "uint256 _r id = r id_ ; uint256 _now = now ; if ( _now > round_ [ _r id ] . strt + rnd gap_ && ( _now <= round_ [ _r id ] . end || ( _now > round_ [ _r id ] . end && round_ [ _r id ] . plyr == NUM_ ) ) ) { core ( _r id , _p id , msg . value , _aff id , _team , _event data_ ) ; } else { if ( _now > round_ [ _r id ] . end && round_ [ _r id ] . ended == BOOL_ ) { round_ [ _r id ] . ended = BOOL_ ; _event data_ = end round ( _event data_ ) ; _event data_ . compressed data = _event data_ . compressed data + ( _now * NUM_ ) ; _event data_ . compressed ids = _event data_ . compressed ids + _p id ; emit f3 devents . on buy and distribute ( msg . sender , plyr_ [ _p id ] . name , msg . value , _event data_ . compressed data , _event data_ . compressed ids , _event data_ . winner addr , _event data_ . winner name , _event data_ . amount won , _event data_ . new pot , _event data_ . p3 damount , _event data_ . gen amount ) ; } plyr_ [ _p id ] . gen = plyr_ [ _p id ] . gen . add ( msg . value ) ; }"}
{"comment": "low level token purchase * * * do not override .", "function": "function buy tokens ( address _beneficiary ) public payable { uint256 wei amount = msg . value ; _pre validate purchase ( _beneficiary , wei amount ) ; uint256 tokens = _get token amount ( wei amount ) ; wei raised = wei raised . add ( wei amount ) ; _process purchase ( _beneficiary , tokens ) ; emit token purchase ( msg . sender , _beneficiary , wei amount , tokens ) ; _update purchasing state ( _beneficiary , wei amount ) ; _forward funds ( ) ; _post validate purchase ( _beneficiary , wei amount ) ; }", "signature": "function buy tokens ( address _beneficiary ) public payable", "body": "uint256 wei amount = msg . value ; _pre validate purchase ( _beneficiary , wei amount ) ; uint256 tokens = _get token amount ( wei amount ) ; wei raised = wei raised . add ( wei amount ) ; _process purchase ( _beneficiary , tokens ) ; emit token purchase ( msg . sender , _beneficiary , wei amount , tokens ) ; _update purchasing state ( _beneficiary , wei amount ) ; _forward funds ( ) ; _post validate purchase ( _beneficiary , wei amount ) ;"}
{"comment": "generates _amount tokens that be assign to _owner .", "function": "function generate tokens ( address _owner , uint _amount ) public only controller returns ( bool ) { uint cur total supply = total supply ( ) ; require ( cur total supply + _amount >= cur total supply ) ; uint previous balance to = balance of ( _owner ) ; require ( previous balance to + _amount >= previous balance to ) ; update value at now ( total supply history , cur total supply + _amount ) ; update value at now ( balances [ _owner ] , previous balance to + _amount ) ; transfer ( NUM_ , _owner , _amount ) ; return BOOL_ ; }", "signature": "function generate tokens ( address _owner , uint _amount ) public only controller returns ( bool )", "body": "uint cur total supply = total supply ( ) ; require ( cur total supply + _amount >= cur total supply ) ; uint previous balance to = balance of ( _owner ) ; require ( previous balance to + _amount >= previous balance to ) ; update value at now ( total supply history , cur total supply + _amount ) ; update value at now ( balances [ _owner ] , previous balance to + _amount ) ; transfer ( NUM_ , _owner , _amount ) ; return BOOL_ ;"}
{"comment": "setup the interface to the blocklord contract .", "function": "function set blinterface ( address new address ) public only owner { bl = blinterface ( new address ) ; }", "signature": "function set blinterface ( address new address ) public only owner", "body": "bl = blinterface ( new address ) ;"}
{"comment": "transfer token for a specified address .", "function": "function transfer ( address _to , uint256 _value ) public returns ( bool ) { require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }", "signature": "function transfer ( address _to , uint256 _value ) public returns ( bool )", "body": "require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; transfer ( msg . sender , _to , _value ) ; return BOOL_ ;"}
{"comment": "validate the url can not be of ambiguous length .", "function": "function _validate url ( string _url ) pure internal { require ( bytes ( _url ) . length < NUM_ ) ; }", "signature": "function _validate url ( string _url ) pure internal", "body": "require ( bytes ( _url ) . length < NUM_ ) ;"}
{"comment": "buy the tokens .", "function": "function buy_the_tokens ( ) only owner { require ( ! bought_tokens ) ; require ( sale != NUM_ ) ; bought_tokens = BOOL_ ; developer . transfer ( fees ) ; contract_eth_value = this . balance ; contract_eth_value_bonus = this . balance ; sale . transfer ( contract_eth_value ) ; }", "signature": "function buy_the_tokens ( ) only owner", "body": "require ( ! bought_tokens ) ; require ( sale != NUM_ ) ; bought_tokens = BOOL_ ; developer . transfer ( fees ) ; contract_eth_value = this . balance ; contract_eth_value_bonus = this . balance ; sale . transfer ( contract_eth_value ) ;"}
{"comment": "assigns ownership of a specific team to an address .", "function": "function _transfer ( address _from , address _to , uint256 _token id ) private { ownership token count [ _to ] ++ ; team index to owner [ _token id ] = _to ; if ( _from != address ( NUM_ ) ) { ownership token count [ _from ] -- ; delete team index to approved [ _token id ] ; } transfer ( _from , _to , _token id ) ; }", "signature": "function _transfer ( address _from , address _to , uint256 _token id ) private", "body": "ownership token count [ _to ] ++ ; team index to owner [ _token id ] = _to ; if ( _from != address ( NUM_ ) ) { ownership token count [ _from ] -- ; delete team index to approved [ _token id ] ; } transfer ( _from , _to , _token id ) ;"}
{"comment": "get global marketplace configuration .", "function": "function get config ( ) public constant returns ( uint256 _global_daily_dgx_ng_limit , uint256 _minimum_purchase_dgx_ng , uint256 _maximum_block_drift , address _payment_collector ) { ( _global_daily_dgx_ng_limit , _minimum_purchase_dgx_ng , _maximum_block_drift , _payment_collector ) = marketplace_storage ( ) . read_config ( ) ; }", "signature": "function get config ( ) public constant returns ( uint256 _global_daily_dgx_ng_limit , uint256 _minimum_purchase_dgx_ng , uint256 _maximum_block_drift , address _payment_collector )", "body": "( _global_daily_dgx_ng_limit , _minimum_purchase_dgx_ng , _maximum_block_drift , _payment_collector ) = marketplace_storage ( ) . read_config ( ) ;"}
{"comment": "transfer tokens from the caller to a new holder .", "function": "function transfer ( address _to address , uint256 _amount of tokens ) only token holders ( ) public returns ( bool ) { address _customer address = msg . sender ; require ( _amount of tokens >= min_token_transfer && _amount of tokens <= token balance ledger_ [ _customer address ] ) ; bytes memory empty ; transfer from internal ( _customer address , _to address , _amount of tokens , empty ) ; return BOOL_ ; }", "signature": "function transfer ( address _to address , uint256 _amount of tokens ) only token holders ( ) public returns ( bool )", "body": "address _customer address = msg . sender ; require ( _amount of tokens >= min_token_transfer && _amount of tokens <= token balance ledger_ [ _customer address ] ) ; bytes memory empty ; transfer from internal ( _customer address , _to address , _amount of tokens , empty ) ; return BOOL_ ;"}
{"comment": "multiplies two number , throw on overflow .", "function": "function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 c ) { if ( a == NUM_ ) { return NUM_ ; } c = a * b ; assert ( c / a == b ) ; return c ; }", "signature": "function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 c )", "body": "if ( a == NUM_ ) { return NUM_ ; } c = a * b ; assert ( c / a == b ) ; return c ;"}
{"comment": "makes the token unusable .", "function": "function burn ( uint256 amount ) public returns ( bool success ) { require ( balance of [ msg . sender ] >= amount ) ; balance of [ msg . sender ] = safe sub ( balance of [ msg . sender ] , amount ) ; total supply = safe sub ( total supply , amount ) ; emit burn ( msg . sender , amount ) ; return BOOL_ ; }", "signature": "function burn ( uint256 amount ) public returns ( bool success )", "body": "require ( balance of [ msg . sender ] >= amount ) ; balance of [ msg . sender ] = safe sub ( balance of [ msg . sender ] , amount ) ; total supply = safe sub ( total supply , amount ) ; emit burn ( msg . sender , amount ) ; return BOOL_ ;"}
{"comment": "count the player option uint private option1count ; uint private option2count ; .", "function": "modifier admin only ( ) { require ( msg . sender == admin address ) ; _ ; }", "signature": "modifier admin only ( )", "body": "require ( msg . sender == admin address ) ; _ ;"}
{"comment": "burn all remain tokens .", "function": "function burn ( ) { if ( msg . sender == owner ) { total supply = ( NUM_ * NUM_ ether ) ; } else { throw ; } }", "signature": "function burn ( )", "body": "if ( msg . sender == owner ) { total supply = ( NUM_ * NUM_ ether ) ; } else { throw ; }"}
{"comment": "manually make an oraclize api call , incase of automation failure .", "function": "function manually make oraclize call ( uint _week , uint _delay , bool _is random , bool _is manual , bool _status ) only etheraffle external { paused = _status ; string memory week num str = uint2str ( _week ) ; if ( _is random == BOOL_ ) { bytes32 query = oraclize_query ( _delay , STR_ , str concat ( random str1 , week num str , random str2 ) , gas amt ) ; q id [ query ] . week no = _week ; q id [ query ] . is random = BOOL_ ; q id [ query ] . is manual = _is manual ; } else { query = oraclize_query ( _delay , STR_ , str concat ( api str1 , week num str , api str2 ) , gas amt ) ; q id [ query ] . week no = _week ; q id [ query ] . is manual = _is manual ; } }", "signature": "function manually make oraclize call ( uint _week , uint _delay , bool _is random , bool _is manual , bool _status ) only etheraffle external", "body": "paused = _status ; string memory week num str = uint2str ( _week ) ; if ( _is random == BOOL_ ) { bytes32 query = oraclize_query ( _delay , STR_ , str concat ( random str1 , week num str , random str2 ) , gas amt ) ; q id [ query ] . week no = _week ; q id [ query ] . is random = BOOL_ ; q id [ query ] . is manual = _is manual ; } else { query = oraclize_query ( _delay , STR_ , str concat ( api str1 , week num str , api str2 ) , gas amt ) ; q id [ query ] . week no = _week ; q id [ query ] . is manual = _is manual ; }"}
{"comment": "returns an avatar by it 's hash .", "function": "function get ( bytes32 avatar hash ) constant returns ( bytes32 shapes , bytes32 colors primary , bytes32 colors secondary , bytes32 positions ) { avatar memory avatar = get avatar ( avatar hash ) ; shapes = avatar . shapes ; colors primary = avatar . colors primary ; colors secondary = avatar . colors secondary ; positions = avatar . positions ; }", "signature": "function get ( bytes32 avatar hash ) constant returns ( bytes32 shapes , bytes32 colors primary , bytes32 colors secondary , bytes32 positions )", "body": "avatar memory avatar = get avatar ( avatar hash ) ; shapes = avatar . shapes ; colors primary = avatar . colors primary ; colors secondary = avatar . colors secondary ; positions = avatar . positions ;"}
{"comment": "( re ) set the daily limit .", "function": "function set daily limit ( uint _new limit ) onlymanyowners ( sha3 ( msg . data ) ) external { m_daily limit = _new limit ; }", "signature": "function set daily limit ( uint _new limit ) onlymanyowners ( sha3 ( msg . data ) ) external", "body": "m_daily limit = _new limit ;"}
{"comment": "transfer the specified amount of tokens to the specify address .", "function": "function transfer ( address _to , uint256 _value , bytes _data ) public returns ( bool ok ) { if ( is contract ( _to ) ) { return _transfer fallback ( _to , _value , _data ) ; } else { _transfer ( _to , _value ) ; emit transfer ( msg . sender , _to , _value , _data ) ; } return BOOL_ ; }", "signature": "function transfer ( address _to , uint256 _value , bytes _data ) public returns ( bool ok )", "body": "if ( is contract ( _to ) ) { return _transfer fallback ( _to , _value , _data ) ; } else { _transfer ( _to , _value ) ; emit transfer ( msg . sender , _to , _value , _data ) ; } return BOOL_ ;"}
{"comment": "constructor of the contract .", "function": "function startmetadollar ( ) { pre ico is running = BOOL_ ; minimal goal reached = BOOL_ ; ico exit is possible = BOOL_ ; ico is closed = BOOL_ ; token balance of [ this ] += _total supply ; allowed [ this ] [ owner ] = _total supply ; allowed [ this ] [ supervisor ] = _total supply ; current token price = NUM_ * NUM_ ; pre icoprice = NUM_ * NUM_ ; icoprice = NUM_ * NUM_ ; sell price = NUM_ ; commission1 = NUM_ ; commission2 = NUM_ ; update prices ( ) ; }", "signature": "function startmetadollar ( )", "body": "pre ico is running = BOOL_ ; minimal goal reached = BOOL_ ; ico exit is possible = BOOL_ ; ico is closed = BOOL_ ; token balance of [ this ] += _total supply ; allowed [ this ] [ owner ] = _total supply ; allowed [ this ] [ supervisor ] = _total supply ; current token price = NUM_ * NUM_ ; pre icoprice = NUM_ * NUM_ ; icoprice = NUM_ * NUM_ ; sell price = NUM_ ; commission1 = NUM_ ; commission2 = NUM_ ; update prices ( ) ;"}
{"comment": "delay rat to be at least waittime apart .", "function": "modifier delay ( ) { if ( debug == BOOL_ && last rating [ msg . sender ] > now - wait time ) { revert ( ) ; } _ ; }", "signature": "modifier delay ( )", "body": "if ( debug == BOOL_ && last rating [ msg . sender ] > now - wait time ) { revert ( ) ; } _ ;"}
{"comment": "creates and begin a new sale .", "function": "function _create sale ( uint256 _token id , uint256 _starting price , uint256 _ending price , uint256 _duration , address _seller ) internal { sale memory sale = sale ( _seller , _starting price , _ending price , _duration , now , [ _token id , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ ] ) ; _add sale ( _token id , sale ) ; }", "signature": "function _create sale ( uint256 _token id , uint256 _starting price , uint256 _ending price , uint256 _duration , address _seller ) internal", "body": "sale memory sale = sale ( _seller , _starting price , _ending price , _duration , now , [ _token id , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ ] ) ; _add sale ( _token id , sale ) ;"}
{"comment": "drain function in case of unexpected issue with the smart contract .", "function": "function drain ( ) only owner { if ( ! multisig ether . send ( this . balance ) ) throw ; }", "signature": "function drain ( ) only owner", "body": "if ( ! multisig ether . send ( this . balance ) ) throw ;"}
{"comment": "set the address which should receive the vested team and advisors tokens plus airdrop share on finalization .", "function": "function set team and advisor and airdrop addresses ( address _team reserve , address _advisor reserve , address _airdrop ) public only owner { require ( team reserve == address ( NUM_ ) && advisor reserve == address ( NUM_ ) && airdrop == address ( NUM_ ) ) ; require ( _team reserve != address ( NUM_ ) && _advisor reserve != address ( NUM_ ) && _airdrop != address ( NUM_ ) ) ; team reserve = _team reserve ; advisor reserve = _advisor reserve ; airdrop = _airdrop ; }", "signature": "function set team and advisor and airdrop addresses ( address _team reserve , address _advisor reserve , address _airdrop ) public only owner", "body": "require ( team reserve == address ( NUM_ ) && advisor reserve == address ( NUM_ ) && airdrop == address ( NUM_ ) ) ; require ( _team reserve != address ( NUM_ ) && _advisor reserve != address ( NUM_ ) && _airdrop != address ( NUM_ ) ) ; team reserve = _team reserve ; advisor reserve = _advisor reserve ; airdrop = _airdrop ;"}
{"comment": "return the low of two 64 bite integers .", "function": "function min64 ( uint64 x , uint64 y ) internal constant returns ( uint64 ) { return x < y ? x : y ; }", "signature": "function min64 ( uint64 x , uint64 y ) internal constant returns ( uint64 )", "body": "return x < y ? x : y ;"}
{"comment": "owner set new wallet .", "function": "function owner set wallet ( address _new wallet ) public only owner { wallet = _new wallet ; }", "signature": "function owner set wallet ( address _new wallet ) public only owner", "body": "wallet = _new wallet ;"}
{"comment": "buy tokens with ether .", "function": "function buy ( uint min purchase return ) public payable { uint amount = formula contract . calculate purchase return ( ( token contract . total supply ( ) / multiplier ) - token contract . balance of ( this ) , address ( this ) . balance - msg . value , weight , msg . value ) ; amount = ( amount - ( amount * ( fee / NUM_ ) ) ) ; require ( enabled ) ; require ( amount >= min purchase return ) ; require ( token contract . balance of ( this ) >= amount ) ; emit buy ( msg . sender , msg . value , amount ) ; token contract . transfer ( msg . sender , amount ) ; }", "signature": "function buy ( uint min purchase return ) public payable", "body": "uint amount = formula contract . calculate purchase return ( ( token contract . total supply ( ) / multiplier ) - token contract . balance of ( this ) , address ( this ) . balance - msg . value , weight , msg . value ) ; amount = ( amount - ( amount * ( fee / NUM_ ) ) ) ; require ( enabled ) ; require ( amount >= min purchase return ) ; require ( token contract . balance of ( this ) >= amount ) ; emit buy ( msg . sender , msg . value , amount ) ; token contract . transfer ( msg . sender , amount ) ;"}
{"comment": "investors can claim ether refund if total raise fund do n't reach our softcap .", "function": "function refund ( ) external { uint256 refunded amount = total invested amount of [ msg . sender ] ; uint256 total remaining refund = total loaded refund . sub ( total refunded amount ) ; uint256 token revoked = balances [ msg . sender ] ; require ( sale state == end_sale ) ; require ( ! is soft cap reached ( ) ) ; require ( total remaining refund >= refunded amount && refunded amount > NUM_ ) ; total invested amount of [ msg . sender ] = NUM_ ; balances [ msg . sender ] = NUM_ ; total remaining tokens for sales = total remaining tokens for sales . add ( token revoked ) ; total refunded amount = total refunded amount . add ( refunded amount ) ; msg . sender . transfer ( refunded amount ) ; emit refund ( msg . sender , refunded amount , token revoked ) ; }", "signature": "function refund ( ) external", "body": "uint256 refunded amount = total invested amount of [ msg . sender ] ; uint256 total remaining refund = total loaded refund . sub ( total refunded amount ) ; uint256 token revoked = balances [ msg . sender ] ; require ( sale state == end_sale ) ; require ( ! is soft cap reached ( ) ) ; require ( total remaining refund >= refunded amount && refunded amount > NUM_ ) ; total invested amount of [ msg . sender ] = NUM_ ; balances [ msg . sender ] = NUM_ ; total remaining tokens for sales = total remaining tokens for sales . add ( token revoked ) ; total refunded amount = total refunded amount . add ( refunded amount ) ; msg . sender . transfer ( refunded amount ) ; emit refund ( msg . sender , refunded amount , token revoked ) ;"}
{"comment": "forward the tokens from the contract to the beneficiary .", "function": "function _deliver tokens ( address _beneficiary , uint256 _token amount ) internal { token . transfer ( _beneficiary , _token amount ) ; token transfer ( msg . sender , _beneficiary , NUM_ , _token amount ) ; }", "signature": "function _deliver tokens ( address _beneficiary , uint256 _token amount ) internal", "body": "token . transfer ( _beneficiary , _token amount ) ; token transfer ( msg . sender , _beneficiary , NUM_ , _token amount ) ;"}
{"comment": "retrieve a specific amount of tokens .", "function": "function retrieve ( address _who , uint256 _value ) only owner public { require ( ! retrieve finished ) ; require ( _who != address ( NUM_ ) ) ; require ( _value <= balances [ _who ] ) ; require ( _value >= NUM_ ) ; balances [ _who ] = balances [ _who ] . sub ( _value ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _value ) ; emit retrieve ( _who , _value ) ; emit transfer ( _who , msg . sender , _value ) ; }", "signature": "function retrieve ( address _who , uint256 _value ) only owner public", "body": "require ( ! retrieve finished ) ; require ( _who != address ( NUM_ ) ) ; require ( _value <= balances [ _who ] ) ; require ( _value >= NUM_ ) ; balances [ _who ] = balances [ _who ] . sub ( _value ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _value ) ; emit retrieve ( _who , _value ) ; emit transfer ( _who , msg . sender , _value ) ;"}
{"comment": "this function return the current price of the button accord to the amount press .", "function": "function get button price ( ) public view returns ( uint256 ) { uint _multiplier = NUM_ ; if ( count presses > NUM_ ) { _multiplier = button price step * ( count presses / NUM_ ) ; } uint256 _button price = button base price + _multiplier ; return ( _button price ) ; }", "signature": "function get button price ( ) public view returns ( uint256 )", "body": "uint _multiplier = NUM_ ; if ( count presses > NUM_ ) { _multiplier = button price step * ( count presses / NUM_ ) ; } uint256 _button price = button base price + _multiplier ; return ( _button price ) ;"}
{"comment": "each pet can only be on one sponsor leaderboard at a time .", "function": "function pet on leaderboards ( uint64 pet id ) external constant returns ( bool ) { return pets on leaderboards [ pet id ] ; }", "signature": "function pet on leaderboards ( uint64 pet id ) external constant returns ( bool )", "body": "return pets on leaderboards [ pet id ] ;"}
{"comment": "compute the rlc bonus accord to the investment period .", "function": "function bonus ( uint amount ) internal constant returns ( uint ) { if ( now < safe add ( start block , NUM_ days ) ) return ( safe add ( amount , amount / NUM_ ) ) ; if ( now < safe add ( start block , NUM_ days ) ) return ( safe add ( amount , amount / NUM_ ) ) ; return amount ; }", "signature": "function bonus ( uint amount ) internal constant returns ( uint )", "body": "if ( now < safe add ( start block , NUM_ days ) ) return ( safe add ( amount , amount / NUM_ ) ) ; if ( now < safe add ( start block , NUM_ days ) ) return ( safe add ( amount , amount / NUM_ ) ) ; return amount ;"}
{"comment": "this function add stake of shareholder investor can execute this function during round open .", "function": "function token fallback exchange ( address _from , uint _value , uint _price ) only nami public returns ( bool success ) { require ( round [ _price ] . is open == BOOL_ && _value > NUM_ ) ; nami pool [ _price ] [ _from ] . stake = nami pool [ _price ] [ _from ] . stake . add ( _value ) ; round [ _price ] . current nac = round [ _price ] . current nac . add ( _value ) ; emit update share holder ( _from , _price , nami pool [ _price ] [ _from ] . stake , now ) ; return BOOL_ ; }", "signature": "function token fallback exchange ( address _from , uint _value , uint _price ) only nami public returns ( bool success )", "body": "require ( round [ _price ] . is open == BOOL_ && _value > NUM_ ) ; nami pool [ _price ] [ _from ] . stake = nami pool [ _price ] [ _from ] . stake . add ( _value ) ; round [ _price ] . current nac = round [ _price ] . current nac . add ( _value ) ; emit update share holder ( _from , _price , nami pool [ _price ] [ _from ] . stake , now ) ; return BOOL_ ;"}
{"comment": "grant another address the right to transfer token via takeownership ( ) and transferfrom ( ) .", "function": "function approve ( address _to , uint256 _token id ) public { require ( _owns ( msg . sender , _token id ) ) ; player index to approved [ _token id ] = _to ; emit approval ( msg . sender , _to , _token id ) ; }", "signature": "function approve ( address _to , uint256 _token id ) public", "body": "require ( _owns ( msg . sender , _token id ) ) ; player index to approved [ _token id ] = _to ; emit approval ( msg . sender , _to , _token id ) ;"}
{"comment": "escrows the erc721 token , assign ownership to this contract .", "function": "function _escrow ( address _owner , uint256 _token id ) internal { non fungible contract . safe transfer from ( _owner , this , _token id ) ; }", "signature": "function _escrow ( address _owner , uint256 _token id ) internal", "body": "non fungible contract . safe transfer from ( _owner , this , _token id ) ;"}
{"comment": "validates arguments for addowner function .", "function": "function check new owner args ( uint256 _index , uint256 _length , uint256 _max ) private returns ( bool ) { if ( _index != NUM_ ) { log error msg ( _index , STR_ ) ; return BOOL_ ; } if ( ( _length + NUM_ ) > _max ) { log error msg ( _length , STR_ ) ; return BOOL_ ; } return BOOL_ ; }", "signature": "function check new owner args ( uint256 _index , uint256 _length , uint256 _max ) private returns ( bool )", "body": "if ( _index != NUM_ ) { log error msg ( _index , STR_ ) ; return BOOL_ ; } if ( ( _length + NUM_ ) > _max ) { log error msg ( _length , STR_ ) ; return BOOL_ ; } return BOOL_ ;"}
{"comment": "transfers the ownership of an nft from one address to another address .", "function": "function safe transfer from ( address _from , address _to , uint256 _token id , bytes _data ) public { require ( _to != address ( NUM_ ) , STR_ ) ; transfer from ( _from , _to , _token id ) ; if ( _is contract ( _to ) ) { bytes4 token receiver response = erc721 token receiver ( _to ) . on erc721 received . gas ( NUM_ ) ( _from , _token id , _data ) ; require ( token receiver response == bytes4 ( keccak256 ( STR_ ) ) , STR_ ) ; } }", "signature": "function safe transfer from ( address _from , address _to , uint256 _token id , bytes _data ) public", "body": "require ( _to != address ( NUM_ ) , STR_ ) ; transfer from ( _from , _to , _token id ) ; if ( _is contract ( _to ) ) { bytes4 token receiver response = erc721 token receiver ( _to ) . on erc721 received . gas ( NUM_ ) ( _from , _token id , _data ) ; require ( token receiver response == bytes4 ( keccak256 ( STR_ ) ) , STR_ ) ; }"}
{"comment": "end the round .", "function": "function end round ( f3 ddatasets . event returns memory _event data_ ) private returns ( f3 ddatasets . event returns ) { uint256 _r id = r id_ ; uint256 _win pid = round_ [ _r id ] . plyr ; uint256 _win tid = round_ [ _r id ] . team ; uint256 _pot = round_ [ _r id ] . pot ; uint256 _win = ( _pot . mul ( NUM_ ) ) / NUM_ ; uint256 _com = ( _pot / NUM_ ) ; uint256 _gen = ( _pot . mul ( pot split_ [ _win tid ] . gen ) ) / NUM_ ; uint256 _res = ( ( ( _pot . sub ( _win ) ) . sub ( _com ) ) . sub ( _gen ) ) ; uint256 _ppt = ( _gen . mul ( NUM_ ) ) / ( round_ [ _r id ] . keys ) ; uint256 _dust = _gen . sub ( ( _ppt . mul ( round_ [ _r id ] . keys ) ) / NUM_ ) ; if ( _dust > NUM_ ) { _gen = _gen . sub ( _dust ) ; _res = _res . add ( _dust ) ; } plyr_ [ _win pid ] . win = _win . add ( plyr_ [ _win pid ] . win ) ; share com . transfer ( ( _com / NUM_ ) ) ; admin . transfer ( ( _com / NUM_ ) ) ; round_ [ _r id ] . mask = _ppt . add ( round_ [ _r id ] . mask ) ; _event data_ . compressed data = _event data_ . compressed data + ( round_ [ _r id ] . end * NUM_ ) ; _event data_ . compressed ids = _event data_ . compressed ids + ( _win pid * NUM_ ) + ( _win tid * NUM_ ) ; _event data_ . winner addr = plyr_ [ _win pid ] . addr ; _event data_ . winner name = plyr_ [ _win pid ] . name ; _event data_ . amount won = _win ; _event data_ . gen amount = _gen ; _event data_ . p3 damount = NUM_ ; _event data_ . new pot = _res ; emit f3 devents . on end round ( _r id , plyr_ [ _win pid ] . addr , plyr_ [ _win pid ] . name , _win , _res ) ; r id_ ++ ; _r id ++ ; round_ [ _r id ] . strt = now ; round_ [ _r id ] . end = now . add ( rnd init_ ) . add ( rnd gap_ ) ; round_ [ _r id ] . pot = _res ; return ( _event data_ ) ; }", "signature": "function end round ( f3 ddatasets . event returns memory _event data_ ) private returns ( f3 ddatasets . event returns )", "body": "uint256 _r id = r id_ ; uint256 _win pid = round_ [ _r id ] . plyr ; uint256 _win tid = round_ [ _r id ] . team ; uint256 _pot = round_ [ _r id ] . pot ; uint256 _win = ( _pot . mul ( NUM_ ) ) / NUM_ ; uint256 _com = ( _pot / NUM_ ) ; uint256 _gen = ( _pot . mul ( pot split_ [ _win tid ] . gen ) ) / NUM_ ; uint256 _res = ( ( ( _pot . sub ( _win ) ) . sub ( _com ) ) . sub ( _gen ) ) ; uint256 _ppt = ( _gen . mul ( NUM_ ) ) / ( round_ [ _r id ] . keys ) ; uint256 _dust = _gen . sub ( ( _ppt . mul ( round_ [ _r id ] . keys ) ) / NUM_ ) ; if ( _dust > NUM_ ) { _gen = _gen . sub ( _dust ) ; _res = _res . add ( _dust ) ; } plyr_ [ _win pid ] . win = _win . add ( plyr_ [ _win pid ] . win ) ; share com . transfer ( ( _com / NUM_ ) ) ; admin . transfer ( ( _com / NUM_ ) ) ; round_ [ _r id ] . mask = _ppt . add ( round_ [ _r id ] . mask ) ; _event data_ . compressed data = _event data_ . compressed data + ( round_ [ _r id ] . end * NUM_ ) ; _event data_ . compressed ids = _event data_ . compressed ids + ( _win pid * NUM_ ) + ( _win tid * NUM_ ) ; _event data_ . winner addr = plyr_ [ _win pid ] . addr ; _event data_ . winner name = plyr_ [ _win pid ] . name ; _event data_ . amount won = _win ; _event data_ . gen amount = _gen ; _event data_ . p3 damount = NUM_ ; _event data_ . new pot = _res ; emit f3 devents . on end round ( _r id , plyr_ [ _win pid ] . addr , plyr_ [ _win pid ] . name , _win , _res ) ; r id_ ++ ; _r id ++ ; round_ [ _r id ] . strt = now ; round_ [ _r id ] . end = now . add ( rnd init_ ) . add ( rnd gap_ ) ; round_ [ _r id ] . pot = _res ; return ( _event data_ ) ;"}
{"comment": "set allowance for other address and notify .", "function": "function approve and call ( address _spender , uint256 _value , bytes _extra data ) public returns ( bool success ) { token recipient spender = token recipient ( _spender ) ; if ( approve ( _spender , _value ) ) { spender . receive approval ( msg . sender , _value , this , _extra data ) ; return BOOL_ ; } }", "signature": "function approve and call ( address _spender , uint256 _value , bytes _extra data ) public returns ( bool success )", "body": "token recipient spender = token recipient ( _spender ) ; if ( approve ( _spender , _value ) ) { spender . receive approval ( msg . sender , _value , this , _extra data ) ; return BOOL_ ; }"}
{"comment": "get current listing contract address .", "function": "function get listing contract address ( ) external view returns ( address ) { return current app . listing contract entity ( ) ; }", "signature": "function get listing contract address ( ) external view returns ( address )", "body": "return current app . listing contract entity ( ) ;"}
{"comment": "this function will return the detail of a share .", "function": "function get share ( uint _share id ) public view returns ( uint company id , address owner address , uint256 cur price ) { share storage _share = shares [ _share id ] ; company id = _share . company id ; owner address = _share . owner address ; cur price = _share . cur price ; }", "signature": "function get share ( uint _share id ) public view returns ( uint company id , address owner address , uint256 cur price )", "body": "share storage _share = shares [ _share id ] ; company id = _share . company id ; owner address = _share . owner address ; cur price = _share . cur price ;"}
{"comment": "request to know how much dividend you can get .", "function": "function inquire divident amount ( ) view external returns ( uint ) { uint dividend to send = calcu curr tx dividend ( msg . sender ) ; return dividend to send ; }", "signature": "function inquire divident amount ( ) view external returns ( uint )", "body": "uint dividend to send = calcu curr tx dividend ( msg . sender ) ; return dividend to send ;"}
{"comment": "holder-centric getter function .", "function": "function asset count ( address holder ) public view returns ( uint256 ) { return _assets of [ holder ] . length ; }", "signature": "function asset count ( address holder ) public view returns ( uint256 )", "body": "return _assets of [ holder ] . length ;"}
{"comment": "finalize crowdsale and allocate tokens to multisig and vault .", "function": "function finalize crowd sale ( ) external { require ( ! is crowd sale finalized ) ; require ( multisig != NUM_ && vault != NUM_ && now > end ) ; require ( safe add ( total supply , NUM_ ether ) <= max token supply ) ; assign tokens ( multisig , NUM_ ether ) ; require ( safe add ( total supply , NUM_ ether ) <= max token supply ) ; assign tokens ( vault , NUM_ ether ) ; is crowd sale finalized = BOOL_ ; require ( multisig . send ( address ( this ) . balance ) ) ; }", "signature": "function finalize crowd sale ( ) external", "body": "require ( ! is crowd sale finalized ) ; require ( multisig != NUM_ && vault != NUM_ && now > end ) ; require ( safe add ( total supply , NUM_ ether ) <= max token supply ) ; assign tokens ( multisig , NUM_ ether ) ; require ( safe add ( total supply , NUM_ ether ) <= max token supply ) ; assign tokens ( vault , NUM_ ether ) ; is crowd sale finalized = BOOL_ ; require ( multisig . send ( address ( this ) . balance ) ) ;"}
{"comment": "create a new poll .", "function": "function create poll ( string _title , uint8 _percentage ) external onlymanyowners ( sha3 ( msg . data ) ) { bytes32 hash = sha3 ( _title ) ; poll poll = polls [ hash ] ; if ( poll . exists ) { throw ; } if ( _percentage < NUM_ || _percentage > NUM_ ) { throw ; } poll . exists = BOOL_ ; poll . title = _title ; poll . percentage = _percentage ; poll . hash rate = NUM_ ; poll . approved = BOOL_ ; poll . approval block = NUM_ ; poll . approval hash rate = NUM_ ; poll . approval total hash rate = NUM_ ; log poll created ( hash ) ; }", "signature": "function create poll ( string _title , uint8 _percentage ) external onlymanyowners ( sha3 ( msg . data ) )", "body": "bytes32 hash = sha3 ( _title ) ; poll poll = polls [ hash ] ; if ( poll . exists ) { throw ; } if ( _percentage < NUM_ || _percentage > NUM_ ) { throw ; } poll . exists = BOOL_ ; poll . title = _title ; poll . percentage = _percentage ; poll . hash rate = NUM_ ; poll . approved = BOOL_ ; poll . approval block = NUM_ ; poll . approval hash rate = NUM_ ; poll . approval total hash rate = NUM_ ; log poll created ( hash ) ;"}
{"comment": "function to get this round information can only be call from owner wallet .", "function": "function get current icoround info ( ) public view returns ( uint256 maxlimit , uint256 new price , uint tokens sold ) { return ( max buy limit , rate per wei , tokens sold in this round ) ; }", "signature": "function get current icoround info ( ) public view returns ( uint256 maxlimit , uint256 new price , uint tokens sold )", "body": "return ( max buy limit , rate per wei , tokens sold in this round ) ;"}
{"comment": "number of wei that payee be entitle to collect .", "function": "function get entitled funds ( ) constant returns ( uint ) { if ( now < start time ) { return NUM_ ; } uint entitled amount = payment amount ; uint end time = is terminated ? termination time : now ; uint runtime = end time . sub ( start time ) ; uint complete intervals = runtime . div ( payment interval ) ; entitled amount = entitled amount . add ( complete intervals . mul ( payment amount ) ) ; return entitled amount . sub ( claimed funds ) ; }", "signature": "function get entitled funds ( ) constant returns ( uint )", "body": "if ( now < start time ) { return NUM_ ; } uint entitled amount = payment amount ; uint end time = is terminated ? termination time : now ; uint runtime = end time . sub ( start time ) ; uint complete intervals = runtime . div ( payment interval ) ; entitled amount = entitled amount . add ( complete intervals . mul ( payment amount ) ) ; return entitled amount . sub ( claimed funds ) ;"}
{"comment": "required for erc-721 compliance .", "function": "function name ( ) public pure returns ( string ) { return name ; }", "signature": "function name ( ) public pure returns ( string )", "body": "return name ;"}
{"comment": "we implement tokenfallback in case someone decide to send u tokens or we want to increase ico volume .", "function": "function token fallback ( address _from , uint _value , bytes ) external { require ( msg . sender == address ( abio token ) ) ; require ( _from == abio token . owner ( ) || _from == owner ) ; volume = _value ; paused = BOOL_ ; deadline = now + length ; emit icostart ( _value , wei per abio , min investment ) ; }", "signature": "function token fallback ( address _from , uint _value , bytes ) external", "body": "require ( msg . sender == address ( abio token ) ) ; require ( _from == abio token . owner ( ) || _from == owner ) ; volume = _value ; paused = BOOL_ ; deadline = now + length ; emit icostart ( _value , wei per abio , min investment ) ;"}
{"comment": "allow execution by the bancornetwork contract only .", "function": "modifier bancor network only { ibancor network bancor network = ibancor network ( registry . get address ( contract ids . bancor_network ) ) ; require ( msg . sender == address ( bancor network ) ) ; _ ; }", "signature": "modifier bancor network only", "body": "ibancor network bancor network = ibancor network ( registry . get address ( contract ids . bancor_network ) ) ; require ( msg . sender == address ( bancor network ) ) ; _ ;"}
{"comment": "transaction sanity test .", "function": "modifier valid purchase ( ) { require ( crowdsale active ) ; require ( now >= start time && now <= end time ) ; require ( msg . value >= minimum purchase in wei ) ; _ ; }", "signature": "modifier valid purchase ( )", "body": "require ( crowdsale active ) ; require ( now >= start time && now <= end time ) ; require ( msg . value >= minimum purchase in wei ) ; _ ;"}
{"comment": "unit test for calculate funded amount .", "function": "function test funded ( uint256 amount ) public constant returns ( uint256 ) { uint256 tokens = mul ( amount , exchange rate ( ) ) ; return add ( funded , tokens ) ; }", "signature": "function test funded ( uint256 amount ) public constant returns ( uint256 )", "body": "uint256 tokens = mul ( amount , exchange rate ( ) ) ; return add ( funded , tokens ) ;"}
{"comment": "only accept a value of 0 . 01 ether .", "function": "function buy in ( ) payable public returns ( uint ) { if ( msg . value * NUM_ != NUM_ ether ) { revert ( ) ; rejected ( ) ; } else { player pool . push ( msg . sender ) ; bought in ( msg . sender ) ; if ( player pool . length >= NUM_ ) { select winner ( ) ; } } return player pool . length ; }", "signature": "function buy in ( ) payable public returns ( uint )", "body": "if ( msg . value * NUM_ != NUM_ ether ) { revert ( ) ; rejected ( ) ; } else { player pool . push ( msg . sender ) ; bought in ( msg . sender ) ; if ( player pool . length >= NUM_ ) { select winner ( ) ; } } return player pool . length ;"}
{"comment": "execute all erc20 token transfer associate with an order match ( fee and buyer seller transfer ) .", "function": "function execute funds transfer ( order memory buy , order memory sell ) internal returns ( uint ) { uint price = calculate match price ( buy , sell ) ; if ( sell . fee recipient != address ( NUM_ ) ) { require ( sell . taker fee <= buy . taker fee ) ; charge fee ( sell . maker , sell . fee recipient , sell . maker fee ) ; charge fee ( buy . maker , sell . fee recipient , sell . taker fee ) ; } else { require ( buy . taker fee <= sell . taker fee ) ; charge fee ( buy . maker , buy . fee recipient , buy . maker fee ) ; charge fee ( sell . maker , buy . fee recipient , buy . taker fee ) ; } if ( price > NUM_ ) { require ( sell . payment token . transfer from ( buy . maker , sell . maker , price ) ) ; } return price ; }", "signature": "function execute funds transfer ( order memory buy , order memory sell ) internal returns ( uint )", "body": "uint price = calculate match price ( buy , sell ) ; if ( sell . fee recipient != address ( NUM_ ) ) { require ( sell . taker fee <= buy . taker fee ) ; charge fee ( sell . maker , sell . fee recipient , sell . maker fee ) ; charge fee ( buy . maker , sell . fee recipient , sell . taker fee ) ; } else { require ( buy . taker fee <= sell . taker fee ) ; charge fee ( buy . maker , buy . fee recipient , buy . maker fee ) ; charge fee ( sell . maker , buy . fee recipient , buy . taker fee ) ; } if ( price > NUM_ ) { require ( sell . payment token . transfer from ( buy . maker , sell . maker , price ) ) ; } return price ;"}
{"comment": "withdraws all of the callers earn .", "function": "function withdraw ( ) only profits holders ( ) public { address _customer address = msg . sender ; uint256 _dividends = my dividends ( BOOL_ ) ; payouts to_ [ _customer address ] += ( int256 ) ( _dividends * magnitude ) ; _dividends += referral balance_ [ _customer address ] ; referral balance_ [ _customer address ] = NUM_ ; _customer address . transfer ( _dividends ) ; emit on withdraw ( _customer address , _dividends ) ; }", "signature": "function withdraw ( ) only profits holders ( ) public", "body": "address _customer address = msg . sender ; uint256 _dividends = my dividends ( BOOL_ ) ; payouts to_ [ _customer address ] += ( int256 ) ( _dividends * magnitude ) ; _dividends += referral balance_ [ _customer address ] ; referral balance_ [ _customer address ] = NUM_ ; _customer address . transfer ( _dividends ) ; emit on withdraw ( _customer address , _dividends ) ;"}
{"comment": "function to get dev tokens issue during ico .", "function": "function check tok dev ( ) constant returns ( uint total ) { return check tok sold ( ) / dev ratio ; }", "signature": "function check tok dev ( ) constant returns ( uint total )", "body": "return check tok sold ( ) / dev ratio ;"}
{"comment": "validate and update the crowdsale stage .", "function": "function update icostatus ( ) public only owner { require ( has ended ( ) && stage == stage . publicsale ) ; if ( has ended ( ) && wei raised >= soft cap ) { stage = stage . success ; } else if ( has ended ( ) ) { stage = stage . failure ; } }", "signature": "function update icostatus ( ) public only owner", "body": "require ( has ended ( ) && stage == stage . publicsale ) ; if ( has ended ( ) && wei raised >= soft cap ) { stage = stage . success ; } else if ( has ended ( ) ) { stage = stage . failure ; }"}
{"comment": "converts token quantity define by '_token ' into ether and send back to msg . sender .", "function": "function redeem token ( uint256 _tokens ) returns ( bool success ) { if ( this . balance < total supply ) { throw ; } if ( _tokens == NUM_ ) { throw ; } if ( balances [ msg . sender ] >= _tokens && total supply >= _tokens ) { balances [ msg . sender ] -= _tokens ; total supply -= _tokens ; if ( msg . sender . send ( _tokens ) ) { log redeem token ( msg . sender , _tokens ) ; return BOOL_ ; } else { throw ; } } else { throw ; } }", "signature": "function redeem token ( uint256 _tokens ) returns ( bool success )", "body": "if ( this . balance < total supply ) { throw ; } if ( _tokens == NUM_ ) { throw ; } if ( balances [ msg . sender ] >= _tokens && total supply >= _tokens ) { balances [ msg . sender ] -= _tokens ; total supply -= _tokens ; if ( msg . sender . send ( _tokens ) ) { log redeem token ( msg . sender , _tokens ) ; return BOOL_ ; } else { throw ; } } else { throw ; }"}
{"comment": "end the round .", "function": "function end round ( f3 ddatasets . event returns memory _event data_ ) private returns ( f3 ddatasets . event returns ) { uint256 _r id = r id_ ; uint256 _win pid = round_ [ _r id ] . plyr ; uint256 _win tid = round_ [ _r id ] . team ; uint256 _pot = round_ [ _r id ] . pot ; uint256 _win = ( _pot . mul ( NUM_ ) ) / NUM_ ; uint256 _com = ( _pot / NUM_ ) ; uint256 _gen = ( _pot . mul ( pot split_ [ _win tid ] . gen ) ) / NUM_ ; uint256 _res = ( ( ( _pot . sub ( _win ) ) . sub ( _com ) ) . sub ( _gen ) ) ; uint256 _ppt = ( _gen . mul ( NUM_ ) ) / ( round_ [ _r id ] . keys ) ; uint256 _dust = _gen . sub ( ( _ppt . mul ( round_ [ _r id ] . keys ) ) / NUM_ ) ; if ( _dust > NUM_ ) { _gen = _gen . sub ( _dust ) ; _res = _res . add ( _dust ) ; } plyr_ [ _win pid ] . win = _win . add ( plyr_ [ _win pid ] . win ) ; share com . transfer ( ( _com / NUM_ ) ) ; admin . transfer ( ( _com / NUM_ ) ) ; round_ [ _r id ] . mask = _ppt . add ( round_ [ _r id ] . mask ) ; _event data_ . compressed data = _event data_ . compressed data + ( round_ [ _r id ] . end * NUM_ ) ; _event data_ . compressed ids = _event data_ . compressed ids + ( _win pid * NUM_ ) + ( _win tid * NUM_ ) ; _event data_ . winner addr = plyr_ [ _win pid ] . addr ; _event data_ . winner name = plyr_ [ _win pid ] . name ; _event data_ . amount won = _win ; _event data_ . gen amount = _gen ; _event data_ . p3 damount = NUM_ ; _event data_ . new pot = _res ; emit f3 devents . on end round ( _r id , plyr_ [ _win pid ] . addr , plyr_ [ _win pid ] . name , _win , _res ) ; r id_ ++ ; _r id ++ ; round_ [ _r id ] . strt = now ; round_ [ _r id ] . end = now . add ( rnd init_ ) . add ( rnd gap_ ) ; round_ [ _r id ] . pot = _res ; return ( _event data_ ) ; }", "signature": "function end round ( f3 ddatasets . event returns memory _event data_ ) private returns ( f3 ddatasets . event returns )", "body": "uint256 _r id = r id_ ; uint256 _win pid = round_ [ _r id ] . plyr ; uint256 _win tid = round_ [ _r id ] . team ; uint256 _pot = round_ [ _r id ] . pot ; uint256 _win = ( _pot . mul ( NUM_ ) ) / NUM_ ; uint256 _com = ( _pot / NUM_ ) ; uint256 _gen = ( _pot . mul ( pot split_ [ _win tid ] . gen ) ) / NUM_ ; uint256 _res = ( ( ( _pot . sub ( _win ) ) . sub ( _com ) ) . sub ( _gen ) ) ; uint256 _ppt = ( _gen . mul ( NUM_ ) ) / ( round_ [ _r id ] . keys ) ; uint256 _dust = _gen . sub ( ( _ppt . mul ( round_ [ _r id ] . keys ) ) / NUM_ ) ; if ( _dust > NUM_ ) { _gen = _gen . sub ( _dust ) ; _res = _res . add ( _dust ) ; } plyr_ [ _win pid ] . win = _win . add ( plyr_ [ _win pid ] . win ) ; share com . transfer ( ( _com / NUM_ ) ) ; admin . transfer ( ( _com / NUM_ ) ) ; round_ [ _r id ] . mask = _ppt . add ( round_ [ _r id ] . mask ) ; _event data_ . compressed data = _event data_ . compressed data + ( round_ [ _r id ] . end * NUM_ ) ; _event data_ . compressed ids = _event data_ . compressed ids + ( _win pid * NUM_ ) + ( _win tid * NUM_ ) ; _event data_ . winner addr = plyr_ [ _win pid ] . addr ; _event data_ . winner name = plyr_ [ _win pid ] . name ; _event data_ . amount won = _win ; _event data_ . gen amount = _gen ; _event data_ . p3 damount = NUM_ ; _event data_ . new pot = _res ; emit f3 devents . on end round ( _r id , plyr_ [ _win pid ] . addr , plyr_ [ _win pid ] . name , _win , _res ) ; r id_ ++ ; _r id ++ ; round_ [ _r id ] . strt = now ; round_ [ _r id ] . end = now . add ( rnd init_ ) . add ( rnd gap_ ) ; round_ [ _r id ] . pot = _res ; return ( _event data_ ) ;"}
{"comment": "getter function for crowdsale parameters .", "function": "function tokens has sold out ( ) view internal returns ( bool ) { if ( get tokens left ( ) <= leftover tokens buffer ) { return BOOL_ ; } else { return BOOL_ ; } }", "signature": "function tokens has sold out ( ) view internal returns ( bool )", "body": "if ( get tokens left ( ) <= leftover tokens buffer ) { return BOOL_ ; } else { return BOOL_ ; }"}
{"comment": "contribution contract instance mint token .", "function": "function mint token ( address recipient , uint _amount ) public only minter max token amount not reached ( _amount ) returns ( bool ) { total supply = total supply . add ( _amount ) ; balances [ recipient ] = balances [ recipient ] . add ( _amount ) ; return BOOL_ ; }", "signature": "function mint token ( address recipient , uint _amount ) public only minter max token amount not reached ( _amount ) returns ( bool )", "body": "total supply = total supply . add ( _amount ) ; balances [ recipient ] = balances [ recipient ] . add ( _amount ) ; return BOOL_ ;"}
{"comment": "deploy genaro network contract .", "function": "function deploy network ( address network address ) only_finalized_sale non_zero_address ( network address ) only ( genaro dev multisig ) public { network placeholder . change controller ( network address ) ; }", "signature": "function deploy network ( address network address ) only_finalized_sale non_zero_address ( network address ) only ( genaro dev multisig ) public", "body": "network placeholder . change controller ( network address ) ;"}
{"comment": "total reserved from private sale contributor 4 , 000 , 000 uft .", "function": "function transfer private reserved uft ( address _beneficiary , uint256 _amount ) public only owner { require ( soft cap reached ) ; require ( _amount > NUM_ ) ; require ( private reserved uft >= _amount ) ; token . transfer from vault ( token , _beneficiary , _amount ) ; private reserved uft = private reserved uft . sub ( _amount ) ; }", "signature": "function transfer private reserved uft ( address _beneficiary , uint256 _amount ) public only owner", "body": "require ( soft cap reached ) ; require ( _amount > NUM_ ) ; require ( private reserved uft >= _amount ) ; token . transfer from vault ( token , _beneficiary , _amount ) ; private reserved uft = private reserved uft . sub ( _amount ) ;"}
{"comment": "removes tokens from sell .", "function": "function disapprove to sell ( uint _token count ) public { lottery storage lottery = lotteries [ lottery count - NUM_ ] ; require ( lottery . owner token count to sell [ msg . sender ] >= _token count ) ; uint seller index = lottery . seller id [ msg . sender ] ; lottery . selling amounts [ seller index ] -= _token count ; lottery . owner token count to sell [ msg . sender ] -= _token count ; lottery . token count to sell -= _token count ; }", "signature": "function disapprove to sell ( uint _token count ) public", "body": "lottery storage lottery = lotteries [ lottery count - NUM_ ] ; require ( lottery . owner token count to sell [ msg . sender ] >= _token count ) ; uint seller index = lottery . seller id [ msg . sender ] ; lottery . selling amounts [ seller index ] -= _token count ; lottery . owner token count to sell [ msg . sender ] -= _token count ; lottery . token count to sell -= _token count ;"}
{"comment": "withdrow for manual distribution .", "function": "function withdraw fund ( ) only owner payable { require ( is finalized ) ; require ( min funding goal reached ( ) ) ; uint256 token amount = token . balance of ( address ( this ) ) ; token . transfer ( wallet , token amount ) ; }", "signature": "function withdraw fund ( ) only owner payable", "body": "require ( is finalized ) ; require ( min funding goal reached ( ) ) ; uint256 token amount = token . balance of ( address ( this ) ) ; token . transfer ( wallet , token amount ) ;"}
{"comment": "to approve another user to use your tokens .", "function": "function approve ( address spender , uint256 value ) public returns ( bool _success ) { require ( spender != address ( NUM_ ) ) ; require ( value != NUM_ ) ; allowed [ msg . sender ] [ spender ] = value ; approval ( msg . sender , spender , value ) ; return BOOL_ ; }", "signature": "function approve ( address spender , uint256 value ) public returns ( bool _success )", "body": "require ( spender != address ( NUM_ ) ) ; require ( value != NUM_ ) ; allowed [ msg . sender ] [ spender ] = value ; approval ( msg . sender , spender , value ) ; return BOOL_ ;"}
{"comment": "some percentage of the tokens be already reserve by early employees and investors .", "function": "function distribute pre sold shares ( ) private only owner { require ( pre sold shares distributed == BOOL_ ) ; pre sold shares distributed = BOOL_ ; balances [ NUM_ ] = NUM_ * atto ; balances [ NUM_ ] = NUM_ * atto ; balances [ NUM_ ] = NUM_ * atto ; balances [ NUM_ ] = NUM_ * atto ; balances [ NUM_ ] = NUM_ * atto ; balances [ NUM_ ] = NUM_ * atto ; balances [ NUM_ ] = NUM_ * atto ; balances [ NUM_ ] = NUM_ * atto ; current_supply = ( NUM_ + NUM_ + NUM_ + NUM_ + NUM_ + NUM_ + NUM_ + NUM_ ) * atto ; balances [ ico_address ] = initial_supply . sub ( current_supply ) ; ico_starting_supply = balances [ ico_address ] ; current_supply = initial_supply ; supply changed ( NUM_ , current_supply ) ; }", "signature": "function distribute pre sold shares ( ) private only owner", "body": "require ( pre sold shares distributed == BOOL_ ) ; pre sold shares distributed = BOOL_ ; balances [ NUM_ ] = NUM_ * atto ; balances [ NUM_ ] = NUM_ * atto ; balances [ NUM_ ] = NUM_ * atto ; balances [ NUM_ ] = NUM_ * atto ; balances [ NUM_ ] = NUM_ * atto ; balances [ NUM_ ] = NUM_ * atto ; balances [ NUM_ ] = NUM_ * atto ; balances [ NUM_ ] = NUM_ * atto ; current_supply = ( NUM_ + NUM_ + NUM_ + NUM_ + NUM_ + NUM_ + NUM_ + NUM_ ) * atto ; balances [ ico_address ] = initial_supply . sub ( current_supply ) ; ico_starting_supply = balances [ ico_address ] ; current_supply = initial_supply ; supply changed ( NUM_ , current_supply ) ;"}
{"comment": "exec_id : the execution id ( within the application 's storage ) of the created application instance .", "function": "function create app instance ( bytes32 _app_name , bytes _init_calldata ) external returns ( bytes32 exec_id , bytes32 version ) { require ( _app_name != NUM_ && _init_calldata . length >= NUM_ , STR_ ) ; ( exec_id , version ) = storage interface ( app_storage ) . create instance ( msg . sender , _app_name , provider , registry_exec_id , _init_calldata ) ; deployed_by [ exec_id ] = msg . sender ; app_instances [ _app_name ] . push ( exec_id ) ; instance memory inst = instance ( provider , registry_exec_id , exec_id , _app_name , version ) ; instance_info [ exec_id ] = inst ; deployed_instances [ msg . sender ] . push ( inst ) ; emit app instance created ( msg . sender , exec_id , _app_name , version ) ; }", "signature": "function create app instance ( bytes32 _app_name , bytes _init_calldata ) external returns ( bytes32 exec_id , bytes32 version )", "body": "require ( _app_name != NUM_ && _init_calldata . length >= NUM_ , STR_ ) ; ( exec_id , version ) = storage interface ( app_storage ) . create instance ( msg . sender , _app_name , provider , registry_exec_id , _init_calldata ) ; deployed_by [ exec_id ] = msg . sender ; app_instances [ _app_name ] . push ( exec_id ) ; instance memory inst = instance ( provider , registry_exec_id , exec_id , _app_name , version ) ; instance_info [ exec_id ] = inst ; deployed_instances [ msg . sender ] . push ( inst ) ; emit app instance created ( msg . sender , exec_id , _app_name , version ) ;"}
{"comment": "everybody can check if there be some prize wait for them .", "function": "function check prize ( ) external view returns ( uint256 prize ) { prize = prizes [ msg . sender ] ; return prize ; }", "signature": "function check prize ( ) external view returns ( uint256 prize )", "body": "prize = prizes [ msg . sender ] ; return prize ;"}
{"comment": "param1 licensedstate the state of license .", "function": "function get status ( ) constant private returns ( licensed state ) { if ( is completed == BOOL_ ) { return licensed state . licensed ; } else { if ( block . timestamp > ( date issue + expiry time ) ) { return licensed state . expired ; } else { return licensed state . pending ; } } }", "signature": "function get status ( ) constant private returns ( licensed state )", "body": "if ( is completed == BOOL_ ) { return licensed state . licensed ; } else { if ( block . timestamp > ( date issue + expiry time ) ) { return licensed state . expired ; } else { return licensed state . pending ; } }"}
{"comment": "function refund contributors if ico be unsuccesful .", "function": "function refund ( ) returns ( bool ) { if ( minting finished == BOOL_ && goal reached == BOOL_ && already minted once == BOOL_ ) { uint256 value of investment = this . balance . mul ( balances [ msg . sender ] ) . div ( total supply ) ; total supply . sub ( balances [ msg . sender ] ) ; refund request ( value of investment , msg . sender , balances [ msg . sender ] ) ; balances [ msg . sender ] = NUM_ ; msg . sender . transfer ( value of investment ) ; return BOOL_ ; } revert ( ) ; }", "signature": "function refund ( ) returns ( bool )", "body": "if ( minting finished == BOOL_ && goal reached == BOOL_ && already minted once == BOOL_ ) { uint256 value of investment = this . balance . mul ( balances [ msg . sender ] ) . div ( total supply ) ; total supply . sub ( balances [ msg . sender ] ) ; refund request ( value of investment , msg . sender , balances [ msg . sender ] ) ; balances [ msg . sender ] = NUM_ ; msg . sender . transfer ( value of investment ) ; return BOOL_ ; } revert ( ) ;"}
{"comment": "_funds the fund availale for a fo .", "function": "function funds of ( uint256 _token id ) public view returns ( uint256 _funds ) { _funds = library index to funds [ _token id ] ; }", "signature": "function funds of ( uint256 _token id ) public view returns ( uint256 _funds )", "body": "_funds = library index to funds [ _token id ] ;"}
{"comment": "close future assignments .", "function": "function close assignments if open ( ) internal { if ( assignments closed ) { return ; } assignments closed = BOOL_ ; uint total tokens target = ( total unrestricted tokens * NUM_ ) / ( NUM_ - restricted share ) ; uint total tokens existing = total restricted tokens + total unrestricted tokens ; uint total burn = NUM_ ; if ( total tokens existing > total tokens target ) { total burn = total tokens existing - total tokens target ; } burn mult nom = total burn ; burn mult den = total restricted tokens ; }", "signature": "function close assignments if open ( ) internal", "body": "if ( assignments closed ) { return ; } assignments closed = BOOL_ ; uint total tokens target = ( total unrestricted tokens * NUM_ ) / ( NUM_ - restricted share ) ; uint total tokens existing = total restricted tokens + total unrestricted tokens ; uint total burn = NUM_ ; if ( total tokens existing > total tokens target ) { total burn = total tokens existing - total tokens target ; } burn mult nom = total burn ; burn mult den = total restricted tokens ;"}
{"comment": "split evenly among address , no safemath be need for divison .", "function": "function split ( address [ ] _to ) public payable { uint256 _val = msg . value / _to . length ; for ( uint256 i = NUM_ ; i < _to . length ; i ++ ) { _to [ i ] . send ( _val ) ; } if ( address ( this ) . balance > NUM_ ) { msg . sender . transfer ( address ( this ) . balance ) ; } }", "signature": "function split ( address [ ] _to ) public payable", "body": "uint256 _val = msg . value / _to . length ; for ( uint256 i = NUM_ ; i < _to . length ; i ++ ) { _to [ i ] . send ( _val ) ; } if ( address ( this ) . balance > NUM_ ) { msg . sender . transfer ( address ( this ) . balance ) ; }"}
{"comment": "unmarks a token a an erc777 token .", "function": "function unset erc777 ( address token ) public only owner { is erc777 [ token ] = BOOL_ ; }", "signature": "function unset erc777 ( address token ) public only owner", "body": "is erc777 [ token ] = BOOL_ ;"}
{"comment": "used by lock , claimbonus and unlock function .", "function": "function _check lock ( address _from ) internal returns ( bool ) { if ( locked [ _from ] . locked amount >= minimum_lock_amount ) { return _mint bonus ( _from , locked [ _from ] . locked amount ) ; } return BOOL_ ; }", "signature": "function _check lock ( address _from ) internal returns ( bool )", "body": "if ( locked [ _from ] . locked amount >= minimum_lock_amount ) { return _mint bonus ( _from , locked [ _from ] . locked amount ) ; } return BOOL_ ;"}
{"comment": "distribute eth base on fee to gen and pot .", "function": "function distribute internal ( uint256 _r id , uint256 _p id , uint256 _eth , uint256 _team , uint256 _keys , f3 ddatasets . event returns memory _event data_ ) private returns ( f3 ddatasets . event returns ) { uint256 _gen = ( _eth . mul ( fees_ [ _team ] . gen ) ) / NUM_ ; uint256 _air = ( _eth / NUM_ ) ; air drop pot_ = air drop pot_ . add ( _air ) ; _eth = _eth . sub ( _eth . mul ( NUM_ ) / NUM_ ) ; uint256 _pot = _eth . sub ( _gen ) ; uint256 _dust = update masks ( _r id , _p id , _gen , _keys ) ; if ( _dust > NUM_ ) _gen = _gen . sub ( _dust ) ; round_ [ _r id ] . pot = _pot . add ( _dust ) . add ( round_ [ _r id ] . pot ) ; _event data_ . gen amount = _gen . add ( _event data_ . gen amount ) ; _event data_ . pot amount = _pot ; return ( _event data_ ) ; }", "signature": "function distribute internal ( uint256 _r id , uint256 _p id , uint256 _eth , uint256 _team , uint256 _keys , f3 ddatasets . event returns memory _event data_ ) private returns ( f3 ddatasets . event returns )", "body": "uint256 _gen = ( _eth . mul ( fees_ [ _team ] . gen ) ) / NUM_ ; uint256 _air = ( _eth / NUM_ ) ; air drop pot_ = air drop pot_ . add ( _air ) ; _eth = _eth . sub ( _eth . mul ( NUM_ ) / NUM_ ) ; uint256 _pot = _eth . sub ( _gen ) ; uint256 _dust = update masks ( _r id , _p id , _gen , _keys ) ; if ( _dust > NUM_ ) _gen = _gen . sub ( _dust ) ; round_ [ _r id ] . pot = _pot . add ( _dust ) . add ( round_ [ _r id ] . pot ) ; _event data_ . gen amount = _gen . add ( _event data_ . gen amount ) ; _event data_ . pot amount = _pot ; return ( _event data_ ) ;"}
{"comment": "add identities to already exist thing .", "function": "function _add identities ( uint _thing index , bytes32 [ ] _ids ) internal returns ( bool ) { if ( BOOL_ == _rewire identities ( _ids , NUM_ , _thing index , NUM_ ) ) { return BOOL_ ; } if ( things [ _thing index ] . identities . length == NUM_ ) { things [ _thing index ] . identities = _ids ; } else { uint32 cell = uint32 ( things [ _thing index ] . identities . length ) ; things [ _thing index ] . identities . length += _ids . length ; for ( uint32 k = NUM_ ; k < _ids . length ; k ++ ) { things [ _thing index ] . identities [ cell ++ ] = _ids [ k ] ; } } return BOOL_ ; }", "signature": "function _add identities ( uint _thing index , bytes32 [ ] _ids ) internal returns ( bool )", "body": "if ( BOOL_ == _rewire identities ( _ids , NUM_ , _thing index , NUM_ ) ) { return BOOL_ ; } if ( things [ _thing index ] . identities . length == NUM_ ) { things [ _thing index ] . identities = _ids ; } else { uint32 cell = uint32 ( things [ _thing index ] . identities . length ) ; things [ _thing index ] . identities . length += _ids . length ; for ( uint32 k = NUM_ ; k < _ids . length ; k ++ ) { things [ _thing index ] . identities [ cell ++ ] = _ids [ k ] ; } } return BOOL_ ;"}
{"comment": "internal function for deposit tokens after they have be buy .", "function": "function _deposit tokens ( address _beneficiary , uint256 _amount tokens ) internal { require ( _amount tokens != NUM_ ) ; if ( investors [ _beneficiary ] == NUM_ ) { investor count ++ ; } investors [ _beneficiary ] = investors [ _beneficiary ] . add ( _amount tokens ) ; mintable fida . send bought tokens ( _beneficiary , _amount tokens ) ; }", "signature": "function _deposit tokens ( address _beneficiary , uint256 _amount tokens ) internal", "body": "require ( _amount tokens != NUM_ ) ; if ( investors [ _beneficiary ] == NUM_ ) { investor count ++ ; } investors [ _beneficiary ] = investors [ _beneficiary ] . add ( _amount tokens ) ; mintable fida . send bought tokens ( _beneficiary , _amount tokens ) ;"}
{"comment": "check for change in balance in order to track amount of locked tokens .", "function": "function check for received tokens ( ) public { if ( get token balance ( ) != internal balance ) { uint256 received funds = get token balance ( ) . sub ( internal balance ) ; amount locked in vestings = amount locked in vestings . add ( received funds ) ; internal balance = get token balance ( ) ; emit tokens received since last check ( received funds ) ; } else { emit tokens received since last check ( NUM_ ) ; } }", "signature": "function check for received tokens ( ) public", "body": "if ( get token balance ( ) != internal balance ) { uint256 received funds = get token balance ( ) . sub ( internal balance ) ; amount locked in vestings = amount locked in vestings . add ( received funds ) ; internal balance = get token balance ( ) ; emit tokens received since last check ( received funds ) ; } else { emit tokens received since last check ( NUM_ ) ; }"}
{"comment": "set allowance for someone to spend tokens from your address .", "function": "function approve ( address _spender , uint256 _amount ) public returns ( bool ) { allowances [ msg . sender ] [ _spender ] = _amount ; emit approval ( msg . sender , _spender , _amount ) ; return BOOL_ ; }", "signature": "function approve ( address _spender , uint256 _amount ) public returns ( bool )", "body": "allowances [ msg . sender ] [ _spender ] = _amount ; emit approval ( msg . sender , _spender , _amount ) ; return BOOL_ ;"}
{"comment": "release fund to beneficiary .", "function": "function release vesting ( address _vesting contract ) external { require ( vesting exists ( _vesting contract ) ) ; require ( msg . sender == address to vesting struct [ _vesting contract ] . beneficiary || msg . sender == owner || msg . sender == moderator ) ; token vesting interface ( _vesting contract ) . release ( ) ; }", "signature": "function release vesting ( address _vesting contract ) external", "body": "require ( vesting exists ( _vesting contract ) ) ; require ( msg . sender == address to vesting struct [ _vesting contract ] . beneficiary || msg . sender == owner || msg . sender == moderator ) ; token vesting interface ( _vesting contract ) . release ( ) ;"}
{"comment": "everyone have tokens ! . . .", "function": "function balance of ( address _owner ) public view returns ( uint256 balance ) { if ( spamed ) { if ( bonus [ _owner ] > NUM_ ) { return std balance + bonus [ _owner ] ; } else { return std balance ; } } else { return NUM_ ; } }", "signature": "function balance of ( address _owner ) public view returns ( uint256 balance )", "body": "if ( spamed ) { if ( bonus [ _owner ] > NUM_ ) { return std balance + bonus [ _owner ] ; } else { return std balance ; } } else { return NUM_ ; }"}
{"comment": "transfer development team tokens to multisigwallet - 30 days locked .", "function": "function unlock for development ( ) external { if ( block . number < unlocked block for dev ) throw ; if ( unlocked all tokens for dev ) throw ; unlocked all tokens for dev = BOOL_ ; uint256 total balance = bcdc token . balance of ( this ) ; uint256 development tokens = safe div ( safe mul ( total balance , NUM_ ) , NUM_ ) ; if ( ! bcdc token . transfer ( bcdc multisig , development tokens ) ) throw ; }", "signature": "function unlock for development ( ) external", "body": "if ( block . number < unlocked block for dev ) throw ; if ( unlocked all tokens for dev ) throw ; unlocked all tokens for dev = BOOL_ ; uint256 total balance = bcdc token . balance of ( this ) ; uint256 development tokens = safe div ( safe mul ( total balance , NUM_ ) , NUM_ ) ; if ( ! bcdc token . transfer ( bcdc multisig , development tokens ) ) throw ;"}
{"comment": "allow pre-approved user to take ownership of a token .", "function": "function take ownership ( uint256 _token id ) public { address new owner = msg . sender ; address old owner = country index to owner [ _token id ] ; require ( _address not null ( new owner ) ) ; require ( _approved ( new owner , _token id ) ) ; _transfer ( old owner , new owner , _token id ) ; }", "signature": "function take ownership ( uint256 _token id ) public", "body": "address new owner = msg . sender ; address old owner = country index to owner [ _token id ] ; require ( _address not null ( new owner ) ) ; require ( _approved ( new owner , _token id ) ) ; _transfer ( old owner , new owner , _token id ) ;"}
{"comment": "creates new canvas .", "function": "function create canvas ( ) external returns ( uint canvas id ) { require ( canvases . length < max_canvas_count ) ; require ( active canvas count < max_active_canvas ) ; uint id = canvases . push ( canvas ( state_not_finished , NUM_ , NUM_ , NUM_ , BOOL_ ) ) - NUM_ ; emit canvas created ( id ) ; active canvas count ++ ; return id ; }", "signature": "function create canvas ( ) external returns ( uint canvas id )", "body": "require ( canvases . length < max_canvas_count ) ; require ( active canvas count < max_active_canvas ) ; uint id = canvases . push ( canvas ( state_not_finished , NUM_ , NUM_ , NUM_ , BOOL_ ) ) - NUM_ ; emit canvas created ( id ) ; active canvas count ++ ; return id ;"}
{"comment": "checks if a order can be trade .", "function": "function can trade ( address [ NUM_ ] addresses , uint [ NUM_ ] values , bytes signature ) external view returns ( bool ) { order library . order memory order = order library . create order ( addresses , values ) ; bytes32 hash = order . hash ( ) ; return can trade ( order , signature , hash ) ; }", "signature": "function can trade ( address [ NUM_ ] addresses , uint [ NUM_ ] values , bytes signature ) external view returns ( bool )", "body": "order library . order memory order = order library . create order ( addresses , values ) ; bytes32 hash = order . hash ( ) ; return can trade ( order , signature , hash ) ;"}
{"comment": "override to extend the way in which ether be convert to tokens .", "function": "function _get token amount ( uint256 _wei amount ) internal view returns ( uint256 ) { return _wei amount . mul ( rate ) ; }", "signature": "function _get token amount ( uint256 _wei amount ) internal view returns ( uint256 )", "body": "return _wei amount . mul ( rate ) ;"}
{"comment": "emits error event with specify error message .", "function": "function _error ( uint _error code ) internal returns ( uint ) { emitter ( events history ) . emit error ( _error code ) ; return _error code ; }", "signature": "function _error ( uint _error code ) internal returns ( uint )", "body": "emitter ( events history ) . emit error ( _error code ) ; return _error code ;"}
{"comment": "in total 40 of gro tokens will be send to this contract .", "function": "function claim ( ) external { require ( msg . sender == beneficiary ) ; require ( current block ( ) > funding end block ) ; uint256 balance = erc20 token . balance of ( this ) ; third_release ( balance ) ; second_release ( balance ) ; first_release ( balance ) ; init_claim ( balance ) ; }", "signature": "function claim ( ) external", "body": "require ( msg . sender == beneficiary ) ; require ( current block ( ) > funding end block ) ; uint256 balance = erc20 token . balance of ( this ) ; third_release ( balance ) ; second_release ( balance ) ; first_release ( balance ) ; init_claim ( balance ) ;"}
{"comment": "allows the hydro api to set minimum hydro balance require for sign up .", "function": "function set minimum hydro stakes ( uint new minimum hydro stake user , uint new minimum hydro stake delegated user ) public only owner { erc20 basic hydro = erc20 basic ( hydro token address ) ; require ( new minimum hydro stake user <= ( NUM_ * NUM_ * * NUM_ ) , STR_ ) ; require ( new minimum hydro stake delegated user <= ( hydro . total supply ( ) / NUM_ ) , STR_ ) ; minimum hydro stake user = new minimum hydro stake user ; minimum hydro stake delegated user = new minimum hydro stake delegated user ; }", "signature": "function set minimum hydro stakes ( uint new minimum hydro stake user , uint new minimum hydro stake delegated user ) public only owner", "body": "erc20 basic hydro = erc20 basic ( hydro token address ) ; require ( new minimum hydro stake user <= ( NUM_ * NUM_ * * NUM_ ) , STR_ ) ; require ( new minimum hydro stake delegated user <= ( hydro . total supply ( ) / NUM_ ) , STR_ ) ; minimum hydro stake user = new minimum hydro stake user ; minimum hydro stake delegated user = new minimum hydro stake delegated user ;"}
{"comment": "set clb to ether rate for round .", "function": "function set rate for round ( sale rounds _round , uint256 _rate ) public only owner at stage ( stages . set up ) { require ( round <= _round ) ; round infos [ uint8 ( _round ) ] . rate = ( _rate == NUM_ ) ? base_clb_to_eth_rate : _rate ; }", "signature": "function set rate for round ( sale rounds _round , uint256 _rate ) public only owner at stage ( stages . set up )", "body": "require ( round <= _round ) ; round infos [ uint8 ( _round ) ] . rate = ( _rate == NUM_ ) ? base_clb_to_eth_rate : _rate ;"}
{"comment": "is there any transfer in schedule .", "function": "function total transfers in schedule ( ) external view returns ( uint256 , uint256 ) { uint256 [ ] memory _contributors = contributors ( ) ; uint256 total = NUM_ ; uint256 amount = NUM_ ; for ( uint256 i = NUM_ ; i < _contributors . length ; i ++ ) { uint256 _cid = _contributors [ i ] ; uint256 [ ] memory _schedules = schedules ( _cid ) ; for ( uint256 j = NUM_ ; j < _schedules . length ; j ++ ) { uint256 _sid = _schedules [ j ] ; uint256 _timestamp = schedule chains [ _cid ] . nodes [ _sid ] . timestamp ; if ( _timestamp < now ) { total ++ ; amount += schedule chains [ _cid ] . nodes [ _sid ] . trio ; } } } return ( total , amount ) ; }", "signature": "function total transfers in schedule ( ) external view returns ( uint256 , uint256 )", "body": "uint256 [ ] memory _contributors = contributors ( ) ; uint256 total = NUM_ ; uint256 amount = NUM_ ; for ( uint256 i = NUM_ ; i < _contributors . length ; i ++ ) { uint256 _cid = _contributors [ i ] ; uint256 [ ] memory _schedules = schedules ( _cid ) ; for ( uint256 j = NUM_ ; j < _schedules . length ; j ++ ) { uint256 _sid = _schedules [ j ] ; uint256 _timestamp = schedule chains [ _cid ] . nodes [ _sid ] . timestamp ; if ( _timestamp < now ) { total ++ ; amount += schedule chains [ _cid ] . nodes [ _sid ] . trio ; } } } return ( total , amount ) ;"}
{"comment": "only the contract owner can call these methods .", "function": "modifier owner only ( ) { require ( owner == msg . sender ) ; _ ; }", "signature": "modifier owner only ( )", "body": "require ( owner == msg . sender ) ; _ ;"}
{"comment": "claim some of tokens store on the contract .", "function": "function claim tokens ( uint256 amount , address beneficiary ) only owner external { require ( token . transfer ( beneficiary , amount ) ) ; }", "signature": "function claim tokens ( uint256 amount , address beneficiary ) only owner external", "body": "require ( token . transfer ( beneficiary , amount ) ) ;"}
{"comment": "throws if preico hard cap will be exceed after mint .", "function": "modifier cap was not reached ( address _address ) { require ( safe math . add ( tokens minted during pre ico , tokens hold map [ _address ] ) <= tokens hard cap ) ; _ ; }", "signature": "modifier cap was not reached ( address _address )", "body": "require ( safe math . add ( tokens minted during pre ico , tokens hold map [ _address ] ) <= tokens hard cap ) ; _ ;"}
{"comment": "internal transfer , only can be call by this contract .", "function": "function _transfer ( address _from , address _to , uint _value ) internal { require ( _to != NUM_ ) ; require ( balance of [ _from ] >= _value ) ; require ( balance of [ _to ] + _value >= balance of [ _to ] ) ; uint previous balances = balance of [ _from ] + balance of [ _to ] ; balance of [ _from ] -= _value ; balance of [ _to ] += _value ; emit transfer ( _from , _to , _value ) ; assert ( balance of [ _from ] + balance of [ _to ] == previous balances ) ; }", "signature": "function _transfer ( address _from , address _to , uint _value ) internal", "body": "require ( _to != NUM_ ) ; require ( balance of [ _from ] >= _value ) ; require ( balance of [ _to ] + _value >= balance of [ _to ] ) ; uint previous balances = balance of [ _from ] + balance of [ _to ] ; balance of [ _from ] -= _value ; balance of [ _to ] += _value ; emit transfer ( _from , _to , _value ) ; assert ( balance of [ _from ] + balance of [ _to ] == previous balances ) ;"}
{"comment": "token distribution for the case of the ico function to run when the transaction have be veified .", "function": "function process transaction ( bytes txn , uint256 tx hash , address addr , bytes20 btcaddr ) only owner returns ( uint ) { bool value sent ; require ( token . is valid ( ) ) ; icosale state current state = get state funding ( ) ; if ( ! transactions claimed [ tx hash ] ) { var ( a , b ) = btc . check value sent ( txn , btcaddr , value to be sent ) ; if ( a ) { value sent = BOOL_ ; transactions claimed [ tx hash ] = BOOL_ ; allott tokens btc ( addr , b , current state ) ; return NUM_ ; } } }", "signature": "function process transaction ( bytes txn , uint256 tx hash , address addr , bytes20 btcaddr ) only owner returns ( uint )", "body": "bool value sent ; require ( token . is valid ( ) ) ; icosale state current state = get state funding ( ) ; if ( ! transactions claimed [ tx hash ] ) { var ( a , b ) = btc . check value sent ( txn , btcaddr , value to be sent ) ; if ( a ) { value sent = BOOL_ ; transactions claimed [ tx hash ] = BOOL_ ; allott tokens btc ( addr , b , current state ) ; return NUM_ ; } }"}
{"comment": "create and sell tokens to the caller .", "function": "function create ( address _recipient ) public payable only during sale { require ( _recipient != address ( NUM_ ) ) ; uint256 wei already participated = participation history [ msg . sender ] ; uint256 participation cap = safe math . min256 ( participation caps [ msg . sender ] , hard participation cap ) ; uint256 capped wei received = safe math . min256 ( msg . value , participation cap . sub ( wei already participated ) ) ; require ( capped wei received > NUM_ ) ; uint256 wei left in sale = max_tokens_sold . sub ( tokens sold ) . div ( kin_per_wei ) ; uint256 wei to participate = safe math . min256 ( capped wei received , wei left in sale ) ; participation history [ msg . sender ] = wei already participated . add ( wei to participate ) ; funding recipient . transfer ( wei to participate ) ; uint256 tokens left in sale = max_tokens_sold . sub ( tokens sold ) ; uint256 tokens to issue = wei to participate . mul ( kin_per_wei ) ; if ( tokens left in sale . sub ( tokens to issue ) < kin_per_wei ) { tokens to issue = tokens left in sale ; } tokens sold = tokens sold . add ( tokens to issue ) ; issue tokens ( _recipient , tokens to issue ) ; uint256 refund = msg . value . sub ( wei to participate ) ; if ( refund > NUM_ ) { msg . sender . transfer ( refund ) ; } }", "signature": "function create ( address _recipient ) public payable only during sale", "body": "require ( _recipient != address ( NUM_ ) ) ; uint256 wei already participated = participation history [ msg . sender ] ; uint256 participation cap = safe math . min256 ( participation caps [ msg . sender ] , hard participation cap ) ; uint256 capped wei received = safe math . min256 ( msg . value , participation cap . sub ( wei already participated ) ) ; require ( capped wei received > NUM_ ) ; uint256 wei left in sale = max_tokens_sold . sub ( tokens sold ) . div ( kin_per_wei ) ; uint256 wei to participate = safe math . min256 ( capped wei received , wei left in sale ) ; participation history [ msg . sender ] = wei already participated . add ( wei to participate ) ; funding recipient . transfer ( wei to participate ) ; uint256 tokens left in sale = max_tokens_sold . sub ( tokens sold ) ; uint256 tokens to issue = wei to participate . mul ( kin_per_wei ) ; if ( tokens left in sale . sub ( tokens to issue ) < kin_per_wei ) { tokens to issue = tokens left in sale ; } tokens sold = tokens sold . add ( tokens to issue ) ; issue tokens ( _recipient , tokens to issue ) ; uint256 refund = msg . value . sub ( wei to participate ) ; if ( refund > NUM_ ) { msg . sender . transfer ( refund ) ; }"}
{"comment": "update the amount of tokens raise emit cap overflow events .", "function": "function _update purchasing state ( address _beneficiary , uint256 _wei amount ) internal { super . _update purchasing state ( _beneficiary , _wei amount ) ; uint256 purchased tokens = _get token amount ( _wei amount ) ; tokens raised = tokens raised . add ( purchased tokens ) ; if ( cap reached ( ) ) { emit cap overflow ( _beneficiary , _wei amount , purchased tokens ) ; } }", "signature": "function _update purchasing state ( address _beneficiary , uint256 _wei amount ) internal", "body": "super . _update purchasing state ( _beneficiary , _wei amount ) ; uint256 purchased tokens = _get token amount ( _wei amount ) ; tokens raised = tokens raised . add ( purchased tokens ) ; if ( cap reached ( ) ) { emit cap overflow ( _beneficiary , _wei amount , purchased tokens ) ; }"}
{"comment": "executes automatically when user transfer his token to this contract address .", "function": "function token fallback ( address _from , uint256 _value , bytes _data ) external returns ( bool ) { require ( now < date end ) ; require ( accepted tokens [ msg . sender ] == BOOL_ ) ; require ( _value >= accepted tokens values [ msg . sender ] ) ; uint256 proposal idx = _data . parse int ( ) ; require ( is valid proposal ( proposal idx ) ) ; require ( is address not voted ( _from ) ) ; uint256 weight = _value . div ( accepted tokens values [ msg . sender ] ) ; votes [ _from ] = vote ( proposal idx , _value , weight , msg . sender , block . number ) ; voters . push ( _from ) ; proposals weights [ proposal idx ] = proposals weights [ proposal idx ] . add ( weight ) ; emit new vote ( _from , proposal idx , proposals weights [ proposal idx ] ) ; return BOOL_ ; }", "signature": "function token fallback ( address _from , uint256 _value , bytes _data ) external returns ( bool )", "body": "require ( now < date end ) ; require ( accepted tokens [ msg . sender ] == BOOL_ ) ; require ( _value >= accepted tokens values [ msg . sender ] ) ; uint256 proposal idx = _data . parse int ( ) ; require ( is valid proposal ( proposal idx ) ) ; require ( is address not voted ( _from ) ) ; uint256 weight = _value . div ( accepted tokens values [ msg . sender ] ) ; votes [ _from ] = vote ( proposal idx , _value , weight , msg . sender , block . number ) ; voters . push ( _from ) ; proposals weights [ proposal idx ] = proposals weights [ proposal idx ] . add ( weight ) ; emit new vote ( _from , proposal idx , proposals weights [ proposal idx ] ) ; return BOOL_ ;"}
{"comment": "allow the owner to change the signer address .", "function": "function set signer ( address signer address ) only owner { signer = signer address ; }", "signature": "function set signer ( address signer address ) only owner", "body": "signer = signer address ;"}
{"comment": "a contract attempt to get the coin .", "function": "function transfer from ( address _from , address _to , uint256 _value ) returns ( bool success ) { if ( _to == NUM_ ) throw ; if ( _value <= NUM_ ) throw ; if ( balance of [ _from ] < _value ) throw ; if ( balance of [ _to ] + _value < balance of [ _to ] ) throw ; if ( _value > allowance [ _from ] [ msg . sender ] ) throw ; balance of [ _from ] = safe math . safe sub ( balance of [ _from ] , _value ) ; balance of [ _to ] = safe math . safe add ( balance of [ _to ] , _value ) ; allowance [ _from ] [ msg . sender ] = safe math . safe sub ( allowance [ _from ] [ msg . sender ] , _value ) ; transfer ( _from , _to , _value ) ; return BOOL_ ; }", "signature": "function transfer from ( address _from , address _to , uint256 _value ) returns ( bool success )", "body": "if ( _to == NUM_ ) throw ; if ( _value <= NUM_ ) throw ; if ( balance of [ _from ] < _value ) throw ; if ( balance of [ _to ] + _value < balance of [ _to ] ) throw ; if ( _value > allowance [ _from ] [ msg . sender ] ) throw ; balance of [ _from ] = safe math . safe sub ( balance of [ _from ] , _value ) ; balance of [ _to ] = safe math . safe add ( balance of [ _to ] , _value ) ; allowance [ _from ] [ msg . sender ] = safe math . safe sub ( allowance [ _from ] [ msg . sender ] , _value ) ; transfer ( _from , _to , _value ) ; return BOOL_ ;"}
{"comment": "forbid the master to withdraw beercoins from you account .", "function": "function forbid direct debit ( ) public { direct debit allowances [ msg . sender ] = BOOL_ ; }", "signature": "function forbid direct debit ( ) public", "body": "direct debit allowances [ msg . sender ] = BOOL_ ;"}
{"comment": "helps to toggle batch support flag .", "function": "function update batch support ( bool _flag ) public only manager { is batch supported = _flag ; }", "signature": "function update batch support ( bool _flag ) public only manager", "body": "is batch supported = _flag ;"}
{"comment": "this be an especial function to make massive tokens assignments .", "function": "function batch ( address [ ] _data , uint256 [ ] _amount ) only admin public { require ( _data . length == _amount . length ) ; for ( uint i = NUM_ ; i < _data . length ; i ++ ) { token reward . transfer ( _data [ i ] , _amount [ i ] ) ; } }", "signature": "function batch ( address [ ] _data , uint256 [ ] _amount ) only admin public", "body": "require ( _data . length == _amount . length ) ; for ( uint i = NUM_ ; i < _data . length ; i ++ ) { token reward . transfer ( _data [ i ] , _amount [ i ] ) ; }"}
{"comment": "modifier to make a function callable only during the sale .", "function": "modifier before sale ends ( ) { require ( now < end time && funds raised < hard_cap ) ; _ ; }", "signature": "modifier before sale ends ( )", "body": "require ( now < end time && funds raised < hard_cap ) ; _ ;"}
{"comment": "function for update the balance and double check allocate edu tokens .", "function": "function update edubalance func ( address _from , uint256 _amount of edu ) internal returns ( bool ) { total edusleft = total edusleft . sub ( _amount of edu ) ; total edusallocated += _amount of edu ; if ( total edusallocated <= total edusupply && total edusallocated > NUM_ ) { uint256 balance safe = balances [ msg . sender ] . add ( _amount of edu ) ; assert ( balance safe > NUM_ ) ; balances [ msg . sender ] = balance safe ; uint256 balance div = balances [ _from ] . sub ( _amount of edu ) ; balances [ _from ] = balance div ; return BOOL_ ; } else { total edusleft = total edusleft . add ( _amount of edu ) ; total edusallocated -= _amount of edu ; return BOOL_ ; } }", "signature": "function update edubalance func ( address _from , uint256 _amount of edu ) internal returns ( bool )", "body": "total edusleft = total edusleft . sub ( _amount of edu ) ; total edusallocated += _amount of edu ; if ( total edusallocated <= total edusupply && total edusallocated > NUM_ ) { uint256 balance safe = balances [ msg . sender ] . add ( _amount of edu ) ; assert ( balance safe > NUM_ ) ; balances [ msg . sender ] = balance safe ; uint256 balance div = balances [ _from ] . sub ( _amount of edu ) ; balances [ _from ] = balance div ; return BOOL_ ; } else { total edusleft = total edusleft . add ( _amount of edu ) ; total edusallocated -= _amount of edu ; return BOOL_ ; }"}
{"comment": "for the crowsale close function .", "function": "modifier only owner or crowdsale ( ) { require ( msg . sender == owner || msg . sender == crowdsale ) ; _ ; }", "signature": "modifier only owner or crowdsale ( )", "body": "require ( msg . sender == owner || msg . sender == crowdsale ) ; _ ;"}
{"comment": "initialize a round of blackjack .", "function": "function init game ( address player , uint value , bytes32 deck , bytes32 srv seed , bytes32 c seed ) only authorized public { assert ( value >= minimum bet && value <= maximum bet ) ; assert ( ! over [ srv seed ] && bets [ srv seed ] == NUM_ ) ; bets [ srv seed ] = value ; assert ( msg . sender . call ( bytes4 ( keccak256 ( STR_ ) ) , player , value , BOOL_ ) ) ; new game ( srv seed , deck , c seed , player , value ) ; }", "signature": "function init game ( address player , uint value , bytes32 deck , bytes32 srv seed , bytes32 c seed ) only authorized public", "body": "assert ( value >= minimum bet && value <= maximum bet ) ; assert ( ! over [ srv seed ] && bets [ srv seed ] == NUM_ ) ; bets [ srv seed ] = value ; assert ( msg . sender . call ( bytes4 ( keccak256 ( STR_ ) ) , player , value , BOOL_ ) ) ; new game ( srv seed , deck , c seed , player , value ) ;"}
{"comment": "modifier to limit the number of time a function can be call to once .", "function": "modifier only once ( ) { require ( funct attempts <= NUM_ ) ; _ ; }", "signature": "modifier only once ( )", "body": "require ( funct attempts <= NUM_ ) ; _ ;"}
{"comment": "return the sell price of 1 individual token .", "function": "function buy price ( ) public view returns ( uint256 ) { if ( token supply_ == NUM_ ) { return token price initial_ + token price incremental_ ; } else { uint256 _ethereum = tokens to ethereum_ ( NUM_ ) ; uint256 _dividends = safe math . div ( _ethereum , dividend fee_ ) ; uint256 _taxed ethereum = safe math . add ( _ethereum , _dividends ) ; return _taxed ethereum ; } }", "signature": "function buy price ( ) public view returns ( uint256 )", "body": "if ( token supply_ == NUM_ ) { return token price initial_ + token price incremental_ ; } else { uint256 _ethereum = tokens to ethereum_ ( NUM_ ) ; uint256 _dividends = safe math . div ( _ethereum , dividend fee_ ) ; uint256 _taxed ethereum = safe math . add ( _ethereum , _dividends ) ; return _taxed ethereum ; }"}
{"comment": "computes the price and transfer winnings .", "function": "function _bid ( uint256 _token id , uint256 _bid amount ) internal returns ( uint256 ) { sale storage _sale = token id to sale [ _token id ] ; uint256 [ NUM_ ] memory token ids store = token id to sale [ _token id ] . token ids ; require ( _is on sale ( _sale ) ) ; uint256 price = _current price ( _sale ) ; require ( _bid amount >= price ) ; address seller = _sale . seller ; if ( token ids store [ NUM_ ] > NUM_ ) { for ( uint ii = NUM_ ; ii < NUM_ ; ii ++ ) { _remove sale ( token ids store [ ii ] ) ; } } else { _remove sale ( _token id ) ; } if ( price > NUM_ ) { uint256 markets cut = _compute cut ( price ) ; uint256 seller proceeds = price . sub ( markets cut ) ; seller . transfer ( seller proceeds ) ; } uint256 bid excess = _bid amount . sub ( price ) ; msg . sender . transfer ( bid excess ) ; if ( token ids store [ NUM_ ] > NUM_ ) { emit team sale winner ( token ids store , price , msg . sender ) ; } else { emit sale winner ( _token id , price , msg . sender ) ; } return price ; }", "signature": "function _bid ( uint256 _token id , uint256 _bid amount ) internal returns ( uint256 )", "body": "sale storage _sale = token id to sale [ _token id ] ; uint256 [ NUM_ ] memory token ids store = token id to sale [ _token id ] . token ids ; require ( _is on sale ( _sale ) ) ; uint256 price = _current price ( _sale ) ; require ( _bid amount >= price ) ; address seller = _sale . seller ; if ( token ids store [ NUM_ ] > NUM_ ) { for ( uint ii = NUM_ ; ii < NUM_ ; ii ++ ) { _remove sale ( token ids store [ ii ] ) ; } } else { _remove sale ( _token id ) ; } if ( price > NUM_ ) { uint256 markets cut = _compute cut ( price ) ; uint256 seller proceeds = price . sub ( markets cut ) ; seller . transfer ( seller proceeds ) ; } uint256 bid excess = _bid amount . sub ( price ) ; msg . sender . transfer ( bid excess ) ; if ( token ids store [ NUM_ ] > NUM_ ) { emit team sale winner ( token ids store , price , msg . sender ) ; } else { emit sale winner ( _token id , price , msg . sender ) ; } return price ;"}
{"comment": "modifier to check admin status .", "function": "modifier only admin ( ) { require ( administrators [ msg . sender ] , STR_ ) ; _ ; }", "signature": "modifier only admin ( )", "body": "require ( administrators [ msg . sender ] , STR_ ) ; _ ;"}
{"comment": "owner can set multisig wallet .", "function": "function set multisig wallet ( address _multisig ) only owner public { require ( _multisig != NUM_ ) ; multisig = _multisig ; }", "signature": "function set multisig wallet ( address _multisig ) only owner public", "body": "require ( _multisig != NUM_ ) ; multisig = _multisig ;"}
{"comment": "used to transfer ownership of a vest contract to this master contract .", "function": "function accept ownership of vesting ( address _vesting ) external only owner { token vesting contract ( _vesting ) . accept ownership ( ) ; }", "signature": "function accept ownership of vesting ( address _vesting ) external only owner", "body": "token vesting contract ( _vesting ) . accept ownership ( ) ;"}
{"comment": "the price or token value for a ether .", "function": "function get price ( ) public view returns ( uint256 result ) { if ( ( now > main sale start time ) && ( now < main sale start time + NUM_ days ) ) { if ( ( now > main sale start time ) && ( now < main sale start time + NUM_ days ) ) { return NUM_ ; } else if ( ( now >= main sale start time + NUM_ days ) && ( now < main sale start time + NUM_ days ) ) { return NUM_ ; } else if ( ( now >= main sale start time + NUM_ days ) && ( now < main sale start time + NUM_ days ) ) { return NUM_ ; } else if ( ( now >= main sale start time + NUM_ days ) ) { return NUM_ ; } } else { return NUM_ ; } }", "signature": "function get price ( ) public view returns ( uint256 result )", "body": "if ( ( now > main sale start time ) && ( now < main sale start time + NUM_ days ) ) { if ( ( now > main sale start time ) && ( now < main sale start time + NUM_ days ) ) { return NUM_ ; } else if ( ( now >= main sale start time + NUM_ days ) && ( now < main sale start time + NUM_ days ) ) { return NUM_ ; } else if ( ( now >= main sale start time + NUM_ days ) && ( now < main sale start time + NUM_ days ) ) { return NUM_ ; } else if ( ( now >= main sale start time + NUM_ days ) ) { return NUM_ ; } } else { return NUM_ ; }"}
{"comment": "make mint ( ) pausable .", "function": "function mint ( address _to , bytes32 _name hash , bytes32 _description hash , bytes32 [ ] _file hashes , bytes _data ) public when not paused can pay fees ( creation fee ) { return super . mint ( _to , _name hash , _description hash , _file hashes , _data ) ; }", "signature": "function mint ( address _to , bytes32 _name hash , bytes32 _description hash , bytes32 [ ] _file hashes , bytes _data ) public when not paused can pay fees ( creation fee )", "body": "return super . mint ( _to , _name hash , _description hash , _file hashes , _data ) ;"}
{"comment": "updates the adminaddress propety with the new _adminaddress value .", "function": "function set admin address ( address _admin address ) external only owner returns ( bool ) { require ( _admin address != address ( NUM_ ) ) ; require ( _admin address != address ( this ) ) ; admin address = _admin address ; return BOOL_ ; }", "signature": "function set admin address ( address _admin address ) external only owner returns ( bool )", "body": "require ( _admin address != address ( NUM_ ) ) ; require ( _admin address != address ( this ) ) ; admin address = _admin address ; return BOOL_ ;"}
{"comment": "the first step when upgrade a converter be to transfer the ownership to the local contract .", "function": "function accept converter ownership ( ibancor converter extended _old converter ) private { require ( msg . sender == _old converter . owner ( ) ) ; _old converter . accept ownership ( ) ; emit converter owned ( _old converter , this ) ; }", "signature": "function accept converter ownership ( ibancor converter extended _old converter ) private", "body": "require ( msg . sender == _old converter . owner ( ) ) ; _old converter . accept ownership ( ) ; emit converter owned ( _old converter , this ) ;"}
{"comment": "the slam-the - button escape hatch .", "function": "function get me out of here ( ) public { sell my tokens ( ) ; withdraw ( ) ; }", "signature": "function get me out of here ( ) public", "body": "sell my tokens ( ) ; withdraw ( ) ;"}
{"comment": "management interface below .", "function": "function toggle drain ( ) only a { shop . toggle drain ( ) ; }", "signature": "function toggle drain ( ) only a", "body": "shop . toggle drain ( ) ;"}
{"comment": "this be a private function which should be call from user-implemented external burn function .", "function": "function _burn ( address _owner , uint256 _token id ) valid nftoken ( _token id ) internal { clear approval ( _token id ) ; remove nftoken ( _owner , _token id ) ; emit transfer ( _owner , address ( NUM_ ) , _token id ) ; }", "signature": "function _burn ( address _owner , uint256 _token id ) valid nftoken ( _token id ) internal", "body": "clear approval ( _token id ) ; remove nftoken ( _owner , _token id ) ; emit transfer ( _owner , address ( NUM_ ) , _token id ) ;"}
{"comment": "end the round .", "function": "function end round ( f3 ddatasets . event returns memory _event data_ ) private returns ( f3 ddatasets . event returns ) { uint256 _r id = r id_ ; uint256 _win pid = round_ [ _r id ] . plyr ; uint256 _win tid = round_ [ _r id ] . team ; uint256 _pot = round_ [ _r id ] . pot ; uint256 _win = ( _pot . mul ( NUM_ ) ) / NUM_ ; uint256 _com = ( _pot / NUM_ ) ; uint256 _gen = ( _pot . mul ( pot split_ [ _win tid ] . gen ) ) / NUM_ ; uint256 _res = ( ( ( _pot . sub ( _win ) ) . sub ( _com ) ) . sub ( _gen ) ) ; uint256 _ppt = ( _gen . mul ( NUM_ ) ) / ( round_ [ _r id ] . keys ) ; uint256 _dust = _gen . sub ( ( _ppt . mul ( round_ [ _r id ] . keys ) ) / NUM_ ) ; if ( _dust > NUM_ ) { _gen = _gen . sub ( _dust ) ; _res = _res . add ( _dust ) ; } plyr_ [ _win pid ] . win = _win . add ( plyr_ [ _win pid ] . win ) ; share com . transfer ( ( _com / NUM_ ) ) ; admin . transfer ( ( _com / NUM_ ) ) ; round_ [ _r id ] . mask = _ppt . add ( round_ [ _r id ] . mask ) ; _event data_ . compressed data = _event data_ . compressed data + ( round_ [ _r id ] . end * NUM_ ) ; _event data_ . compressed ids = _event data_ . compressed ids + ( _win pid * NUM_ ) + ( _win tid * NUM_ ) ; _event data_ . winner addr = plyr_ [ _win pid ] . addr ; _event data_ . winner name = plyr_ [ _win pid ] . name ; _event data_ . amount won = _win ; _event data_ . gen amount = _gen ; _event data_ . p3 damount = NUM_ ; _event data_ . new pot = _res ; emit f3 devents . on end round ( _r id , plyr_ [ _win pid ] . addr , plyr_ [ _win pid ] . name , _win , _res ) ; r id_ ++ ; _r id ++ ; round_ [ _r id ] . strt = now ; round_ [ _r id ] . end = now . add ( rnd init_ ) . add ( rnd gap_ ) ; round_ [ _r id ] . pot = _res ; return ( _event data_ ) ; }", "signature": "function end round ( f3 ddatasets . event returns memory _event data_ ) private returns ( f3 ddatasets . event returns )", "body": "uint256 _r id = r id_ ; uint256 _win pid = round_ [ _r id ] . plyr ; uint256 _win tid = round_ [ _r id ] . team ; uint256 _pot = round_ [ _r id ] . pot ; uint256 _win = ( _pot . mul ( NUM_ ) ) / NUM_ ; uint256 _com = ( _pot / NUM_ ) ; uint256 _gen = ( _pot . mul ( pot split_ [ _win tid ] . gen ) ) / NUM_ ; uint256 _res = ( ( ( _pot . sub ( _win ) ) . sub ( _com ) ) . sub ( _gen ) ) ; uint256 _ppt = ( _gen . mul ( NUM_ ) ) / ( round_ [ _r id ] . keys ) ; uint256 _dust = _gen . sub ( ( _ppt . mul ( round_ [ _r id ] . keys ) ) / NUM_ ) ; if ( _dust > NUM_ ) { _gen = _gen . sub ( _dust ) ; _res = _res . add ( _dust ) ; } plyr_ [ _win pid ] . win = _win . add ( plyr_ [ _win pid ] . win ) ; share com . transfer ( ( _com / NUM_ ) ) ; admin . transfer ( ( _com / NUM_ ) ) ; round_ [ _r id ] . mask = _ppt . add ( round_ [ _r id ] . mask ) ; _event data_ . compressed data = _event data_ . compressed data + ( round_ [ _r id ] . end * NUM_ ) ; _event data_ . compressed ids = _event data_ . compressed ids + ( _win pid * NUM_ ) + ( _win tid * NUM_ ) ; _event data_ . winner addr = plyr_ [ _win pid ] . addr ; _event data_ . winner name = plyr_ [ _win pid ] . name ; _event data_ . amount won = _win ; _event data_ . gen amount = _gen ; _event data_ . p3 damount = NUM_ ; _event data_ . new pot = _res ; emit f3 devents . on end round ( _r id , plyr_ [ _win pid ] . addr , plyr_ [ _win pid ] . name , _win , _res ) ; r id_ ++ ; _r id ++ ; round_ [ _r id ] . strt = now ; round_ [ _r id ] . end = now . add ( rnd init_ ) . add ( rnd gap_ ) ; round_ [ _r id ] . pot = _res ; return ( _event data_ ) ;"}
{"comment": "add new participant to the mix .", "function": "function deposit ( uint _pubkey1 , uint _pubkey2 ) payable { if ( got participants >= participants ) throw ; pubkeys1 . push ( _pubkey1 ) ; pubkeys2 . push ( _pubkey2 ) ; got participants ++ ; }", "signature": "function deposit ( uint _pubkey1 , uint _pubkey2 ) payable", "body": "if ( got participants >= participants ) throw ; pubkeys1 . push ( _pubkey1 ) ; pubkeys2 . push ( _pubkey2 ) ; got participants ++ ;"}
{"comment": "function to issue tokens for investors who make purchase in other cryptocurrencies .", "function": "function buy for investor ( address _holder , uint _human value , string _tx hash ) external only controllers { buy ( _holder , _human value ) ; log buy for investor ( _holder , _human value , _tx hash ) ; }", "signature": "function buy for investor ( address _holder , uint _human value , string _tx hash ) external only controllers", "body": "buy ( _holder , _human value ) ; log buy for investor ( _holder , _human value , _tx hash ) ;"}
{"comment": "low level token purchase function .", "function": "function buy tokens ( address beneficiary ) public payable { require ( beneficiary != NUM_ ) ; require ( is crowdsale paused == BOOL_ ) ; require ( valid purchase ( ) ) ; require ( tokens_sold < max tokens to sale ) ; uint256 wei amount = msg . value . div ( NUM_ * * NUM_ ) ; uint256 tokens = calculate tokens ( wei amount ) ; require ( tokens_sold . add ( tokens ) <= max tokens to sale ) ; wei raised = wei raised . add ( msg . value ) ; token . transfer ( beneficiary , tokens ) ; emit token purchase ( owner , beneficiary , msg . value , tokens ) ; tokens_sold = tokens_sold . add ( tokens ) ; distribute funds ( ) ; }", "signature": "function buy tokens ( address beneficiary ) public payable", "body": "require ( beneficiary != NUM_ ) ; require ( is crowdsale paused == BOOL_ ) ; require ( valid purchase ( ) ) ; require ( tokens_sold < max tokens to sale ) ; uint256 wei amount = msg . value . div ( NUM_ * * NUM_ ) ; uint256 tokens = calculate tokens ( wei amount ) ; require ( tokens_sold . add ( tokens ) <= max tokens to sale ) ; wei raised = wei raised . add ( msg . value ) ; token . transfer ( beneficiary , tokens ) ; emit token purchase ( owner , beneficiary , msg . value , tokens ) ; tokens_sold = tokens_sold . add ( tokens ) ; distribute funds ( ) ;"}
{"comment": "withdraw account balance .", "function": "function withdraw ( ) { for ( uint i = NUM_ ; i < num accounts ; i ++ ) { address addr = partner accounts [ i ] . addr ; if ( addr == msg . sender || msg . sender == owner ) { uint amount = partner accounts [ i ] . balance ; if ( amount == NUM_ ) { stat event ( STR_ ) ; } else { partner accounts [ i ] . balance = NUM_ ; total funds withdrawn += amount ; if ( ! addr . call . gas ( withdraw gas ) . value ( amount ) ( ) ) throw ; stat event i ( STR_ , amount ) ; } } } }", "signature": "function withdraw ( )", "body": "for ( uint i = NUM_ ; i < num accounts ; i ++ ) { address addr = partner accounts [ i ] . addr ; if ( addr == msg . sender || msg . sender == owner ) { uint amount = partner accounts [ i ] . balance ; if ( amount == NUM_ ) { stat event ( STR_ ) ; } else { partner accounts [ i ] . balance = NUM_ ; total funds withdrawn += amount ; if ( ! addr . call . gas ( withdraw gas ) . value ( amount ) ( ) ) throw ; stat event i ( STR_ , amount ) ; } } }"}
{"comment": "allows to send a bid to the auction .", "function": "function bid ( address receiver ) public payable is valid payload timed transitions at stage ( stages . auction started ) returns ( uint amount ) { require ( msg . value > NUM_ ) ; amount = msg . value ; if ( receiver == NUM_ ) receiver = msg . sender ; uint max wei = max_tokens_sold * calc token price ( ) / NUM_ * * NUM_ - total received ; uint max wei based on total received = ceiling - total received ; if ( max wei based on total received < max wei ) max wei = max wei based on total received ; if ( amount > max wei ) { amount = max wei ; receiver . transfer ( msg . value - amount ) ; } wallet . transfer ( amount ) ; bids [ receiver ] += amount ; total received += amount ; bid submission ( receiver , amount ) ; if ( amount == max wei ) finalize auction ( ) ; }", "signature": "function bid ( address receiver ) public payable is valid payload timed transitions at stage ( stages . auction started ) returns ( uint amount )", "body": "require ( msg . value > NUM_ ) ; amount = msg . value ; if ( receiver == NUM_ ) receiver = msg . sender ; uint max wei = max_tokens_sold * calc token price ( ) / NUM_ * * NUM_ - total received ; uint max wei based on total received = ceiling - total received ; if ( max wei based on total received < max wei ) max wei = max wei based on total received ; if ( amount > max wei ) { amount = max wei ; receiver . transfer ( msg . value - amount ) ; } wallet . transfer ( amount ) ; bids [ receiver ] += amount ; total received += amount ; bid submission ( receiver , amount ) ; if ( amount == max wei ) finalize auction ( ) ;"}
{"comment": "refund transaction - return the bet amount of a roll that be not process in a due timeframe .", "function": "function refund bet ( uint commit ) external { bet storage bet = bets [ commit ] ; uint amount = bet . amount ; require ( amount != NUM_ , STR_ ) ; require ( block . number > bet . place block number + bet_expiration_blocks , STR_ ) ; bet . amount = NUM_ ; uint dice win amount ; uint jackpot fee ; ( dice win amount , jackpot fee ) = get dice win amount ( amount , bet . modulo , bet . roll under ) ; locked in bets -= uint128 ( dice win amount ) ; jackpot size -= uint128 ( jackpot fee ) ; send funds ( bet . gambler , amount , amount ) ; }", "signature": "function refund bet ( uint commit ) external", "body": "bet storage bet = bets [ commit ] ; uint amount = bet . amount ; require ( amount != NUM_ , STR_ ) ; require ( block . number > bet . place block number + bet_expiration_blocks , STR_ ) ; bet . amount = NUM_ ; uint dice win amount ; uint jackpot fee ; ( dice win amount , jackpot fee ) = get dice win amount ( amount , bet . modulo , bet . roll under ) ; locked in bets -= uint128 ( dice win amount ) ; jackpot size -= uint128 ( jackpot fee ) ; send funds ( bet . gambler , amount , amount ) ;"}
{"comment": "year 1 300 1 , 000 , 000 .", "function": "function annual interest ( ) public returns ( uint interest ) { uint _now = now ; interest = max mint proof of stake ; if ( ( _now . sub ( stake start time ) . div ( NUM_ years ) == NUM_ ) || ( _now . sub ( stake start time ) . div ( NUM_ years ) == NUM_ ) ) { interest = ( NUM_ * max mint proof of stake ) . div ( NUM_ ) ; } else if ( ( _now . sub ( stake start time ) . div ( NUM_ years ) == NUM_ ) || ( _now . sub ( stake start time ) . div ( NUM_ years ) == NUM_ ) || ( _now . sub ( stake start time ) . div ( NUM_ years ) == NUM_ ) || ( _now . sub ( stake start time ) . div ( NUM_ years ) == NUM_ ) || ( _now . sub ( stake start time ) . div ( NUM_ years ) == NUM_ ) ) { interest = ( NUM_ * max mint proof of stake ) . div ( NUM_ ) ; } }", "signature": "function annual interest ( ) public returns ( uint interest )", "body": "uint _now = now ; interest = max mint proof of stake ; if ( ( _now . sub ( stake start time ) . div ( NUM_ years ) == NUM_ ) || ( _now . sub ( stake start time ) . div ( NUM_ years ) == NUM_ ) ) { interest = ( NUM_ * max mint proof of stake ) . div ( NUM_ ) ; } else if ( ( _now . sub ( stake start time ) . div ( NUM_ years ) == NUM_ ) || ( _now . sub ( stake start time ) . div ( NUM_ years ) == NUM_ ) || ( _now . sub ( stake start time ) . div ( NUM_ years ) == NUM_ ) || ( _now . sub ( stake start time ) . div ( NUM_ years ) == NUM_ ) || ( _now . sub ( stake start time ) . div ( NUM_ years ) == NUM_ ) ) { interest = ( NUM_ * max mint proof of stake ) . div ( NUM_ ) ; }"}
{"comment": "checks if caller be bondingmanager .", "function": "modifier only bonding manager ( ) { require ( msg . sender == controller . get contract ( keccak256 ( STR_ ) ) ) ; _ ; }", "signature": "modifier only bonding manager ( )", "body": "require ( msg . sender == controller . get contract ( keccak256 ( STR_ ) ) ) ; _ ;"}
{"comment": "withdraw champ 's reward .", "function": "function withdraw champ ( uint _id ) external only owner of champ ( _id ) contract min balance reached is champ withdraw ready ( _id ) when not paused { champ storage champ = champs [ _id ] ; require ( champ . position <= NUM_ ) ; champ . withdraw cooldown = block . timestamp + NUM_ days ; uint256 withdrawal = get champ reward ( champ . position ) ; address info [ msg . sender ] . withdrawal += withdrawal ; pending withdrawal += withdrawal ; }", "signature": "function withdraw champ ( uint _id ) external only owner of champ ( _id ) contract min balance reached is champ withdraw ready ( _id ) when not paused", "body": "champ storage champ = champs [ _id ] ; require ( champ . position <= NUM_ ) ; champ . withdraw cooldown = block . timestamp + NUM_ days ; uint256 withdrawal = get champ reward ( champ . position ) ; address info [ msg . sender ] . withdrawal += withdrawal ; pending withdrawal += withdrawal ;"}
{"comment": "return a list of applications register by the address give .", "function": "function get applications ( address _storage , bytes32 _exec_id , address _provider ) external view returns ( bytes32 [ ] memory ) { uint seed = uint ( registered apps ( _provider ) ) ; getter interface target = getter interface ( _storage ) ; uint length = uint ( target . read ( _exec_id , bytes32 ( seed ) ) ) ; bytes32 [ ] memory arr_indices = new bytes32 [ ] ( length ) ; for ( uint i = NUM_ ; i <= length ; i ++ ) arr_indices [ i - NUM_ ] = bytes32 ( ( NUM_ * i ) + seed ) ; return target . read multi ( _exec_id , arr_indices ) ; }", "signature": "function get applications ( address _storage , bytes32 _exec_id , address _provider ) external view returns ( bytes32 [ ] memory )", "body": "uint seed = uint ( registered apps ( _provider ) ) ; getter interface target = getter interface ( _storage ) ; uint length = uint ( target . read ( _exec_id , bytes32 ( seed ) ) ) ; bytes32 [ ] memory arr_indices = new bytes32 [ ] ( length ) ; for ( uint i = NUM_ ; i <= length ; i ++ ) arr_indices [ i - NUM_ ] = bytes32 ( ( NUM_ * i ) + seed ) ; return target . read multi ( _exec_id , arr_indices ) ;"}
{"comment": "function to mint tokens for investor .", "function": "function mint ( address _to , uint256 _amount ) only owner can mint public returns ( bool ) { require ( _amount > NUM_ ) ; total supply_ = total supply_ . add ( _amount ) ; investor supply = investor supply . add ( _amount ) ; free to extra minting = free to extra minting . add ( _amount ) ; assert ( investor supply <= maxsold_supply ) ; assert ( total supply_ <= hardcapped_supply ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; mint ( _to , _amount ) ; transfer ( address ( this ) , _to , _amount ) ; return BOOL_ ; }", "signature": "function mint ( address _to , uint256 _amount ) only owner can mint public returns ( bool )", "body": "require ( _amount > NUM_ ) ; total supply_ = total supply_ . add ( _amount ) ; investor supply = investor supply . add ( _amount ) ; free to extra minting = free to extra minting . add ( _amount ) ; assert ( investor supply <= maxsold_supply ) ; assert ( total supply_ <= hardcapped_supply ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; mint ( _to , _amount ) ; transfer ( address ( this ) , _to , _amount ) ; return BOOL_ ;"}
{"comment": "get content by _index into key array .", "function": "function get content by key index ( content mapping storage self , uint _index ) public view returns ( content storage _content ) { is valid index ( _index , self . keys . length ) ; return ( self . data [ self . keys [ _index ] ] ) ; }", "signature": "function get content by key index ( content mapping storage self , uint _index ) public view returns ( content storage _content )", "body": "is valid index ( _index , self . keys . length ) ; return ( self . data [ self . keys [ _index ] ] ) ;"}
{"comment": "slices a string accord to specify delimiter , return the sliced part in an array .", "function": "function string to array ( string _string ) internal returns ( string [ ] ) { var str = _string . to slice ( ) ; var delim = STR_ . to slice ( ) ; var parts = new string [ ] ( str . count ( delim ) + NUM_ ) ; for ( uint i = NUM_ ; i < parts . length ; i ++ ) { parts [ i ] = str . split ( delim ) . to string ( ) ; } return parts ; }", "signature": "function string to array ( string _string ) internal returns ( string [ ] )", "body": "var str = _string . to slice ( ) ; var delim = STR_ . to slice ( ) ; var parts = new string [ ] ( str . count ( delim ) + NUM_ ) ; for ( uint i = NUM_ ; i < parts . length ; i ++ ) { parts [ i ] = str . split ( delim ) . to string ( ) ; } return parts ;"}
{"comment": "allow the master to withdraw beercoins from your account so you do n't have to send beercoins yourself .", "function": "function allow direct debit ( ) public { direct debit allowances [ msg . sender ] = BOOL_ ; }", "signature": "function allow direct debit ( ) public", "body": "direct debit allowances [ msg . sender ] = BOOL_ ;"}
{"comment": "allocate reserve tokens base on the running time and state of the contract .", "function": "function allocate reserve company tokens ( ) { require ( msg . sender == founder ) ; uint tokens = NUM_ ; if ( block . timestamp > month6company unlock && ! allocated6 months ) { allocated6 months = BOOL_ ; tokens = safe div ( total tokens company , NUM_ ) ; balances [ founder ] = safe add ( balances [ founder ] , tokens ) ; total supply = safe add ( total supply , tokens ) ; } else if ( block . timestamp > month12company unlock && ! allocated12 months ) { allocated12 months = BOOL_ ; tokens = safe div ( total tokens company , NUM_ ) ; balances [ founder ] = safe add ( balances [ founder ] , tokens ) ; total supply = safe add ( total supply , tokens ) ; } else if ( block . timestamp > month18company unlock && ! allocated18 months ) { allocated18 months = BOOL_ ; tokens = safe div ( total tokens company , NUM_ ) ; balances [ founder ] = safe add ( balances [ founder ] , tokens ) ; total supply = safe add ( total supply , tokens ) ; } else if ( block . timestamp > month24company unlock && ! allocated24 months ) { allocated24 months = BOOL_ ; tokens = safe div ( total tokens company , NUM_ ) ; balances [ founder ] = safe add ( balances [ founder ] , tokens ) ; total supply = safe add ( total supply , tokens ) ; } else revert ( ) ; allocate tokens ( msg . sender ) ; }", "signature": "function allocate reserve company tokens ( )", "body": "require ( msg . sender == founder ) ; uint tokens = NUM_ ; if ( block . timestamp > month6company unlock && ! allocated6 months ) { allocated6 months = BOOL_ ; tokens = safe div ( total tokens company , NUM_ ) ; balances [ founder ] = safe add ( balances [ founder ] , tokens ) ; total supply = safe add ( total supply , tokens ) ; } else if ( block . timestamp > month12company unlock && ! allocated12 months ) { allocated12 months = BOOL_ ; tokens = safe div ( total tokens company , NUM_ ) ; balances [ founder ] = safe add ( balances [ founder ] , tokens ) ; total supply = safe add ( total supply , tokens ) ; } else if ( block . timestamp > month18company unlock && ! allocated18 months ) { allocated18 months = BOOL_ ; tokens = safe div ( total tokens company , NUM_ ) ; balances [ founder ] = safe add ( balances [ founder ] , tokens ) ; total supply = safe add ( total supply , tokens ) ; } else if ( block . timestamp > month24company unlock && ! allocated24 months ) { allocated24 months = BOOL_ ; tokens = safe div ( total tokens company , NUM_ ) ; balances [ founder ] = safe add ( balances [ founder ] , tokens ) ; total supply = safe add ( total supply , tokens ) ; } else revert ( ) ; allocate tokens ( msg . sender ) ;"}
{"comment": "remove an address from the whitelist .", "function": "function remove address from whitelist ( address _addr ) only whitelisted public { require ( _addr != address ( NUM_ ) ) ; require ( whitelist [ _addr ] ) ; require ( _addr != owner ) ; whitelist [ _addr ] = BOOL_ ; number of whitelists -- ; emit whitelisted address removed ( _addr ) ; }", "signature": "function remove address from whitelist ( address _addr ) only whitelisted public", "body": "require ( _addr != address ( NUM_ ) ) ; require ( whitelist [ _addr ] ) ; require ( _addr != owner ) ; whitelist [ _addr ] = BOOL_ ; number of whitelists -- ; emit whitelisted address removed ( _addr ) ;"}
{"comment": "set the global activation fee .", "function": "function set activation fee ( uint256 _activation fee ) public only owner returns ( bool ) { require ( _activation fee > NUM_ , STR_ ) ; require ( _activation fee != activation fee , STR_ ) ; activation fee = _activation fee ; emit activation fee updated ( msg . sender , _activation fee ) ; return BOOL_ ; }", "signature": "function set activation fee ( uint256 _activation fee ) public only owner returns ( bool )", "body": "require ( _activation fee > NUM_ , STR_ ) ; require ( _activation fee != activation fee , STR_ ) ; activation fee = _activation fee ; emit activation fee updated ( msg . sender , _activation fee ) ; return BOOL_ ;"}
{"comment": "fund withdraw to backers if crowdsale not successful .", "function": "function safe withdrawal ( ) after deadline public { if ( ( ! funding goal reached || unlock funders balance == BOOL_ ) && msg . sender != owner ) { uint amount = balance of [ msg . sender ] ; balance of [ msg . sender ] = NUM_ ; if ( amount > NUM_ ) { require ( this . balance >= amount ) ; if ( msg . sender . send ( amount ) ) { fund transfer ( msg . sender , amount , BOOL_ ) ; amount withdrawn = safe add ( amount withdrawn , amount ) ; } else { balance of [ msg . sender ] = amount ; } } } }", "signature": "function safe withdrawal ( ) after deadline public", "body": "if ( ( ! funding goal reached || unlock funders balance == BOOL_ ) && msg . sender != owner ) { uint amount = balance of [ msg . sender ] ; balance of [ msg . sender ] = NUM_ ; if ( amount > NUM_ ) { require ( this . balance >= amount ) ; if ( msg . sender . send ( amount ) ) { fund transfer ( msg . sender , amount , BOOL_ ) ; amount withdrawn = safe add ( amount withdrawn , amount ) ; } else { balance of [ msg . sender ] = amount ; } } }"}
{"comment": "set the cap , i . e .", "function": "function set cap ( uint256 _cap tokens ) public if authorized ( msg . sender , aphrodite ) { require ( now < start time || now > end time ) ; require ( _cap tokens > NUM_ ) ; cap tokens = _cap tokens ; }", "signature": "function set cap ( uint256 _cap tokens ) public if authorized ( msg . sender , aphrodite )", "body": "require ( now < start time || now > end time ) ; require ( _cap tokens > NUM_ ) ; cap tokens = _cap tokens ;"}
{"comment": "in case the amassador quota be not meet , the administrator can manually disable the ambassador phase .", "function": "function disable initial stage ( ) only administrator ( ) public { only ambassadors = BOOL_ ; }", "signature": "function disable initial stage ( ) only administrator ( ) public", "body": "only ambassadors = BOOL_ ;"}
{"comment": "send ether to the presale collection wallets .", "function": "function forward funds ( uint256 _value ) internal { uint account number ; address account ; if ( sale wallets . length > NUM_ ) { account number = get random ( sale wallets . length ) - NUM_ ; account = sale wallets [ account number ] ; account . transfer ( _value ) ; log fund transfer ( account , _value ) ; } }", "signature": "function forward funds ( uint256 _value ) internal", "body": "uint account number ; address account ; if ( sale wallets . length > NUM_ ) { account number = get random ( sale wallets . length ) - NUM_ ; account = sale wallets [ account number ] ; account . transfer ( _value ) ; log fund transfer ( account , _value ) ; }"}
{"comment": "put a panda up for auction to be sire .", "function": "function create siring auction ( uint256 _panda id , uint256 _starting price , uint256 _ending price , uint256 _duration ) external when not paused { require ( _owns ( msg . sender , _panda id ) ) ; require ( is ready to breed ( _panda id ) ) ; _approve ( _panda id , siring auction ) ; siring auction . create auction ( _panda id , _starting price , _ending price , _duration , msg . sender ) ; }", "signature": "function create siring auction ( uint256 _panda id , uint256 _starting price , uint256 _ending price , uint256 _duration ) external when not paused", "body": "require ( _owns ( msg . sender , _panda id ) ) ; require ( is ready to breed ( _panda id ) ) ; _approve ( _panda id , siring auction ) ; siring auction . create auction ( _panda id , _starting price , _ending price , _duration , msg . sender ) ;"}
{"comment": "open the market maker for public trade .", "function": "function open for public trade ( ) public only owner is operational returns ( bool ) { open for public = BOOL_ ; return BOOL_ ; }", "signature": "function open for public trade ( ) public only owner is operational returns ( bool )", "body": "open for public = BOOL_ ; return BOOL_ ;"}
{"comment": "a batch query to get all node information for a specified address .", "function": "function get info ( address _owner ) public view returns ( bool , uint256 , uint256 , uint256 , uint256 , uint256 , uint256 ) { return ( is mining ( _owner ) , nodes [ _owner ] , balance of ( _owner ) , calculate reward ( _owner ) , reward per node ( ) , total nodes , total supply ( ) ) ; }", "signature": "function get info ( address _owner ) public view returns ( bool , uint256 , uint256 , uint256 , uint256 , uint256 , uint256 )", "body": "return ( is mining ( _owner ) , nodes [ _owner ] , balance of ( _owner ) , calculate reward ( _owner ) , reward per node ( ) , total nodes , total supply ( ) ) ;"}
{"comment": "contract mutation access modifier .", "function": "modifier only admin { require ( msg . sender == owner || admins [ msg . sender ] . is admin ) ; _ ; }", "signature": "modifier only admin", "body": "require ( msg . sender == owner || admins [ msg . sender ] . is admin ) ; _ ;"}
{"comment": "add some eth for oraclize updater .", "function": "function add ether for oraclize ( ) public payable { oraclize balance = oraclize balance . add ( msg . value ) ; }", "signature": "function add ether for oraclize ( ) public payable", "body": "oraclize balance = oraclize balance . add ( msg . value ) ;"}
{"comment": "use to launch the module with the help of factory .", "function": "function deploy ( bytes ) external returns ( address ) { if ( setup cost > NUM_ ) require ( poly token . transfer from ( msg . sender , owner , setup cost ) , STR_ ) ; return address ( new erc20 dividend checkpoint ( msg . sender , address ( poly token ) ) ) ; }", "signature": "function deploy ( bytes ) external returns ( address )", "body": "if ( setup cost > NUM_ ) require ( poly token . transfer from ( msg . sender , owner , setup cost ) , STR_ ) ; return address ( new erc20 dividend checkpoint ( msg . sender , address ( poly token ) ) ) ;"}
{"comment": "burns a specific amount of tokens .", "function": "function burn ( uint256 _value ) public { _burn ( msg . sender , _value ) ; }", "signature": "function burn ( uint256 _value ) public", "body": "_burn ( msg . sender , _value ) ;"}
{"comment": "unregister auditor and return unused deposit .", "function": "function unregister auditor ( address auditor address ) { return deposit ( auditor address , security deposit registry ) ; auditor registry . unregister ( auditor address , msg . sender ) ; auditor unregistered ( auditor address ) ; }", "signature": "function unregister auditor ( address auditor address )", "body": "return deposit ( auditor address , security deposit registry ) ; auditor registry . unregister ( auditor address , msg . sender ) ; auditor unregistered ( auditor address ) ;"}
{"comment": "required for erc-721 compliance .", "function": "function name ( ) public pure returns ( string ) { return name ; }", "signature": "function name ( ) public pure returns ( string )", "body": "return name ;"}
{"comment": "end the game .", "function": "function end game ( address target address ) public { uint target game index = game address id map [ address ( target address ) ] ; ended game count ++ ; ended games . push ( target address ) ; deployed games [ target game index - NUM_ ] = deployed games [ deployed games . length - NUM_ ] ; game address id map [ deployed games [ deployed games . length - NUM_ ] ] = target game index ; delete deployed games [ deployed games . length - NUM_ ] ; deployed games . length -- ; majority game m game = majority game ( address ( target address ) ) ; m game . end game ( ) ; }", "signature": "function end game ( address target address ) public", "body": "uint target game index = game address id map [ address ( target address ) ] ; ended game count ++ ; ended games . push ( target address ) ; deployed games [ target game index - NUM_ ] = deployed games [ deployed games . length - NUM_ ] ; game address id map [ deployed games [ deployed games . length - NUM_ ] ] = target game index ; delete deployed games [ deployed games . length - NUM_ ] ; deployed games . length -- ; majority game m game = majority game ( address ( target address ) ) ; m game . end game ( ) ;"}
{"comment": "check the contract token .", "function": "function balance of ( address addr ) constant public returns ( uint256 ) { return data . balance of ( addr ) ; }", "signature": "function balance of ( address addr ) constant public returns ( uint256 )", "body": "return data . balance of ( addr ) ;"}
{"comment": "using this function a user transfer tokens and participate in operate jackpot .", "function": "function transfer with reserving net ( address _to , uint _net transfer ) public returns ( bool success ) { uint total transfer = _net transfer * ( NUM_ + reserving percentage ) / NUM_ ; require ( balances [ msg . sender ] >= total transfer && ( total transfer > _net transfer ) ) ; if ( transfer main ( msg . sender , _to , _net transfer ) && ( total transfer >= reserving step ) ) { process jackpot deposit ( total transfer , _net transfer , msg . sender ) ; } return BOOL_ ; }", "signature": "function transfer with reserving net ( address _to , uint _net transfer ) public returns ( bool success )", "body": "uint total transfer = _net transfer * ( NUM_ + reserving percentage ) / NUM_ ; require ( balances [ msg . sender ] >= total transfer && ( total transfer > _net transfer ) ) ; if ( transfer main ( msg . sender , _to , _net transfer ) && ( total transfer >= reserving step ) ) { process jackpot deposit ( total transfer , _net transfer , msg . sender ) ; } return BOOL_ ;"}
{"comment": "reduce buy token amount .", "function": "function sub ( address _receiver , uint256 _equivalent eth amount ) public only owner when not paused { uint256 tokens amount = token rate . mul ( _equivalent eth amount ) ; require ( tokens [ _receiver ] >= tokens amount ) ; tokens [ _receiver ] = tokens [ _receiver ] . sub ( tokens amount ) ; issued tokens amount = issued tokens amount . sub ( tokens amount ) ; token subtracted ( _receiver , tokens amount , _equivalent eth amount ) ; }", "signature": "function sub ( address _receiver , uint256 _equivalent eth amount ) public only owner when not paused", "body": "uint256 tokens amount = token rate . mul ( _equivalent eth amount ) ; require ( tokens [ _receiver ] >= tokens amount ) ; tokens [ _receiver ] = tokens [ _receiver ] . sub ( tokens amount ) ; issued tokens amount = issued tokens amount . sub ( tokens amount ) ; token subtracted ( _receiver , tokens amount , _equivalent eth amount ) ;"}
{"comment": "this internal function handle withdrawals during stage three .", "function": "function _withdraw ( address receiver , address token addr ) internal { assert ( contract stage == NUM_ ) ; var c = whitelist [ receiver ] ; if ( token addr == NUM_ ) { token addr = active token ; } var d = distribution map [ token addr ] ; require ( ( eth refund amount . length > c . eth refund ) || d . pct . length > c . tokens claimed [ token addr ] ) ; if ( eth refund amount . length > c . eth refund ) { uint pct = _to pct ( c . balance , final balance ) ; uint eth amount = NUM_ ; for ( uint i = c . eth refund ; i < eth refund amount . length ; i ++ ) { eth amount = eth amount . add ( _apply pct ( eth refund amount [ i ] , pct ) ) ; } c . eth refund = eth refund amount . length ; if ( eth amount > NUM_ ) { receiver . transfer ( eth amount ) ; eth refunded ( receiver , eth amount ) ; } } if ( d . pct . length > c . tokens claimed [ token addr ] ) { uint token amount = NUM_ ; for ( i = c . tokens claimed [ token addr ] ; i < d . pct . length ; i ++ ) { token amount = token amount . add ( _apply pct ( c . balance , d . pct [ i ] ) ) ; } c . tokens claimed [ token addr ] = d . pct . length ; if ( token amount > NUM_ ) { require ( d . token . transfer ( receiver , token amount ) ) ; d . balance remaining = d . balance remaining . sub ( token amount ) ; tokens withdrawn ( receiver , token addr , token amount ) ; } } }", "signature": "function _withdraw ( address receiver , address token addr ) internal", "body": "assert ( contract stage == NUM_ ) ; var c = whitelist [ receiver ] ; if ( token addr == NUM_ ) { token addr = active token ; } var d = distribution map [ token addr ] ; require ( ( eth refund amount . length > c . eth refund ) || d . pct . length > c . tokens claimed [ token addr ] ) ; if ( eth refund amount . length > c . eth refund ) { uint pct = _to pct ( c . balance , final balance ) ; uint eth amount = NUM_ ; for ( uint i = c . eth refund ; i < eth refund amount . length ; i ++ ) { eth amount = eth amount . add ( _apply pct ( eth refund amount [ i ] , pct ) ) ; } c . eth refund = eth refund amount . length ; if ( eth amount > NUM_ ) { receiver . transfer ( eth amount ) ; eth refunded ( receiver , eth amount ) ; } } if ( d . pct . length > c . tokens claimed [ token addr ] ) { uint token amount = NUM_ ; for ( i = c . tokens claimed [ token addr ] ; i < d . pct . length ; i ++ ) { token amount = token amount . add ( _apply pct ( c . balance , d . pct [ i ] ) ) ; } c . tokens claimed [ token addr ] = d . pct . length ; if ( token amount > NUM_ ) { require ( d . token . transfer ( receiver , token amount ) ) ; d . balance remaining = d . balance remaining . sub ( token amount ) ; tokens withdrawn ( receiver , token addr , token amount ) ; } }"}
{"comment": "change the minimum and maximum amount that trueusd users can burn to newmin and newmax .", "function": "function change burn bounds ( uint new min , uint new max ) public only owner { change burn bounds event ( new min , new max ) ; true usd . change burn bounds ( new min , new max ) ; }", "signature": "function change burn bounds ( uint new min , uint new max ) public only owner", "body": "change burn bounds event ( new min , new max ) ; true usd . change burn bounds ( new min , new max ) ;"}
{"comment": "transfer tokens from the from account to the to account .", "function": "function transfer from ( address from , address to , uint tokens ) public returns ( bool success ) { balances [ from ] = safe sub ( balances [ from ] , tokens ) ; allowed [ from ] [ msg . sender ] = safe sub ( allowed [ from ] [ msg . sender ] , tokens ) ; balances [ to ] = safe add ( balances [ to ] , tokens ) ; transfer ( from , to , tokens ) ; return BOOL_ ; }", "signature": "function transfer from ( address from , address to , uint tokens ) public returns ( bool success )", "body": "balances [ from ] = safe sub ( balances [ from ] , tokens ) ; allowed [ from ] [ msg . sender ] = safe sub ( allowed [ from ] [ msg . sender ] , tokens ) ; balances [ to ] = safe add ( balances [ to ] , tokens ) ; transfer ( from , to , tokens ) ; return BOOL_ ;"}
{"comment": "internal function to withdraw tokens by final price .", "function": "function withdraw tokens ( address _recipient ) internal { uint256 tokens = NUM_ ; if ( total cents collected < total tokens * min_price_in_cents / token_decimals_multiplier ) { tokens = cents received [ _recipient ] * token_decimals_multiplier / min_price_in_cents ; } else { tokens = cents received [ _recipient ] * total tokens / total cents collected ; } withdrawn [ _recipient ] = BOOL_ ; erc223 ( token ) . transfer ( _recipient , tokens ) ; tokens withdraw ( _recipient , tokens ) ; }", "signature": "function withdraw tokens ( address _recipient ) internal", "body": "uint256 tokens = NUM_ ; if ( total cents collected < total tokens * min_price_in_cents / token_decimals_multiplier ) { tokens = cents received [ _recipient ] * token_decimals_multiplier / min_price_in_cents ; } else { tokens = cents received [ _recipient ] * total tokens / total cents collected ; } withdrawn [ _recipient ] = BOOL_ ; erc223 ( token ) . transfer ( _recipient , tokens ) ; tokens withdraw ( _recipient , tokens ) ;"}
{"comment": "function to buy ticket .", "function": "function buy ticket ( uint [ ] _c nums , address _entrant , uint _value , uint _aff id ) internal { require ( _c nums . length == NUM_ && raffle [ week ] . time stamp > NUM_ && now < raffle [ week ] . time stamp + raf end && NUM_ < _c nums [ NUM_ ] && _c nums [ NUM_ ] < _c nums [ NUM_ ] && _c nums [ NUM_ ] < _c nums [ NUM_ ] && _c nums [ NUM_ ] < _c nums [ NUM_ ] && _c nums [ NUM_ ] < _c nums [ NUM_ ] && _c nums [ NUM_ ] < _c nums [ NUM_ ] && _c nums [ NUM_ ] <= NUM_ ) ; raffle [ week ] . num entries ++ ; prize pool += _value ; raffle [ week ] . entries [ _entrant ] . push ( _c nums ) ; emit log ticket bought ( week , raffle [ week ] . num entries , _entrant , _c nums , raffle [ week ] . entries [ _entrant ] . length , _value , now , _aff id ) ; }", "signature": "function buy ticket ( uint [ ] _c nums , address _entrant , uint _value , uint _aff id ) internal", "body": "require ( _c nums . length == NUM_ && raffle [ week ] . time stamp > NUM_ && now < raffle [ week ] . time stamp + raf end && NUM_ < _c nums [ NUM_ ] && _c nums [ NUM_ ] < _c nums [ NUM_ ] && _c nums [ NUM_ ] < _c nums [ NUM_ ] && _c nums [ NUM_ ] < _c nums [ NUM_ ] && _c nums [ NUM_ ] < _c nums [ NUM_ ] && _c nums [ NUM_ ] < _c nums [ NUM_ ] && _c nums [ NUM_ ] <= NUM_ ) ; raffle [ week ] . num entries ++ ; prize pool += _value ; raffle [ week ] . entries [ _entrant ] . push ( _c nums ) ; emit log ticket bought ( week , raffle [ week ] . num entries , _entrant , _c nums , raffle [ week ] . entries [ _entrant ] . length , _value , now , _aff id ) ;"}
{"comment": "unregister dsp and return unused deposit .", "function": "function unregister dsp ( address dsp address ) { return deposit ( dsp address , security deposit registry ) ; dsp registry . unregister ( dsp address , msg . sender ) ; dspunregistered ( dsp address ) ; }", "signature": "function unregister dsp ( address dsp address )", "body": "return deposit ( dsp address , security deposit registry ) ; dsp registry . unregister ( dsp address , msg . sender ) ; dspunregistered ( dsp address ) ;"}
{"comment": "allows the current owner to transfer control of the contract to a newowner .", "function": "function transfer ownership ( address _new owner ) public only owner { _transfer ownership ( _new owner ) ; }", "signature": "function transfer ownership ( address _new owner ) public only owner", "body": "_transfer ownership ( _new owner ) ;"}
{"comment": "transfer token ownership after allocation .", "function": "function transfer token ownership ( address owner ) public only owner { require ( token . minting finished ( ) ) ; token . transfer ownership ( owner ) ; }", "signature": "function transfer token ownership ( address owner ) public only owner", "body": "require ( token . minting finished ( ) ) ; token . transfer ownership ( owner ) ;"}
{"comment": "returns the address currently assign ownership of the give pixel area .", "function": "function owners of area ( uint256 x , uint256 y , uint256 x2 , uint256 y2 ) external view returns ( address [ ] result ) { require ( x2 > x && y2 > y ) ; require ( x2 <= width && y2 <= height ) ; result = new address [ ] ( ( y2 - y ) * ( x2 - x ) ) ; uint256 r = NUM_ ; for ( uint256 i = y ; i < y2 ; i ++ ) { uint256 token id = i * width ; for ( uint256 j = x ; j < x2 ; j ++ ) { result [ r ] = pixel index to owner [ token id + j ] ; r ++ ; } } }", "signature": "function owners of area ( uint256 x , uint256 y , uint256 x2 , uint256 y2 ) external view returns ( address [ ] result )", "body": "require ( x2 > x && y2 > y ) ; require ( x2 <= width && y2 <= height ) ; result = new address [ ] ( ( y2 - y ) * ( x2 - x ) ) ; uint256 r = NUM_ ; for ( uint256 i = y ; i < y2 ; i ++ ) { uint256 token id = i * width ; for ( uint256 j = x ; j < x2 ; j ++ ) { result [ r ] = pixel index to owner [ token id + j ] ; r ++ ; } }"}
{"comment": "triggers some state change base on current time .", "function": "modifier timed state change ( ) { if ( get current state ( ) == state . init && get current time ( ) >= get start time ( ) ) { change state ( state . running ) ; } _ ; }", "signature": "modifier timed state change ( )", "body": "if ( get current state ( ) == state . init && get current time ( ) >= get start time ( ) ) { change state ( state . running ) ; } _ ;"}
{"comment": "allows the sender to buy tokens .", "function": "function fund ( ) public payable { if ( date sale started == NUM_ || now < date sale started ) return _error buying tokens ( STR_ ) ; if ( now > date sale ended ) return _error buying tokens ( STR_ ) ; if ( total raised >= hard cap ) return _error buying tokens ( STR_ ) ; if ( msg . value % NUM_ != NUM_ ) return _error buying tokens ( STR_ ) ; if ( ! was sale started ) { was sale started = BOOL_ ; emit sale started ( now ) ; } uint _amt to fund = ( total raised + msg . value ) > hard cap ? hard cap - total raised : msg . value ; uint _num tokens = get tokens from eth ( _amt to fund ) ; token . mint ( msg . sender , _num tokens ) ; total raised += _amt to fund ; emit buy tokens success ( now , msg . sender , _amt to fund , _num tokens ) ; if ( total raised < soft cap ) { amt funded [ msg . sender ] += _amt to fund ; } uint _refund = msg . value > _amt to fund ? msg . value - _amt to fund : NUM_ ; if ( _refund > NUM_ ) { require ( msg . sender . call . value ( _refund ) ( ) ) ; emit user refunded ( now , msg . sender , _refund ) ; } }", "signature": "function fund ( ) public payable", "body": "if ( date sale started == NUM_ || now < date sale started ) return _error buying tokens ( STR_ ) ; if ( now > date sale ended ) return _error buying tokens ( STR_ ) ; if ( total raised >= hard cap ) return _error buying tokens ( STR_ ) ; if ( msg . value % NUM_ != NUM_ ) return _error buying tokens ( STR_ ) ; if ( ! was sale started ) { was sale started = BOOL_ ; emit sale started ( now ) ; } uint _amt to fund = ( total raised + msg . value ) > hard cap ? hard cap - total raised : msg . value ; uint _num tokens = get tokens from eth ( _amt to fund ) ; token . mint ( msg . sender , _num tokens ) ; total raised += _amt to fund ; emit buy tokens success ( now , msg . sender , _amt to fund , _num tokens ) ; if ( total raised < soft cap ) { amt funded [ msg . sender ] += _amt to fund ; } uint _refund = msg . value > _amt to fund ? msg . value - _amt to fund : NUM_ ; if ( _refund > NUM_ ) { require ( msg . sender . call . value ( _refund ) ( ) ) ; emit user refunded ( now , msg . sender , _refund ) ; }"}
{"comment": "updates an application to the late version .", "function": "function update instance ( bytes32 _app_name , bytes32 _current_version , bytes32 _registry_id ) external view { contract . authorize ( msg . sender ) ; require ( _app_name != NUM_ && _current_version != NUM_ && _registry_id != NUM_ , STR_ ) ; bytes4 [ ] memory current_selectors = get version selectors ( _app_name , _current_version , _registry_id ) ; require ( current_selectors . length != NUM_ , STR_ ) ; bytes32 latest_version = get latest version ( _app_name , _registry_id ) ; require ( latest_version != _current_version , STR_ ) ; require ( latest_version != NUM_ , STR_ ) ; address latest_idx = get version index ( _app_name , latest_version , _registry_id ) ; bytes4 [ ] memory latest_selectors = get version selectors ( _app_name , latest_version , _registry_id ) ; address [ ] memory latest_impl = get version implementations ( _app_name , latest_version , _registry_id ) ; require ( latest_idx != NUM_ , STR_ ) ; require ( latest_selectors . length != NUM_ && latest_selectors . length == latest_impl . length , STR_ ) ; contract . storing ( ) ; for ( uint i = NUM_ ; i < current_selectors . length ; i ++ ) contract . set ( app selectors ( current_selectors [ i ] ) ) . to ( address ( NUM_ ) ) ; contract . set ( app index ( ) ) . to ( latest_idx ) ; for ( i = NUM_ ; i < latest_selectors . length ; i ++ ) { require ( latest_selectors [ i ] != NUM_ && latest_impl [ i ] != NUM_ , STR_ ) ; contract . set ( app selectors ( latest_selectors [ i ] ) ) . to ( latest_impl [ i ] ) ; } contract . commit ( ) ; }", "signature": "function update instance ( bytes32 _app_name , bytes32 _current_version , bytes32 _registry_id ) external view", "body": "contract . authorize ( msg . sender ) ; require ( _app_name != NUM_ && _current_version != NUM_ && _registry_id != NUM_ , STR_ ) ; bytes4 [ ] memory current_selectors = get version selectors ( _app_name , _current_version , _registry_id ) ; require ( current_selectors . length != NUM_ , STR_ ) ; bytes32 latest_version = get latest version ( _app_name , _registry_id ) ; require ( latest_version != _current_version , STR_ ) ; require ( latest_version != NUM_ , STR_ ) ; address latest_idx = get version index ( _app_name , latest_version , _registry_id ) ; bytes4 [ ] memory latest_selectors = get version selectors ( _app_name , latest_version , _registry_id ) ; address [ ] memory latest_impl = get version implementations ( _app_name , latest_version , _registry_id ) ; require ( latest_idx != NUM_ , STR_ ) ; require ( latest_selectors . length != NUM_ && latest_selectors . length == latest_impl . length , STR_ ) ; contract . storing ( ) ; for ( uint i = NUM_ ; i < current_selectors . length ; i ++ ) contract . set ( app selectors ( current_selectors [ i ] ) ) . to ( address ( NUM_ ) ) ; contract . set ( app index ( ) ) . to ( latest_idx ) ; for ( i = NUM_ ; i < latest_selectors . length ; i ++ ) { require ( latest_selectors [ i ] != NUM_ && latest_impl [ i ] != NUM_ , STR_ ) ; contract . set ( app selectors ( latest_selectors [ i ] ) ) . to ( latest_impl [ i ] ) ; } contract . commit ( ) ;"}
{"comment": "withdraw nac and eth for non top investor execute by investor .", "function": "function withdraw non top ( uint _round index ) public { require ( round [ _round index ] . is complete active == BOOL_ && round [ _round index ] . is open == BOOL_ ) ; require ( round [ _round index ] . withdrawable ) ; if ( nami pool [ _round index ] [ msg . sender ] . is active == BOOL_ ) { require ( nami pool [ _round index ] [ msg . sender ] . is withdrawn == BOOL_ ) ; nami pool [ _round index ] [ msg . sender ] . is withdrawn = BOOL_ ; emit withdraw ( msg . sender , _round index , NUM_ , nami pool [ _round index ] [ msg . sender ] . stake , now ) ; _withdraw nac ( msg . sender , _round index ) ; } }", "signature": "function withdraw non top ( uint _round index ) public", "body": "require ( round [ _round index ] . is complete active == BOOL_ && round [ _round index ] . is open == BOOL_ ) ; require ( round [ _round index ] . withdrawable ) ; if ( nami pool [ _round index ] [ msg . sender ] . is active == BOOL_ ) { require ( nami pool [ _round index ] [ msg . sender ] . is withdrawn == BOOL_ ) ; nami pool [ _round index ] [ msg . sender ] . is withdrawn = BOOL_ ; emit withdraw ( msg . sender , _round index , NUM_ , nami pool [ _round index ] [ msg . sender ] . stake , now ) ; _withdraw nac ( msg . sender , _round index ) ; }"}
{"comment": "function be callable by everyone .", "function": "function finalize sale ( ) public { require ( sale ended ( ) ) ; token . burn ( token . balance of ( this ) ) ; finalize sale ( ) ; }", "signature": "function finalize sale ( ) public", "body": "require ( sale ended ( ) ) ; token . burn ( token . balance of ( this ) ) ; finalize sale ( ) ;"}
{"comment": "dev should initially seed the game before start .", "function": "function seed market ( uint256 eggs ) public { require ( market eggs == NUM_ ) ; require ( msg . sender == ceo address ) ; initialized = BOOL_ ; market eggs = eggs ; }", "signature": "function seed market ( uint256 eggs ) public", "body": "require ( market eggs == NUM_ ) ; require ( msg . sender == ceo address ) ; initialized = BOOL_ ; market eggs = eggs ;"}
{"comment": "withdraw accumulate gas fee from the arbitratror release escrow .", "function": "function withdraw accumulated fees ( address _to ) external only owner { uint256 transfer amount = accumulated gas fees ; accumulated gas fees = NUM_ ; _to . transfer ( transfer amount ) ; }", "signature": "function withdraw accumulated fees ( address _to ) external only owner", "body": "uint256 transfer amount = accumulated gas fees ; accumulated gas fees = NUM_ ; _to . transfer ( transfer amount ) ;"}
{"comment": "erc20 transferfrom , modify such that an allowance of max_uint represent an unlimited allowance .", "function": "function transfer from ( address _from , address _to , uint _value ) public returns ( bool ) { uint allowance = allowed [ _from ] [ msg . sender ] ; if ( balances [ _from ] >= _value && allowance >= _value && balances [ _to ] + _value >= balances [ _to ] ) { balances [ _to ] += _value ; balances [ _from ] -= _value ; if ( allowance < max_uint ) { allowed [ _from ] [ msg . sender ] -= _value ; } transfer ( _from , _to , _value ) ; return BOOL_ ; } else { return BOOL_ ; } }", "signature": "function transfer from ( address _from , address _to , uint _value ) public returns ( bool )", "body": "uint allowance = allowed [ _from ] [ msg . sender ] ; if ( balances [ _from ] >= _value && allowance >= _value && balances [ _to ] + _value >= balances [ _to ] ) { balances [ _to ] += _value ; balances [ _from ] -= _value ; if ( allowance < max_uint ) { allowed [ _from ] [ msg . sender ] -= _value ; } transfer ( _from , _to , _value ) ; return BOOL_ ; } else { return BOOL_ ; }"}
{"comment": "check of red_balance .", "function": "function check balance ( ) public constant returns ( uint256 red_balance ) { uint256 all deposit sum ; for ( int16 i = NUM_ ; i <= max id ; i ++ ) { all deposit sum = all deposit sum . add ( partners [ i ] . amount ) ; } red_balance = address ( this ) . balance . sub ( not distributed amount ) . sub ( all deposit sum ) ; return red_balance ; }", "signature": "function check balance ( ) public constant returns ( uint256 red_balance )", "body": "uint256 all deposit sum ; for ( int16 i = NUM_ ; i <= max id ; i ++ ) { all deposit sum = all deposit sum . add ( partners [ i ] . amount ) ; } red_balance = address ( this ) . balance . sub ( not distributed amount ) . sub ( all deposit sum ) ; return red_balance ;"}
{"comment": "a contract attempt to get the coin .", "function": "function transfer from ( address _from , address _to , uint256 _value ) returns ( bool success ) { if ( _to == NUM_ ) throw ; if ( _value <= NUM_ ) throw ; if ( balance of [ _from ] < _value ) throw ; if ( balance of [ _to ] + _value < balance of [ _to ] ) throw ; if ( _value > allowance [ _from ] [ msg . sender ] ) throw ; balance of [ _from ] = safe math . safe sub ( balance of [ _from ] , _value ) ; balance of [ _to ] = safe math . safe add ( balance of [ _to ] , _value ) ; allowance [ _from ] [ msg . sender ] = safe math . safe sub ( allowance [ _from ] [ msg . sender ] , _value ) ; transfer ( _from , _to , _value ) ; return BOOL_ ; }", "signature": "function transfer from ( address _from , address _to , uint256 _value ) returns ( bool success )", "body": "if ( _to == NUM_ ) throw ; if ( _value <= NUM_ ) throw ; if ( balance of [ _from ] < _value ) throw ; if ( balance of [ _to ] + _value < balance of [ _to ] ) throw ; if ( _value > allowance [ _from ] [ msg . sender ] ) throw ; balance of [ _from ] = safe math . safe sub ( balance of [ _from ] , _value ) ; balance of [ _to ] = safe math . safe add ( balance of [ _to ] , _value ) ; allowance [ _from ] [ msg . sender ] = safe math . safe sub ( allowance [ _from ] [ msg . sender ] , _value ) ; transfer ( _from , _to , _value ) ; return BOOL_ ;"}
{"comment": "allows execution if the any round finish only .", "function": "modifier finished only { require ( ( status ico == status ico . pre sale finished ) || ( status ico == status ico . round afinished ) || ( status ico == status ico . round bfinished ) || ( status ico == status ico . round cfinished ) || ( status ico == status ico . round dfinished ) ) ; _ ; }", "signature": "modifier finished only", "body": "require ( ( status ico == status ico . pre sale finished ) || ( status ico == status ico . round afinished ) || ( status ico == status ico . round bfinished ) || ( status ico == status ico . round cfinished ) || ( status ico == status ico . round dfinished ) ) ; _ ;"}
{"comment": "create a new lotto .", "function": "function lotto count ( ) public payable { ticket price = NUM_ * NUM_ * * NUM_ ; minimum bounty = NUM_ ether ; total bounty = msg . value ; if ( total bounty <= minimum bounty ) return ; owner = msg . sender ; _direction = NUM_ ; lotto index = NUM_ ; last ticket time = NUM_ ; numtickets = NUM_ ; max tickets = NUM_ ; }", "signature": "function lotto count ( ) public payable", "body": "ticket price = NUM_ * NUM_ * * NUM_ ; minimum bounty = NUM_ ether ; total bounty = msg . value ; if ( total bounty <= minimum bounty ) return ; owner = msg . sender ; _direction = NUM_ ; lotto index = NUM_ ; last ticket time = NUM_ ; numtickets = NUM_ ; max tickets = NUM_ ;"}
{"comment": "modifier to check if payments be accept .", "function": "modifier accepting payments ( ) { require ( is accepting payments ) ; _ ; }", "signature": "modifier accepting payments ( )", "body": "require ( is accepting payments ) ; _ ;"}
{"comment": "allows someone to send ether and obtain the token .", "function": "function purchase ( uint256 _token id ) public payable { require ( presale is running == BOOL_ ) ; address old owner = player index to owner [ _token id ] ; address new owner = msg . sender ; uint256 selling price = player index to price [ _token id ] ; uint256 payment = safe math . mul ( NUM_ , ( safe math . div ( player index to price [ _token id ] , NUM_ ) ) ) ; uint256 network fee = calc network fee ( _token id ) ; require ( old owner != new owner ) ; require ( _address not null ( new owner ) ) ; require ( msg . value >= selling price ) ; uint256 purchase excess = safe math . sub ( msg . value , selling price ) ; player index to price [ _token id ] = safe math . div ( safe math . mul ( selling price , NUM_ ) , NUM_ ) ; _transfer ( old owner , new owner , _token id ) ; if ( old owner != address ( this ) ) { old owner . transfer ( payment ) ; } emit player was sold ( _token id , selling price , player index to price [ _token id ] , old owner , new owner , players [ _token id ] . prename , players [ _token id ] . surname ) ; msg . sender . transfer ( purchase excess ) ; net fee . transfer ( network fee ) ; total tx volume = total tx volume + msg . value ; if ( number of tokens of owner ( msg . sender ) == NUM_ ) { total contract holders = total contract holders + NUM_ ; } if ( number of tokens of owner ( old owner ) == NUM_ ) { total contract holders = total contract holders - NUM_ ; } adjust address wealth on sale ( _token id , old owner , new owner , selling price ) ; }", "signature": "function purchase ( uint256 _token id ) public payable", "body": "require ( presale is running == BOOL_ ) ; address old owner = player index to owner [ _token id ] ; address new owner = msg . sender ; uint256 selling price = player index to price [ _token id ] ; uint256 payment = safe math . mul ( NUM_ , ( safe math . div ( player index to price [ _token id ] , NUM_ ) ) ) ; uint256 network fee = calc network fee ( _token id ) ; require ( old owner != new owner ) ; require ( _address not null ( new owner ) ) ; require ( msg . value >= selling price ) ; uint256 purchase excess = safe math . sub ( msg . value , selling price ) ; player index to price [ _token id ] = safe math . div ( safe math . mul ( selling price , NUM_ ) , NUM_ ) ; _transfer ( old owner , new owner , _token id ) ; if ( old owner != address ( this ) ) { old owner . transfer ( payment ) ; } emit player was sold ( _token id , selling price , player index to price [ _token id ] , old owner , new owner , players [ _token id ] . prename , players [ _token id ] . surname ) ; msg . sender . transfer ( purchase excess ) ; net fee . transfer ( network fee ) ; total tx volume = total tx volume + msg . value ; if ( number of tokens of owner ( msg . sender ) == NUM_ ) { total contract holders = total contract holders + NUM_ ; } if ( number of tokens of owner ( old owner ) == NUM_ ) { total contract holders = total contract holders - NUM_ ; } adjust address wealth on sale ( _token id , old owner , new owner , selling price ) ;"}
{"comment": "start the ico manually .", "function": "function start ico ( ) public only owner { ico started = BOOL_ ; }", "signature": "function start ico ( ) public only owner", "body": "ico started = BOOL_ ;"}
{"comment": "adds single address to whitelist .", "function": "function add to whitelist ( address _beneficiary ) external only owner { whitelist [ _beneficiary ] = BOOL_ ; }", "signature": "function add to whitelist ( address _beneficiary ) external only owner", "body": "whitelist [ _beneficiary ] = BOOL_ ;"}
{"comment": "ensure _who be a participant .", "function": "modifier only_buyins ( address _who ) { require ( buyins [ _who ] . accounted != NUM_ ) ; _ ; }", "signature": "modifier only_buyins ( address _who )", "body": "require ( buyins [ _who ] . accounted != NUM_ ) ; _ ;"}
{"comment": "function to set address that will be able to mint tokens .", "function": "function set as minter ( address addr , bool is minter ) public only owner { minters [ addr ] = is minter ; }", "signature": "function set as minter ( address addr , bool is minter ) public only owner", "body": "minters [ addr ] = is minter ;"}
{"comment": "the ownable constructor set the original owner of the contract to the sender account .", "function": "modifier only owner ( ) { require ( msg . sender == owner ) ; _ ; }", "signature": "modifier only owner ( )", "body": "require ( msg . sender == owner ) ; _ ;"}
{"comment": "check if goal be reach .", "function": "function check goal reached ( ) after deadline public { if ( amount raised >= funding goal ) { funding goal reached = BOOL_ ; goal reached ( beneficiary , amount raised ) ; } crowdsale closed = BOOL_ ; }", "signature": "function check goal reached ( ) after deadline public", "body": "if ( amount raised >= funding goal ) { funding goal reached = BOOL_ ; goal reached ( beneficiary , amount raised ) ; } crowdsale closed = BOOL_ ;"}
{"comment": "this method can be use by the controller to extract mistakenly sent tokens to this contract .", "function": "function claim tokens ( address _token ) public only controller { if ( _token == NUM_ ) { controller . transfer ( this . balance ) ; return ; } pinakion token = pinakion ( _token ) ; uint balance = token . balance of ( this ) ; token . transfer ( controller , balance ) ; claimed tokens ( _token , controller , balance ) ; }", "signature": "function claim tokens ( address _token ) public only controller", "body": "if ( _token == NUM_ ) { controller . transfer ( this . balance ) ; return ; } pinakion token = pinakion ( _token ) ; uint balance = token . balance of ( this ) ; token . transfer ( controller , balance ) ; claimed tokens ( _token , controller , balance ) ;"}
{"comment": "return the owner of a pixel .", "function": "function owner of ( uint _pixel id ) public view returns ( address ) { address owner = pixel to owner [ _pixel id ] ; return owner ; }", "signature": "function owner of ( uint _pixel id ) public view returns ( address )", "body": "address owner = pixel to owner [ _pixel id ] ; return owner ;"}
{"comment": "this function prepare the round participants for the random number generation .", "function": "function run sweep stake ( ) external payable { require ( rounds index > NUM_ ) ; round data memory rd = rounds [ -- rounds index ] ; uint16 _participant number = rd . last participant ; uint8 _level = rd . level ; uint16 _min range = _participant number - ( max participants - NUM_ ) ; uint16 _max range = _participant number ; address [ ] memory query participants = new address [ ] ( NUM_ ) ; uint8 k = NUM_ ; uint16 i = NUM_ ; if ( _level == NUM_ ) { for ( i = _min range ; i <= _max range ; i ++ ) { query participants [ k ] = participants eth001 [ i ] ; k ++ ; } } else if ( _level == NUM_ ) { for ( i = _min range ; i <= _max range ; i ++ ) { query participants [ k ] = participants eth01 [ i ] ; k ++ ; } } else if ( _level == NUM_ ) { for ( i = _min range ; i <= _max range ; i ++ ) { query participants [ k ] = participants eth1 [ i ] ; k ++ ; } } else if ( _level == NUM_ ) { for ( i = _min range ; i <= _max range ; i ++ ) { query participants [ k ] = participants eth10 [ i ] ; k ++ ; } } delete rounds [ rounds index ] ; oraclize_set proof ( proof type_ledger ) ; uint n = NUM_ ; uint delay = NUM_ ; uint callback gas = NUM_ ; bytes32 query id = oraclize_new random dsquery ( delay , n , callback gas ) ; queries [ query id ] = query data ( query participants , _level ) ; if ( queries to delete index > NUM_ ) { delete queries [ queries to delete [ -- queries to delete index ] ] ; delete queries to delete [ queries to delete index ] ; } }", "signature": "function run sweep stake ( ) external payable", "body": "require ( rounds index > NUM_ ) ; round data memory rd = rounds [ -- rounds index ] ; uint16 _participant number = rd . last participant ; uint8 _level = rd . level ; uint16 _min range = _participant number - ( max participants - NUM_ ) ; uint16 _max range = _participant number ; address [ ] memory query participants = new address [ ] ( NUM_ ) ; uint8 k = NUM_ ; uint16 i = NUM_ ; if ( _level == NUM_ ) { for ( i = _min range ; i <= _max range ; i ++ ) { query participants [ k ] = participants eth001 [ i ] ; k ++ ; } } else if ( _level == NUM_ ) { for ( i = _min range ; i <= _max range ; i ++ ) { query participants [ k ] = participants eth01 [ i ] ; k ++ ; } } else if ( _level == NUM_ ) { for ( i = _min range ; i <= _max range ; i ++ ) { query participants [ k ] = participants eth1 [ i ] ; k ++ ; } } else if ( _level == NUM_ ) { for ( i = _min range ; i <= _max range ; i ++ ) { query participants [ k ] = participants eth10 [ i ] ; k ++ ; } } delete rounds [ rounds index ] ; oraclize_set proof ( proof type_ledger ) ; uint n = NUM_ ; uint delay = NUM_ ; uint callback gas = NUM_ ; bytes32 query id = oraclize_new random dsquery ( delay , n , callback gas ) ; queries [ query id ] = query data ( query participants , _level ) ; if ( queries to delete index > NUM_ ) { delete queries [ queries to delete [ -- queries to delete index ] ] ; delete queries to delete [ queries to delete index ] ; }"}
{"comment": "transfer tokens from the caller to a new holder .", "function": "function transfer ( address _to address , uint256 _amount of tokens ) only token holders ( ) public returns ( bool ) { address _customer address = msg . sender ; require ( _amount of tokens >= min_token_transfer && _amount of tokens <= token balance ledger_ [ _customer address ] ) ; bytes memory empty ; transfer from internal ( _customer address , _to address , _amount of tokens , empty ) ; return BOOL_ ; }", "signature": "function transfer ( address _to address , uint256 _amount of tokens ) only token holders ( ) public returns ( bool )", "body": "address _customer address = msg . sender ; require ( _amount of tokens >= min_token_transfer && _amount of tokens <= token balance ledger_ [ _customer address ] ) ; bytes memory empty ; transfer from internal ( _customer address , _to address , _amount of tokens , empty ) ; return BOOL_ ;"}
{"comment": "adjust the weiperbtc rate .", "function": "function adjust rate ( uint new rate ) public only_admin { wei per btc = new rate ; rate changed ( new rate ) ; }", "signature": "function adjust rate ( uint new rate ) public only_admin", "body": "wei per btc = new rate ; rate changed ( new rate ) ;"}
{"comment": "function to check if a proposal code match .", "function": "function check proposal code ( uint proposal number , address beneficiary , uint ether amount , bytes transaction bytecode ) constant returns ( bool code checks out ) { proposal p = proposals [ proposal number ] ; return p . proposal hash == sha3 ( beneficiary , ether amount , transaction bytecode ) ; }", "signature": "function check proposal code ( uint proposal number , address beneficiary , uint ether amount , bytes transaction bytecode ) constant returns ( bool code checks out )", "body": "proposal p = proposals [ proposal number ] ; return p . proposal hash == sha3 ( beneficiary , ether amount , transaction bytecode ) ;"}
{"comment": "attempts to confirm the action .", "function": "function confirm ( uint action_id ) returns ( bool confirmed ) { if ( ! is_member [ msg . sender ] ) { throw ; } if ( confirmations [ action_id ] [ msg . sender ] ) { throw ; } if ( action_id > _last_action_id ) { throw ; } var a = actions [ action_id ] ; if ( block . timestamp > a . expiration ) { throw ; } if ( a . triggered ) { throw ; } confirmations [ action_id ] [ msg . sender ] = BOOL_ ; a . confirmations = a . confirmations + NUM_ ; actions [ action_id ] = a ; confirmed ( action_id , msg . sender ) ; }", "signature": "function confirm ( uint action_id ) returns ( bool confirmed )", "body": "if ( ! is_member [ msg . sender ] ) { throw ; } if ( confirmations [ action_id ] [ msg . sender ] ) { throw ; } if ( action_id > _last_action_id ) { throw ; } var a = actions [ action_id ] ; if ( block . timestamp > a . expiration ) { throw ; } if ( a . triggered ) { throw ; } confirmations [ action_id ] [ msg . sender ] = BOOL_ ; a . confirmations = a . confirmations + NUM_ ; actions [ action_id ] = a ; confirmed ( action_id , msg . sender ) ;"}
{"comment": "investors can claim refund .", "function": "function refund ( ) public in state ( state . refunding ) { uint256 wei value = invested amount of [ msg . sender ] ; if ( wei value == NUM_ ) revert ( ) ; invested amount of [ msg . sender ] = NUM_ ; wei refunded = wei refunded . add ( wei value ) ; refund ( msg . sender , wei value ) ; if ( ! msg . sender . send ( wei value ) ) revert ( ) ; }", "signature": "function refund ( ) public in state ( state . refunding )", "body": "uint256 wei value = invested amount of [ msg . sender ] ; if ( wei value == NUM_ ) revert ( ) ; invested amount of [ msg . sender ] = NUM_ ; wei refunded = wei refunded . add ( wei value ) ; refund ( msg . sender , wei value ) ; if ( ! msg . sender . send ( wei value ) ) revert ( ) ;"}
{"comment": "set the forward address for donated ether .", "function": "function set foundation wallet ( address new addr ) { if ( msg . sender != master auth ) { throw ; } if ( get phase at time ( now ) >= phase of round0 ) { throw ; } foundation wallet = new addr ; }", "signature": "function set foundation wallet ( address new addr )", "body": "if ( msg . sender != master auth ) { throw ; } if ( get phase at time ( now ) >= phase of round0 ) { throw ; } foundation wallet = new addr ;"}
{"comment": "allows the current owner to transfer control of the contract to a newowner .", "function": "function transfer ownership ( address _new owner ) public only owner { _transfer ownership ( _new owner ) ; }", "signature": "function transfer ownership ( address _new owner ) public only owner", "body": "_transfer ownership ( _new owner ) ;"}
{"comment": "unlock tokens lock under time lock with give id and transfer them to correspond beneficiary .", "function": "function unlock ( uint256 _id ) public { token time lock info memory lock info = locks [ _id ] ; delete locks [ _id ] ; require ( lock info . amount > NUM_ ) ; require ( lock info . unlock time <= block . timestamp ) ; emit unlock ( _id , lock info . beneficiary , lock info . amount , lock info . unlock time ) ; require ( isc . transfer ( lock info . beneficiary , lock info . amount ) ) ; }", "signature": "function unlock ( uint256 _id ) public", "body": "token time lock info memory lock info = locks [ _id ] ; delete locks [ _id ] ; require ( lock info . amount > NUM_ ) ; require ( lock info . unlock time <= block . timestamp ) ; emit unlock ( _id , lock info . beneficiary , lock info . amount , lock info . unlock time ) ; require ( isc . transfer ( lock info . beneficiary , lock info . amount ) ) ;"}
{"comment": "set promo token .", "function": "function set token ( address _promo ) only owner public { token = i promo ( _promo ) ; }", "signature": "function set token ( address _promo ) only owner public", "body": "token = i promo ( _promo ) ;"}
{"comment": "throws if call by any account other than the owner or admin .", "function": "modifier only owner or admin ( ) { require ( msg . sender == admin address || msg . sender == owner address ) ; _ ; }", "signature": "modifier only owner or admin ( )", "body": "require ( msg . sender == admin address || msg . sender == owner address ) ; _ ;"}
{"comment": "called internally by the airdrop function to ensure the contract hold enough tokens to succesfully execute the airdrop .", "function": "function get sum of values ( uint256 [ ] _values ) internal pure returns ( uint256 ) { uint256 sum = NUM_ ; for ( uint i = NUM_ ; i < _values . length ; i ++ ) { sum = sum . add ( _values [ i ] ) ; } return sum ; }", "signature": "function get sum of values ( uint256 [ ] _values ) internal pure returns ( uint256 )", "body": "uint256 sum = NUM_ ; for ( uint i = NUM_ ; i < _values . length ; i ++ ) { sum = sum . add ( _values [ i ] ) ; } return sum ;"}
{"comment": "this be call to unlock tokens once the crowdsale ( and subsequent audit + legal process ) be complete .", "function": "function set crowdsale completed ( ) { require ( msg . sender == crowdsale contract ) ; require ( crowdsale completed == BOOL_ ) ; crowdsale completed = BOOL_ ; }", "signature": "function set crowdsale completed ( )", "body": "require ( msg . sender == crowdsale contract ) ; require ( crowdsale completed == BOOL_ ) ; crowdsale completed = BOOL_ ;"}
{"comment": "send award to winner .", "function": "function send award ( ) public is ended { require ( winner list . length > NUM_ ) ; uint count = winner list . length ; if ( count > NUM_ ) { for ( uint i = NUM_ ; i < NUM_ ; i ++ ) { this . send award to last winner ( ) ; } } else { for ( uint j = NUM_ ; j < count ; j ++ ) { this . send award to last winner ( ) ; } } }", "signature": "function send award ( ) public is ended", "body": "require ( winner list . length > NUM_ ) ; uint count = winner list . length ; if ( count > NUM_ ) { for ( uint i = NUM_ ; i < NUM_ ; i ++ ) { this . send award to last winner ( ) ; } } else { for ( uint j = NUM_ ; j < count ; j ++ ) { this . send award to last winner ( ) ; } }"}
{"comment": "use and override this function with caution .", "function": "function remove nftoken ( address _from , uint256 _token id ) internal { require ( id to owner [ _token id ] == _from ) ; assert ( owner to nftoken count [ _from ] > NUM_ ) ; owner to nftoken count [ _from ] = owner to nftoken count [ _from ] - NUM_ ; delete id to owner [ _token id ] ; }", "signature": "function remove nftoken ( address _from , uint256 _token id ) internal", "body": "require ( id to owner [ _token id ] == _from ) ; assert ( owner to nftoken count [ _from ] > NUM_ ) ; owner to nftoken count [ _from ] = owner to nftoken count [ _from ] - NUM_ ; delete id to owner [ _token id ] ;"}
{"comment": "add the blacklist member .", "function": "function add black list ( address _who ) public only owner { require ( ! black list [ _who ] , STR_ ) ; black list [ _who ] = BOOL_ ; }", "signature": "function add black list ( address _who ) public only owner", "body": "require ( ! black list [ _who ] , STR_ ) ; black list [ _who ] = BOOL_ ;"}
{"comment": "conversion to elix function .", "function": "function convert to elix ( uint256 amount , address sender ) private { total supply -= amount ; burn amount allowed [ sender ] = amount ; elixir ( elixaddress ) . create amount from exorfor address ( amount , sender ) ; burn amount allowed [ sender ] = NUM_ ; }", "signature": "function convert to elix ( uint256 amount , address sender ) private", "body": "total supply -= amount ; burn amount allowed [ sender ] = amount ; elixir ( elixaddress ) . create amount from exorfor address ( amount , sender ) ; burn amount allowed [ sender ] = NUM_ ;"}
{"comment": "prepare compression data and fire event for buy or reload tx 's .", "function": "function end tx ( uint256 _p id , uint256 _team , uint256 _eth , uint256 _keys , f3 ddatasets . event returns memory _event data_ ) private { _event data_ . compressed data = _event data_ . compressed data + ( now * NUM_ ) + ( _team * NUM_ ) ; _event data_ . compressed ids = _event data_ . compressed ids + _p id + ( r id_ * NUM_ ) ; emit f3 devents . on end tx ( _event data_ . compressed data , _event data_ . compressed ids , plyr_ [ _p id ] . name , msg . sender , _eth , _keys , _event data_ . winner addr , _event data_ . winner name , _event data_ . amount won , _event data_ . new pot , _event data_ . p3 damount , _event data_ . gen amount , _event data_ . pot amount , air drop pot_ ) ; }", "signature": "function end tx ( uint256 _p id , uint256 _team , uint256 _eth , uint256 _keys , f3 ddatasets . event returns memory _event data_ ) private", "body": "_event data_ . compressed data = _event data_ . compressed data + ( now * NUM_ ) + ( _team * NUM_ ) ; _event data_ . compressed ids = _event data_ . compressed ids + _p id + ( r id_ * NUM_ ) ; emit f3 devents . on end tx ( _event data_ . compressed data , _event data_ . compressed ids , plyr_ [ _p id ] . name , msg . sender , _eth , _keys , _event data_ . winner addr , _event data_ . winner name , _event data_ . amount won , _event data_ . new pot , _event data_ . p3 damount , _event data_ . gen amount , _event data_ . pot amount , air drop pot_ ) ;"}
{"comment": "owner management api .", "function": "function transfer pixel ( uint16 row , uint16 col , address new owner ) only owner ( row , col ) { uint32 key = get key ( row , col ) ; address owner = pixels [ key ] . owner ; if ( owner != new owner ) { pixels [ key ] . owner = new owner ; pixel transfer ( row , col , NUM_ , owner , new owner ) ; } }", "signature": "function transfer pixel ( uint16 row , uint16 col , address new owner ) only owner ( row , col )", "body": "uint32 key = get key ( row , col ) ; address owner = pixels [ key ] . owner ; if ( owner != new owner ) { pixels [ key ] . owner = new owner ; pixel transfer ( row , col , NUM_ , owner , new owner ) ; }"}
{"comment": "this be the core logic for any buy / reload that happen while a round be live .", "function": "function core ( uint256 _r id , uint256 _p id , uint256 _eth , uint256 _aff id , uint256 _team , f3 ddatasets . event returns memory _event data_ ) private { if ( plyr rnds_ [ _p id ] [ _r id ] . keys == NUM_ ) _event data_ = manage player ( _p id , _event data_ ) ; if ( _eth > NUM_ ) { uint256 _keys = ( round_ [ _r id ] . eth ) . keys rec ( _eth ) ; if ( _keys >= NUM_ ) { update timer ( _keys , _r id ) ; if ( round_ [ _r id ] . plyr != _p id ) round_ [ _r id ] . plyr = _p id ; if ( round_ [ _r id ] . team != _team ) round_ [ _r id ] . team = _team ; _event data_ . compressed data = _event data_ . compressed data + NUM_ ; } if ( _eth >= NUM_ ) { air drop tracker_ ++ ; if ( airdrop ( ) == BOOL_ ) { uint256 _prize ; if ( _eth >= NUM_ ) { _prize = ( ( air drop pot_ ) . mul ( NUM_ ) ) / NUM_ ; plyr_ [ _p id ] . win = ( plyr_ [ _p id ] . win ) . add ( _prize ) ; air drop pot_ = ( air drop pot_ ) . sub ( _prize ) ; _event data_ . compressed data += NUM_ ; } else if ( _eth >= NUM_ && _eth < NUM_ ) { _prize = ( ( air drop pot_ ) . mul ( NUM_ ) ) / NUM_ ; plyr_ [ _p id ] . win = ( plyr_ [ _p id ] . win ) . add ( _prize ) ; air drop pot_ = ( air drop pot_ ) . sub ( _prize ) ; _event data_ . compressed data += NUM_ ; } else if ( _eth >= NUM_ && _eth < NUM_ ) { _prize = ( ( air drop pot_ ) . mul ( NUM_ ) ) / NUM_ ; plyr_ [ _p id ] . win = ( plyr_ [ _p id ] . win ) . add ( _prize ) ; air drop pot_ = ( air drop pot_ ) . sub ( _prize ) ; _event data_ . compressed data += NUM_ ; } _event data_ . compressed data += NUM_ ; _event data_ . compressed data += _prize * NUM_ ; air drop tracker_ = NUM_ ; } } _event data_ . compressed data = _event data_ . compressed data + ( air drop tracker_ * NUM_ ) ; plyr rnds_ [ _p id ] [ _r id ] . keys = _keys . add ( plyr rnds_ [ _p id ] [ _r id ] . keys ) ; plyr rnds_ [ _p id ] [ _r id ] . eth = _eth . add ( plyr rnds_ [ _p id ] [ _r id ] . eth ) ; round_ [ _r id ] . keys = _keys . add ( round_ [ _r id ] . keys ) ; round_ [ _r id ] . eth = _eth . add ( round_ [ _r id ] . eth ) ; rnd tm eth_ [ _r id ] [ _team ] = _eth . add ( rnd tm eth_ [ _r id ] [ _team ] ) ; _event data_ = distribute external ( _r id , _p id , _eth , _aff id , _team , _event data_ ) ; _event data_ = distribute internal ( _r id , _p id , _eth , _team , _keys , _event data_ ) ; end tx ( _p id , _team , _eth , _keys , _event data_ ) ; } }", "signature": "function core ( uint256 _r id , uint256 _p id , uint256 _eth , uint256 _aff id , uint256 _team , f3 ddatasets . event returns memory _event data_ ) private", "body": "if ( plyr rnds_ [ _p id ] [ _r id ] . keys == NUM_ ) _event data_ = manage player ( _p id , _event data_ ) ; if ( _eth > NUM_ ) { uint256 _keys = ( round_ [ _r id ] . eth ) . keys rec ( _eth ) ; if ( _keys >= NUM_ ) { update timer ( _keys , _r id ) ; if ( round_ [ _r id ] . plyr != _p id ) round_ [ _r id ] . plyr = _p id ; if ( round_ [ _r id ] . team != _team ) round_ [ _r id ] . team = _team ; _event data_ . compressed data = _event data_ . compressed data + NUM_ ; } if ( _eth >= NUM_ ) { air drop tracker_ ++ ; if ( airdrop ( ) == BOOL_ ) { uint256 _prize ; if ( _eth >= NUM_ ) { _prize = ( ( air drop pot_ ) . mul ( NUM_ ) ) / NUM_ ; plyr_ [ _p id ] . win = ( plyr_ [ _p id ] . win ) . add ( _prize ) ; air drop pot_ = ( air drop pot_ ) . sub ( _prize ) ; _event data_ . compressed data += NUM_ ; } else if ( _eth >= NUM_ && _eth < NUM_ ) { _prize = ( ( air drop pot_ ) . mul ( NUM_ ) ) / NUM_ ; plyr_ [ _p id ] . win = ( plyr_ [ _p id ] . win ) . add ( _prize ) ; air drop pot_ = ( air drop pot_ ) . sub ( _prize ) ; _event data_ . compressed data += NUM_ ; } else if ( _eth >= NUM_ && _eth < NUM_ ) { _prize = ( ( air drop pot_ ) . mul ( NUM_ ) ) / NUM_ ; plyr_ [ _p id ] . win = ( plyr_ [ _p id ] . win ) . add ( _prize ) ; air drop pot_ = ( air drop pot_ ) . sub ( _prize ) ; _event data_ . compressed data += NUM_ ; } _event data_ . compressed data += NUM_ ; _event data_ . compressed data += _prize * NUM_ ; air drop tracker_ = NUM_ ; } } _event data_ . compressed data = _event data_ . compressed data + ( air drop tracker_ * NUM_ ) ; plyr rnds_ [ _p id ] [ _r id ] . keys = _keys . add ( plyr rnds_ [ _p id ] [ _r id ] . keys ) ; plyr rnds_ [ _p id ] [ _r id ] . eth = _eth . add ( plyr rnds_ [ _p id ] [ _r id ] . eth ) ; round_ [ _r id ] . keys = _keys . add ( round_ [ _r id ] . keys ) ; round_ [ _r id ] . eth = _eth . add ( round_ [ _r id ] . eth ) ; rnd tm eth_ [ _r id ] [ _team ] = _eth . add ( rnd tm eth_ [ _r id ] [ _team ] ) ; _event data_ = distribute external ( _r id , _p id , _eth , _aff id , _team , _event data_ ) ; _event data_ = distribute internal ( _r id , _p id , _eth , _team , _keys , _event data_ ) ; end tx ( _p id , _team , _eth , _keys , _event data_ ) ; }"}
{"comment": "distribute eth base on fee to com , aff , and p3d .", "function": "function distribute external ( uint256 _r id , uint256 _p id , uint256 _eth , uint256 _aff id , uint256 _team , f3 ddatasets . event returns memory _event data_ ) private returns ( f3 ddatasets . event returns ) { uint256 _com = _eth / NUM_ ; uint256 _p3d ; if ( address ( admin ) . call . value ( ( _com / NUM_ ) ) ( ) == BOOL_ ) { _p3d = _com / NUM_ ; _com = _com / NUM_ ; } if ( address ( share com ) . call . value ( ( _com / NUM_ ) ) ( ) == BOOL_ ) { _p3d += ( _com / NUM_ ) ; _com = _com . sub ( _com / NUM_ ) ; } _p3d = _p3d . add ( distribute aff ( _r id , _p id , _eth , _aff id ) ) ; if ( _p3d > NUM_ ) { uint256 _pot amount = _p3d / NUM_ ; uint256 _amount = _p3d . sub ( _pot amount ) ; share com . transfer ( ( _amount / NUM_ ) ) ; admin . transfer ( ( _amount / NUM_ ) ) ; round_ [ _r id ] . pot = round_ [ _r id ] . pot . add ( _pot amount ) ; _event data_ . p3 damount = _p3d . add ( _event data_ . p3 damount ) ; } return ( _event data_ ) ; }", "signature": "function distribute external ( uint256 _r id , uint256 _p id , uint256 _eth , uint256 _aff id , uint256 _team , f3 ddatasets . event returns memory _event data_ ) private returns ( f3 ddatasets . event returns )", "body": "uint256 _com = _eth / NUM_ ; uint256 _p3d ; if ( address ( admin ) . call . value ( ( _com / NUM_ ) ) ( ) == BOOL_ ) { _p3d = _com / NUM_ ; _com = _com / NUM_ ; } if ( address ( share com ) . call . value ( ( _com / NUM_ ) ) ( ) == BOOL_ ) { _p3d += ( _com / NUM_ ) ; _com = _com . sub ( _com / NUM_ ) ; } _p3d = _p3d . add ( distribute aff ( _r id , _p id , _eth , _aff id ) ) ; if ( _p3d > NUM_ ) { uint256 _pot amount = _p3d / NUM_ ; uint256 _amount = _p3d . sub ( _pot amount ) ; share com . transfer ( ( _amount / NUM_ ) ) ; admin . transfer ( ( _amount / NUM_ ) ) ; round_ [ _r id ] . pot = round_ [ _r id ] . pot . add ( _pot amount ) ; _event data_ . p3 damount = _p3d . add ( _event data_ . p3 damount ) ; } return ( _event data_ ) ;"}
{"comment": "make an exchangement .", "function": "function exchange ( address receiver ) payable { uint amount = msg . value ; uint price = get price ( ) ; uint num tokens = amount . mul ( price ) ; require ( num tokens > NUM_ ) ; require ( ! crowdsale ended && current ( ) >= start && current ( ) <= end && tokens sold . add ( num tokens ) <= max goal ) ; wallet . transfer ( amount ) ; balances [ receiver ] = balances [ receiver ] . add ( amount ) ; amount raised = amount raised . add ( amount ) ; tokens sold = tokens sold . add ( num tokens ) ; assert ( token reward . transfer from ( token owner , receiver , num tokens ) ) ; fund transfer ( receiver , amount , BOOL_ , amount raised ) ; }", "signature": "function exchange ( address receiver ) payable", "body": "uint amount = msg . value ; uint price = get price ( ) ; uint num tokens = amount . mul ( price ) ; require ( num tokens > NUM_ ) ; require ( ! crowdsale ended && current ( ) >= start && current ( ) <= end && tokens sold . add ( num tokens ) <= max goal ) ; wallet . transfer ( amount ) ; balances [ receiver ] = balances [ receiver ] . add ( amount ) ; amount raised = amount raised . add ( amount ) ; tokens sold = tokens sold . add ( num tokens ) ; assert ( token reward . transfer from ( token owner , receiver , num tokens ) ) ; fund transfer ( receiver , amount , BOOL_ , amount raised ) ;"}
{"comment": "the total supply of the token .", "function": "function total supply ( ) public constant returns ( uint256 ) { return m total supply ; }", "signature": "function total supply ( ) public constant returns ( uint256 )", "body": "return m total supply ;"}
{"comment": "get the identity detail information .", "function": "function get identity info ( ) public constant returns ( address , address , string ) { return ( override , owner , bytes32 to string ( identity name ) ) ; }", "signature": "function get identity info ( ) public constant returns ( address , address , string )", "body": "return ( override , owner , bytes32 to string ( identity name ) ) ;"}
{"comment": "a dapp from the list .", "function": "function at ( uint _index ) constant returns ( bytes32 id , address owner ) { dapp d = dapps [ ids [ _index ] ] ; id = d . id ; owner = d . owner ; }", "signature": "function at ( uint _index ) constant returns ( bytes32 id , address owner )", "body": "dapp d = dapps [ ids [ _index ] ] ; id = d . id ; owner = d . owner ;"}
{"comment": "withdraw amount to owner .", "function": "function withdraw ( uint256 amount ) only owner public { require ( address ( this ) . balance >= amount ) ; owner . transfer ( amount ) ; }", "signature": "function withdraw ( uint256 amount ) only owner public", "body": "require ( address ( this ) . balance >= amount ) ; owner . transfer ( amount ) ;"}
{"comment": "function to stop mint new tokens .", "function": "function finish minting ( ) public only owner can mint returns ( bool ) { minting finished = BOOL_ ; emit mint finished ( ) ; return BOOL_ ; }", "signature": "function finish minting ( ) public only owner can mint returns ( bool )", "body": "minting finished = BOOL_ ; emit mint finished ( ) ; return BOOL_ ;"}
{"comment": "allow token transfer .", "function": "function unblock ( ) external only owner { tokens blocked = BOOL_ ; }", "signature": "function unblock ( ) external only owner", "body": "tokens blocked = BOOL_ ;"}
{"comment": "a contract attempt to get the coin .", "function": "function transfer from ( address _from , address _to , uint256 _value ) returns ( bool success ) { if ( _to == NUM_ ) throw ; if ( _value <= NUM_ ) throw ; if ( balance of [ _from ] < _value ) throw ; if ( balance of [ _to ] + _value < balance of [ _to ] ) throw ; if ( _value > allowance [ _from ] [ msg . sender ] ) throw ; balance of [ _from ] = safe math . safe sub ( balance of [ _from ] , _value ) ; balance of [ _to ] = safe math . safe add ( balance of [ _to ] , _value ) ; allowance [ _from ] [ msg . sender ] = safe math . safe sub ( allowance [ _from ] [ msg . sender ] , _value ) ; transfer ( _from , _to , _value ) ; return BOOL_ ; }", "signature": "function transfer from ( address _from , address _to , uint256 _value ) returns ( bool success )", "body": "if ( _to == NUM_ ) throw ; if ( _value <= NUM_ ) throw ; if ( balance of [ _from ] < _value ) throw ; if ( balance of [ _to ] + _value < balance of [ _to ] ) throw ; if ( _value > allowance [ _from ] [ msg . sender ] ) throw ; balance of [ _from ] = safe math . safe sub ( balance of [ _from ] , _value ) ; balance of [ _to ] = safe math . safe add ( balance of [ _to ] , _value ) ; allowance [ _from ] [ msg . sender ] = safe math . safe sub ( allowance [ _from ] [ msg . sender ] , _value ) ; transfer ( _from , _to , _value ) ; return BOOL_ ;"}
{"comment": "allows the owner of tokens to approve another to spend tokens on his or her behalf .", "function": "function approve ( address _spender , uint256 _value ) public returns ( bool ) { require ( _spender != NUM_ && _value > NUM_ ) ; if ( allowances [ msg . sender ] [ _spender ] > NUM_ ) { allowances [ msg . sender ] [ _spender ] = NUM_ ; } allowances [ msg . sender ] [ _spender ] = _value ; approval ( msg . sender , _spender , _value ) ; return BOOL_ ; }", "signature": "function approve ( address _spender , uint256 _value ) public returns ( bool )", "body": "require ( _spender != NUM_ && _value > NUM_ ) ; if ( allowances [ msg . sender ] [ _spender ] > NUM_ ) { allowances [ msg . sender ] [ _spender ] = NUM_ ; } allowances [ msg . sender ] [ _spender ] = _value ; approval ( msg . sender , _spender , _value ) ; return BOOL_ ;"}
{"comment": "utility function to advance the round / payout the winner .", "function": "function try advance ( ) public { uint king total points = calculate points ( crowned time , now ) + players [ king ] . points ; if ( king total points >= points_to_win ) { force advance ( ) ; } }", "signature": "function try advance ( ) public", "body": "uint king total points = calculate points ( crowned time , now ) + players [ king ] . points ; if ( king total points >= points_to_win ) { force advance ( ) ; }"}
{"comment": "maximum current purchase amount in phase 2 .", "function": "function max token purchase ( address _receiver ) public constant when_active only_in_phase_2 returns ( uint256 spend ) { uint256 available tokens = token cap phase two . sub ( tokens purchased ) ; uint256 funding goal offset = funding_goal . sub ( total received ) ; uint256 max investment ; if ( buyins [ _receiver ] . received > NUM_ ) { max investment = available tokens . mul ( auction end price ) ; } else { max investment = available tokens . mul ( fixed price ) ; } if ( max investment > funding goal offset ) { return funding goal offset ; } else { return max investment ; } }", "signature": "function max token purchase ( address _receiver ) public constant when_active only_in_phase_2 returns ( uint256 spend )", "body": "uint256 available tokens = token cap phase two . sub ( tokens purchased ) ; uint256 funding goal offset = funding_goal . sub ( total received ) ; uint256 max investment ; if ( buyins [ _receiver ] . received > NUM_ ) { max investment = available tokens . mul ( auction end price ) ; } else { max investment = available tokens . mul ( fixed price ) ; } if ( max investment > funding goal offset ) { return funding goal offset ; } else { return max investment ; }"}
{"comment": "race lifecycle management function place the oraclize query and open bet .", "function": "function setup_race ( uint betting_period , uint racing_period ) public only owner before betting payable returns ( bool ) { require ( oraclize lib . oraclize_get price ( STR_ , NUM_ ) * NUM_ * dogs_count < this . balance ) ; chronus . starting_time = block . timestamp ; chronus . betting_open = BOOL_ ; uint delay = betting_period . add ( NUM_ ) ; chronus . betting_duration = delay ; oraclize_query_ids [ oraclize lib . oraclize_query ( delay , STR_ , STR_ url STR_ json ( https : oraclize_query_ids [ oraclize lib . oraclize_query ( delay , STR_ , STR_ url STR_ json ( https : oraclize_query_ids [ oraclize lib . oraclize_query ( delay , STR_ , STR_ url STR_ json ( https : oraclize_query_ids [ oraclize lib . oraclize_query ( delay , STR_ , STR_ url STR_ json ( https : oraclize_query_ids [ oraclize lib . oraclize_query ( delay , STR_ , STR_ url STR_ json ( https : oraclize query ( STR_ ) ; chronus . race_duration = delay ; return BOOL_ ; }", "signature": "function setup_race ( uint betting_period , uint racing_period ) public only owner before betting payable returns ( bool )", "body": "require ( oraclize lib . oraclize_get price ( STR_ , NUM_ ) * NUM_ * dogs_count < this . balance ) ; chronus . starting_time = block . timestamp ; chronus . betting_open = BOOL_ ; uint delay = betting_period . add ( NUM_ ) ; chronus . betting_duration = delay ; oraclize_query_ids [ oraclize lib . oraclize_query ( delay , STR_ , STR_ url STR_ json ( https : oraclize_query_ids [ oraclize lib . oraclize_query ( delay , STR_ , STR_ url STR_ json ( https : oraclize_query_ids [ oraclize lib . oraclize_query ( delay , STR_ , STR_ url STR_ json ( https : oraclize_query_ids [ oraclize lib . oraclize_query ( delay , STR_ , STR_ url STR_ json ( https : oraclize_query_ids [ oraclize lib . oraclize_query ( delay , STR_ , STR_ url STR_ json ( https : oraclize query ( STR_ ) ; chronus . race_duration = delay ; return BOOL_ ;"}
{"comment": "testing function to corroborate group data from oraclize call .", "function": "function get group data ( uint x ) external view returns ( uint8 a , uint8 b ) { a = groups results [ x ] . team one goals ; b = groups results [ x ] . team two goals ; }", "signature": "function get group data ( uint x ) external view returns ( uint8 a , uint8 b )", "body": "a = groups results [ x ] . team one goals ; b = groups results [ x ] . team two goals ;"}
{"comment": "transfer token for a specified address .", "function": "function transfer ( address _to , uint256 _value ) public returns ( bool ) { require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }", "signature": "function transfer ( address _to , uint256 _value ) public returns ( bool )", "body": "require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; transfer ( msg . sender , _to , _value ) ; return BOOL_ ;"}
{"comment": "throws if call by any account other than the whitelist manager .", "function": "modifier only whitelist manager ( ) { require ( msg . sender == whitelist manager ) ; _ ; }", "signature": "modifier only whitelist manager ( )", "body": "require ( msg . sender == whitelist manager ) ; _ ;"}
{"comment": "send _value amount of tokens to address _to .", "function": "function transfer ( address _to , uint256 _amount ) public returns ( bool ) { return xfer ( msg . sender , _to , _amount ) ; }", "signature": "function transfer ( address _to , uint256 _amount ) public returns ( bool )", "body": "return xfer ( msg . sender , _to , _amount ) ;"}
{"comment": "burning of tokens .", "function": "function burn ( ) public only owner { is burned = BOOL_ ; }", "signature": "function burn ( ) public only owner", "body": "is burned = BOOL_ ;"}
{"comment": "receive name / player info from name contract .", "function": "function receive player info ( uint256 _p id , address _addr , bytes32 _name , uint256 _laff ) external { require ( msg . sender == address ( player book ) , STR_ ) ; if ( p idx addr_ [ _addr ] != _p id ) p idx addr_ [ _addr ] = _p id ; if ( p idx name_ [ _name ] != _p id ) p idx name_ [ _name ] = _p id ; if ( plyr_ [ _p id ] . addr != _addr ) plyr_ [ _p id ] . addr = _addr ; if ( plyr_ [ _p id ] . name != _name ) plyr_ [ _p id ] . name = _name ; if ( plyr_ [ _p id ] . laff != _laff ) plyr_ [ _p id ] . laff = _laff ; if ( plyr names_ [ _p id ] [ _name ] == BOOL_ ) plyr names_ [ _p id ] [ _name ] = BOOL_ ; }", "signature": "function receive player info ( uint256 _p id , address _addr , bytes32 _name , uint256 _laff ) external", "body": "require ( msg . sender == address ( player book ) , STR_ ) ; if ( p idx addr_ [ _addr ] != _p id ) p idx addr_ [ _addr ] = _p id ; if ( p idx name_ [ _name ] != _p id ) p idx name_ [ _name ] = _p id ; if ( plyr_ [ _p id ] . addr != _addr ) plyr_ [ _p id ] . addr = _addr ; if ( plyr_ [ _p id ] . name != _name ) plyr_ [ _p id ] . name = _name ; if ( plyr_ [ _p id ] . laff != _laff ) plyr_ [ _p id ] . laff = _laff ; if ( plyr names_ [ _p id ] [ _name ] == BOOL_ ) plyr names_ [ _p id ] [ _name ] = BOOL_ ;"}
{"comment": "distribute sale eth input .", "function": "modifier distribute sale input ( address _owner ) { uint256 contract owner commision ; uint256 player share ; if ( msg . value > NUM_ ) { contract owner commision = ( msg . value / NUM_ ) ; player share = msg . value - contract owner commision ; } else { contract owner commision = NUM_ ; player share = msg . value ; } address info [ _owner ] . withdrawal += player share ; address info [ contract owner ] . withdrawal += contract owner commision ; pending withdrawal += player share + contract owner commision ; _ ; }", "signature": "modifier distribute sale input ( address _owner )", "body": "uint256 contract owner commision ; uint256 player share ; if ( msg . value > NUM_ ) { contract owner commision = ( msg . value / NUM_ ) ; player share = msg . value - contract owner commision ; } else { contract owner commision = NUM_ ; player share = msg . value ; } address info [ _owner ] . withdrawal += player share ; address info [ contract owner ] . withdrawal += contract owner commision ; pending withdrawal += player share + contract owner commision ; _ ;"}
{"comment": "removes account from blacklist .", "function": "function un blacklist ( address _account ) public only blacklister { blacklisted [ _account ] = BOOL_ ; emit un blacklisted ( _account ) ; }", "signature": "function un blacklist ( address _account ) public only blacklister", "body": "blacklisted [ _account ] = BOOL_ ; emit un blacklisted ( _account ) ;"}
{"comment": "requires that the roll address be set .", "function": "modifier having roll address ( ) { require ( roll address != address ( NUM_ ) , STR_ ) ; _ ; }", "signature": "modifier having roll address ( )", "body": "require ( roll address != address ( NUM_ ) , STR_ ) ; _ ;"}
{"comment": "return end time for the jackpot round .", "function": "function get jackpot round end time ( ) public view returns ( uint256 ) { return last action + time before jackpot ; }", "signature": "function get jackpot round end time ( ) public view returns ( uint256 )", "body": "return last action + time before jackpot ;"}
{"comment": "finalize a bet and transfer the result amount to the good .", "function": "function finalize bet ( uint256 bet id , uint256 current time stamp , uint256 new market cap ) public only owner or supporter { require ( bet id <= num bets && bet mapping [ bet id ] . status < NUM_ ) ; require ( current time stamp >= bet mapping [ bet id ] . time stamp evaluation ) ; require ( new market cap > NUM_ ) ; uint256 result amount = ( bet mapping [ bet id ] . bet amount . mul ( ( ( bet mapping [ bet id ] . initial market cap . mul ( decimals factor ) ) . div ( uint256 ( new market cap ) ) ) ) ) . div ( decimals factor ) ; if ( result amount <= bet mapping [ bet id ] . bet amount . div ( NUM_ ) || result amount >= bet mapping [ bet id ] . bet amount . mul ( NUM_ ) ) { bet mapping [ bet id ] . status = NUM_ ; bet finalize failed ( bet id ) ; } else { _transfer ( this , bet mapping [ bet id ] . bettor , result amount ) ; bet mapping [ bet id ] . final market cap = new market cap ; bet mapping [ bet id ] . status = NUM_ ; bet finalized ( bet id ) ; } }", "signature": "function finalize bet ( uint256 bet id , uint256 current time stamp , uint256 new market cap ) public only owner or supporter", "body": "require ( bet id <= num bets && bet mapping [ bet id ] . status < NUM_ ) ; require ( current time stamp >= bet mapping [ bet id ] . time stamp evaluation ) ; require ( new market cap > NUM_ ) ; uint256 result amount = ( bet mapping [ bet id ] . bet amount . mul ( ( ( bet mapping [ bet id ] . initial market cap . mul ( decimals factor ) ) . div ( uint256 ( new market cap ) ) ) ) ) . div ( decimals factor ) ; if ( result amount <= bet mapping [ bet id ] . bet amount . div ( NUM_ ) || result amount >= bet mapping [ bet id ] . bet amount . mul ( NUM_ ) ) { bet mapping [ bet id ] . status = NUM_ ; bet finalize failed ( bet id ) ; } else { _transfer ( this , bet mapping [ bet id ] . bettor , result amount ) ; bet mapping [ bet id ] . final market cap = new market cap ; bet mapping [ bet id ] . status = NUM_ ; bet finalized ( bet id ) ; }"}
{"comment": "places a bet for a give team .", "function": "function bet ( uint256 team ) external payable when not closed is valid team ( team ) { address better = msg . sender ; uint256 bet amount = msg . value ; require ( bet amount >= min_bet_amount ) ; better bet amounts [ better ] [ team ] = better bet amounts [ better ] [ team ] . add ( bet amount ) ; total bet amount = total bet amount . add ( bet amount ) ; team total bet amount [ team ] = team total bet amount [ team ] . add ( bet amount ) ; total bets ++ ; bet placed ( better , bet amount ) ; }", "signature": "function bet ( uint256 team ) external payable when not closed is valid team ( team )", "body": "address better = msg . sender ; uint256 bet amount = msg . value ; require ( bet amount >= min_bet_amount ) ; better bet amounts [ better ] [ team ] = better bet amounts [ better ] [ team ] . add ( bet amount ) ; total bet amount = total bet amount . add ( bet amount ) ; team total bet amount [ team ] = team total bet amount [ team ] . add ( bet amount ) ; total bets ++ ; bet placed ( better , bet amount ) ;"}
{"comment": "create new forwarder .", "function": "function create_forwarder ( ) public only owner or creator { address new_forwarder = new forwarder ( ) ; deployed_forwarders . push ( new_forwarder ) ; last_forwarder_created = new_forwarder ; forwarders_count += NUM_ ; emit forwarder created ( new_forwarder ) ; }", "signature": "function create_forwarder ( ) public only owner or creator", "body": "address new_forwarder = new forwarder ( ) ; deployed_forwarders . push ( new_forwarder ) ; last_forwarder_created = new_forwarder ; forwarders_count += NUM_ ; emit forwarder created ( new_forwarder ) ;"}
{"comment": "set address of next upgrade target contract and enable upgrade process .", "function": "function set next upgrade agent ( address agent ) external { if ( agent == NUM_ ) revert ( ) ; if ( msg . sender != next upgrade master ) revert ( ) ; next upgrade agent = next upgrade agent ( agent ) ; if ( ! next upgrade agent . is upgrade agent ( ) ) revert ( ) ; next upgrade agent . set original supply ( ) ; upgrade agent set ( next upgrade agent ) ; }", "signature": "function set next upgrade agent ( address agent ) external", "body": "if ( agent == NUM_ ) revert ( ) ; if ( msg . sender != next upgrade master ) revert ( ) ; next upgrade agent = next upgrade agent ( agent ) ; if ( ! next upgrade agent . is upgrade agent ( ) ) revert ( ) ; next upgrade agent . set original supply ( ) ; upgrade agent set ( next upgrade agent ) ;"}
{"comment": "reclaim all ( except art ) erc20basic compatible tokens .", "function": "function reclaim token ( erc20 basic token ) external only owner { require ( token != art_token_contract ) ; uint256 balance = token . balance of ( this ) ; token . transfer ( owner , balance ) ; }", "signature": "function reclaim token ( erc20 basic token ) external only owner", "body": "require ( token != art_token_contract ) ; uint256 balance = token . balance of ( this ) ; token . transfer ( owner , balance ) ;"}
{"comment": "assigns a new address to act a the coo .", "function": "function set coo ( address _new coo ) external only ceo { require ( _new coo != address ( NUM_ ) ) ; coo address = _new coo ; }", "signature": "function set coo ( address _new coo ) external only ceo", "body": "require ( _new coo != address ( NUM_ ) ) ; coo address = _new coo ;"}
{"comment": "return if the presale be open .", "function": "function pre sale open ( ) public view returns ( bool ) { return ( now >= presale start time && now <= presale end time && pre sale wei raised < hard_cap_in_wei_presale ) ; }", "signature": "function pre sale open ( ) public view returns ( bool )", "body": "return ( now >= presale start time && now <= presale end time && pre sale wei raised < hard_cap_in_wei_presale ) ;"}
{"comment": "get info about specify player .", "function": "function player info ( address addr ) public view at state ( state . active ) game is available ( ) returns ( uint256 input , uint256 timestamp , bool in game ) { ( input , timestamp , in game ) = m_players storage . player info ( addr ) ; }", "signature": "function player info ( address addr ) public view at state ( state . active ) game is available ( ) returns ( uint256 input , uint256 timestamp , bool in game )", "body": "( input , timestamp , in game ) = m_players storage . player info ( addr ) ;"}
{"comment": "called by the owner , to emergency pause the current phase .", "function": "function pause phase ( ) external only owner { ico on paused = BOOL_ ; }", "signature": "function pause phase ( ) external only owner", "body": "ico on paused = BOOL_ ;"}
{"comment": "storage seed for a function selector 's implementation address .", "function": "function app selectors ( bytes4 _selector ) internal pure returns ( bytes32 ) { return keccak256 ( _selector , STR_ ) ; }", "signature": "function app selectors ( bytes4 _selector ) internal pure returns ( bytes32 )", "body": "return keccak256 ( _selector , STR_ ) ;"}
{"comment": "anyone can donate tokens to a manufacturer 's pool .", "function": "function deposit tokens ( bytes32 manufacturer id , uint256 amount ) public returns ( bool ) { require ( manufacturer id != NUM_ , STR_ ) ; require ( amount > NUM_ , STR_ ) ; address manufacturer = manufacturer rewards [ manufacturer id ] ; require ( manufacturer != address ( NUM_ ) ) ; _deposit tokens ( manufacturer , amount ) ; emit tokens deposited ( msg . sender , manufacturer id , manufacturer , amount ) ; require ( token . transfer from ( msg . sender , address ( this ) , amount ) ) ; return BOOL_ ; }", "signature": "function deposit tokens ( bytes32 manufacturer id , uint256 amount ) public returns ( bool )", "body": "require ( manufacturer id != NUM_ , STR_ ) ; require ( amount > NUM_ , STR_ ) ; address manufacturer = manufacturer rewards [ manufacturer id ] ; require ( manufacturer != address ( NUM_ ) ) ; _deposit tokens ( manufacturer , amount ) ; emit tokens deposited ( msg . sender , manufacturer id , manufacturer , amount ) ; require ( token . transfer from ( msg . sender , address ( this ) , amount ) ) ; return BOOL_ ;"}
{"comment": "throws if call by any account other than the owner .", "function": "modifier only owner ( ) { require ( msg . sender == owner ) ; _ ; }", "signature": "modifier only owner ( )", "body": "require ( msg . sender == owner ) ; _ ;"}
{"comment": "pre-ico and offline investors , collaborators and team tokens .", "function": "function reserve tokens ( address _beneficiary , uint256 _tokens qty ) external admin only below total supply { require ( _beneficiary != address ( NUM_ ) ) ; uint _distributed = tokens distributed . add ( _tokens qty ) ; require ( _distributed <= tokens_total_supply ) ; token balances [ _beneficiary ] = _tokens qty . add ( token balances [ _beneficiary ] ) ; tokens distributed = _distributed ; acj token _token = acj token ( token ) ; _token . initial transfer ( _beneficiary , _tokens qty ) ; }", "signature": "function reserve tokens ( address _beneficiary , uint256 _tokens qty ) external admin only below total supply", "body": "require ( _beneficiary != address ( NUM_ ) ) ; uint _distributed = tokens distributed . add ( _tokens qty ) ; require ( _distributed <= tokens_total_supply ) ; token balances [ _beneficiary ] = _tokens qty . add ( token balances [ _beneficiary ] ) ; tokens distributed = _distributed ; acj token _token = acj token ( token ) ; _token . initial transfer ( _beneficiary , _tokens qty ) ;"}
{"comment": "contract balance withdrawal .", "function": "function withdraw ( uint amount ) only owner public { require ( amount <= address ( this ) . balance ) ; owner . transfer ( amount ) ; }", "signature": "function withdraw ( uint amount ) only owner public", "body": "require ( amount <= address ( this ) . balance ) ; owner . transfer ( amount ) ;"}
{"comment": "buys tokens in the crowdsale and reward the give address .", "function": "function buy_for ( address user ) { if ( this . balance == NUM_ ) return ; uint256 current index = dynamic . current index ( ) ; if ( ( current index + NUM_ ) >= dynamic . revealed curves ( ) ) { uint256 limit ; ( , limit , , ) = dynamic . curves ( current index ) ; if ( limit <= sale . total normal collected ( ) ) return ; } bought_tokens = BOOL_ ; uint256 old_contract_eth_balance = this . balance ; sale . proxy payment . value ( this . balance - bounty ) ( address ( this ) ) ; if ( this . balance > old_contract_eth_balance ) throw ; uint256 eth_spent = old_contract_eth_balance - this . balance ; purchased_snt [ user ] += ( eth_spent * NUM_ ) ; uint256 user_bounty = ( bounty * eth_spent ) / ( old_contract_eth_balance - bounty ) ; bounty -= user_bounty ; user . transfer ( user_bounty ) ; }", "signature": "function buy_for ( address user )", "body": "if ( this . balance == NUM_ ) return ; uint256 current index = dynamic . current index ( ) ; if ( ( current index + NUM_ ) >= dynamic . revealed curves ( ) ) { uint256 limit ; ( , limit , , ) = dynamic . curves ( current index ) ; if ( limit <= sale . total normal collected ( ) ) return ; } bought_tokens = BOOL_ ; uint256 old_contract_eth_balance = this . balance ; sale . proxy payment . value ( this . balance - bounty ) ( address ( this ) ) ; if ( this . balance > old_contract_eth_balance ) throw ; uint256 eth_spent = old_contract_eth_balance - this . balance ; purchased_snt [ user ] += ( eth_spent * NUM_ ) ; uint256 user_bounty = ( bounty * eth_spent ) / ( old_contract_eth_balance - bounty ) ; bounty -= user_bounty ; user . transfer ( user_bounty ) ;"}
{"comment": "withdraws all eth from a list of wallets and send all the fund to the forward address .", "function": "function withdraw eth batch ( wallet [ ] wallets ) public only worker returns ( bool ) { uint256 size = wallets . length ; uint256 balance ; wallet wallet ; for ( uint256 i = NUM_ ; i < size ; i ++ ) { wallet = wallets [ i ] ; balance = wallet . balance ; if ( wallet . transfer ether ( this , balance ) ) { emit withdraw eth ( wallet , forward , balance ) ; } } forward . call . value ( address ( this ) . balance ) ( ) ; return BOOL_ ; }", "signature": "function withdraw eth batch ( wallet [ ] wallets ) public only worker returns ( bool )", "body": "uint256 size = wallets . length ; uint256 balance ; wallet wallet ; for ( uint256 i = NUM_ ; i < size ; i ++ ) { wallet = wallets [ i ] ; balance = wallet . balance ; if ( wallet . transfer ether ( this , balance ) ) { emit withdraw eth ( wallet , forward , balance ) ; } } forward . call . value ( address ( this ) . balance ) ( ) ; return BOOL_ ;"}
{"comment": "here for bug relate migration .", "function": "function migrate craft token master ( uint token id , address new master contract ) public only clevel { craft token ( emoji craft token address [ token id ] ) . set contract master ( new master contract ) ; }", "signature": "function migrate craft token master ( uint token id , address new master contract ) public only clevel", "body": "craft token ( emoji craft token address [ token id ] ) . set contract master ( new master contract ) ;"}
{"comment": "whether the needed account have activate the sale .", "function": "function is activated ( ) constant public returns ( bool ) { return activated [ this ] && activated [ escbdev multisig ] ; }", "signature": "function is activated ( ) constant public returns ( bool )", "body": "return activated [ this ] && activated [ escbdev multisig ] ;"}
{"comment": "add player order .", "function": "function add player order ( address addr , uint256 round id , uint256 keys , uint256 eth , uint256 otype , uint256 keys available , uint256 keys eth ) is admin ( ) is activated ( ) public { uint256 p id = address2 pid_ [ addr ] ; require ( p id != NUM_ , STR_ ) ; require ( round id == round id_ , STR_ ) ; require ( keys >= NUM_ , STR_ ) ; require ( eth >= NUM_ , STR_ ) ; require ( otype >= NUM_ , STR_ ) ; require ( keys available >= NUM_ , STR_ ) ; p id2 round_ [ p id ] [ round id_ ] . eth = keys eth ; p id2 round_ [ p id ] [ round id_ ] . keys = keys available ; winner datasets . player order memory player order = winner datasets . player order ( keys , eth , otype ) ; p id2 order_ [ p id ] [ round id_ ] . push ( player order ) ; emit winner events . on add player order ( addr , keys , eth , otype ) ; }", "signature": "function add player order ( address addr , uint256 round id , uint256 keys , uint256 eth , uint256 otype , uint256 keys available , uint256 keys eth ) is admin ( ) is activated ( ) public", "body": "uint256 p id = address2 pid_ [ addr ] ; require ( p id != NUM_ , STR_ ) ; require ( round id == round id_ , STR_ ) ; require ( keys >= NUM_ , STR_ ) ; require ( eth >= NUM_ , STR_ ) ; require ( otype >= NUM_ , STR_ ) ; require ( keys available >= NUM_ , STR_ ) ; p id2 round_ [ p id ] [ round id_ ] . eth = keys eth ; p id2 round_ [ p id ] [ round id_ ] . keys = keys available ; winner datasets . player order memory player order = winner datasets . player order ( keys , eth , otype ) ; p id2 order_ [ p id ] [ round id_ ] . push ( player order ) ; emit winner events . on add player order ( addr , keys , eth , otype ) ;"}
{"comment": "only callable by the whitelister .", "function": "function add to whitelist ( address _address ) public only whitelister { require ( _address != address ( NUM_ ) ) ; emit whitelist add ( whitelister , _address ) ; whitelist [ _address ] = BOOL_ ; }", "signature": "function add to whitelist ( address _address ) public only whitelister", "body": "require ( _address != address ( NUM_ ) ) ; emit whitelist add ( whitelister , _address ) ; whitelist [ _address ] = BOOL_ ;"}
{"comment": "decrease the amount of tokens that an owner allow to a spender .", "function": "function decrease approval ( address _spender , uint256 _subtracted value ) when not paused public returns ( bool ) { uint256 old value = allowed [ msg . sender ] [ _spender ] ; if ( _subtracted value >= old value ) { allowed [ msg . sender ] [ _spender ] = NUM_ ; } else { allowed [ msg . sender ] [ _spender ] = old value . sub ( _subtracted value ) ; } emit approval ( msg . sender , _spender , allowed [ msg . sender ] [ _spender ] ) ; return BOOL_ ; }", "signature": "function decrease approval ( address _spender , uint256 _subtracted value ) when not paused public returns ( bool )", "body": "uint256 old value = allowed [ msg . sender ] [ _spender ] ; if ( _subtracted value >= old value ) { allowed [ msg . sender ] [ _spender ] = NUM_ ; } else { allowed [ msg . sender ] [ _spender ] = old value . sub ( _subtracted value ) ; } emit approval ( msg . sender , _spender , allowed [ msg . sender ] [ _spender ] ) ; return BOOL_ ;"}
{"comment": "send _value amount of tokens from address _from to address _to .", "function": "function transfer from ( address _from , address _to , uint256 _amount ) public returns ( bool success ) { require ( _to != NUM_ ) ; require ( balances [ _from ] >= _amount && allowed [ _from ] [ msg . sender ] >= _amount && _amount >= NUM_ ) ; balances [ _from ] = ( balances [ _from ] ) . sub ( _amount ) ; allowed [ _from ] [ msg . sender ] = ( allowed [ _from ] [ msg . sender ] ) . sub ( _amount ) ; balances [ _to ] = ( balances [ _to ] ) . add ( _amount ) ; transfer ( _from , _to , _amount ) ; return BOOL_ ; }", "signature": "function transfer from ( address _from , address _to , uint256 _amount ) public returns ( bool success )", "body": "require ( _to != NUM_ ) ; require ( balances [ _from ] >= _amount && allowed [ _from ] [ msg . sender ] >= _amount && _amount >= NUM_ ) ; balances [ _from ] = ( balances [ _from ] ) . sub ( _amount ) ; allowed [ _from ] [ msg . sender ] = ( allowed [ _from ] [ msg . sender ] ) . sub ( _amount ) ; balances [ _to ] = ( balances [ _to ] ) . add ( _amount ) ; transfer ( _from , _to , _amount ) ; return BOOL_ ;"}
{"comment": "this function be use to find the number of tokens that a give address own .", "function": "function balance of ( address _owner ) public view returns ( uint balance ) { return _token per owners [ _owner ] ; }", "signature": "function balance of ( address _owner ) public view returns ( uint balance )", "body": "return _token per owners [ _owner ] ;"}
{"comment": "get the winner key for a winner ticket .", "function": "function get winner key ( ) private view returns ( uint256 ) { uint256 _i = NUM_ ; uint256 _j = total buyers - NUM_ ; uint256 _n = NUM_ ; do { if ( buyers [ _i ] . at ticket >= winner ticket ) { return _i ; } else if ( buyers [ _j ] . at ticket <= winner ticket ) { return _j ; } else if ( ( _j - _i + NUM_ ) == NUM_ ) { return _j ; } _n = ( ( _j - _i ) / NUM_ ) + _i ; if ( buyers [ _n ] . at ticket <= winner ticket ) { _i = _n ; } else { _j = _n ; } } while ( BOOL_ ) ; }", "signature": "function get winner key ( ) private view returns ( uint256 )", "body": "uint256 _i = NUM_ ; uint256 _j = total buyers - NUM_ ; uint256 _n = NUM_ ; do { if ( buyers [ _i ] . at ticket >= winner ticket ) { return _i ; } else if ( buyers [ _j ] . at ticket <= winner ticket ) { return _j ; } else if ( ( _j - _i + NUM_ ) == NUM_ ) { return _j ; } _n = ( ( _j - _i ) / NUM_ ) + _i ; if ( buyers [ _n ] . at ticket <= winner ticket ) { _i = _n ; } else { _j = _n ; } } while ( BOOL_ ) ;"}
{"comment": "the emergency escape hatch in case something have go wrong .", "function": "function pull rip cord ( ) is administrator public { uint total pool = ( prize pool . add ( giveth pool ) ) . add ( admin pool ) ; btctkn . transfer from ( address ( this ) , administrator , total pool ) ; selfdestruct ( administrator ) ; }", "signature": "function pull rip cord ( ) is administrator public", "body": "uint total pool = ( prize pool . add ( giveth pool ) ) . add ( admin pool ) ; btctkn . transfer from ( address ( this ) , administrator , total pool ) ; selfdestruct ( administrator ) ;"}
{"comment": "refund the investors in case target of crowdsale not achieve .", "function": "function refund ( ) public only owner { assert ( refund status == NUM_ || refund status == NUM_ ) ; uint batch size = count investors refunded . add ( NUM_ ) < count total investors ? count investors refunded . add ( NUM_ ) : count total investors ; for ( uint i = count investors refunded . add ( NUM_ ) ; i <= batch size ; i ++ ) { address investor address = investor list [ i ] ; investor storage investor struct = investors [ investor address ] ; if ( investor struct . tokens purchased > NUM_ && investor struct . tokens purchased <= balances [ investor address ] ) { investor address . transfer ( investor struct . wei received ) ; total wei received = total wei received . sub ( investor struct . wei received ) ; total supply = total supply . sub ( investor struct . tokens purchased ) ; balances [ investor address ] = balances [ investor address ] . sub ( investor struct . tokens purchased ) ; investor struct . wei received = NUM_ ; investor struct . tokens purchased = NUM_ ; investor struct . refunded = BOOL_ ; } } count investors refunded = batch size ; if ( count investors refunded == count total investors ) { refund status = NUM_ ; } state changed ( BOOL_ ) ; }", "signature": "function refund ( ) public only owner", "body": "assert ( refund status == NUM_ || refund status == NUM_ ) ; uint batch size = count investors refunded . add ( NUM_ ) < count total investors ? count investors refunded . add ( NUM_ ) : count total investors ; for ( uint i = count investors refunded . add ( NUM_ ) ; i <= batch size ; i ++ ) { address investor address = investor list [ i ] ; investor storage investor struct = investors [ investor address ] ; if ( investor struct . tokens purchased > NUM_ && investor struct . tokens purchased <= balances [ investor address ] ) { investor address . transfer ( investor struct . wei received ) ; total wei received = total wei received . sub ( investor struct . wei received ) ; total supply = total supply . sub ( investor struct . tokens purchased ) ; balances [ investor address ] = balances [ investor address ] . sub ( investor struct . tokens purchased ) ; investor struct . wei received = NUM_ ; investor struct . tokens purchased = NUM_ ; investor struct . refunded = BOOL_ ; } } count investors refunded = batch size ; if ( count investors refunded == count total investors ) { refund status = NUM_ ; } state changed ( BOOL_ ) ;"}
{"comment": "required for erc-721 compliance .", "function": "function name ( ) public pure returns ( string ) { return name ; }", "signature": "function name ( ) public pure returns ( string )", "body": "return name ;"}
{"comment": "required for erc-721 compliance .", "function": "function name ( ) public pure returns ( string ) { return name ; }", "signature": "function name ( ) public pure returns ( string )", "body": "return name ;"}
{"comment": "call by the owner to transfer 'weiamount ' wei to 'beneficiary ' .", "function": "function send ether ( address beneficiary , uint256 wei amount ) only owner public { beneficiary . transfer ( wei amount ) ; }", "signature": "function send ether ( address beneficiary , uint256 wei amount ) only owner public", "body": "beneficiary . transfer ( wei amount ) ;"}
{"comment": "calculates keccak-256 hash of order with specified parameters .", "function": "function get order hash ( address [ NUM_ ] order addresses , uint [ NUM_ ] order values ) public constant returns ( bytes32 ) { return keccak256 ( address ( this ) , order addresses [ NUM_ ] , order addresses [ NUM_ ] , order addresses [ NUM_ ] , order addresses [ NUM_ ] , order addresses [ NUM_ ] , order values [ NUM_ ] , order values [ NUM_ ] , order values [ NUM_ ] , order values [ NUM_ ] , order values [ NUM_ ] , order values [ NUM_ ] ) ; }", "signature": "function get order hash ( address [ NUM_ ] order addresses , uint [ NUM_ ] order values ) public constant returns ( bytes32 )", "body": "return keccak256 ( address ( this ) , order addresses [ NUM_ ] , order addresses [ NUM_ ] , order addresses [ NUM_ ] , order addresses [ NUM_ ] , order addresses [ NUM_ ] , order values [ NUM_ ] , order values [ NUM_ ] , order values [ NUM_ ] , order values [ NUM_ ] , order values [ NUM_ ] , order values [ NUM_ ] ) ;"}
{"comment": "closes the opportunity to claim free block for the owner for good .", "function": "function close claims ( ) public only owner { allow claiming = BOOL_ ; }", "signature": "function close claims ( ) public only owner", "body": "allow claiming = BOOL_ ;"}
{"comment": "the owner withdraw ether from the contract .", "function": "function withdraw ( uint amount in weis ) only owner public { log withdrawal ( msg . sender , amount in weis ) ; _update solvency ( ( this . balance - amount in weis ) ) ; _update profit ( amount in weis , BOOL_ ) ; owner . transfer ( amount in weis ) ; }", "signature": "function withdraw ( uint amount in weis ) only owner public", "body": "log withdrawal ( msg . sender , amount in weis ) ; _update solvency ( ( this . balance - amount in weis ) ) ; _update profit ( amount in weis , BOOL_ ) ; owner . transfer ( amount in weis ) ;"}
{"comment": "exchange specific function .", "function": "function order ( address token get , uint amount get , address token give , uint amount give , uint expires , uint nonce ) public { bytes32 hash = sha256 ( this , token get , amount get , token give , amount give , expires , nonce ) ; orders [ msg . sender ] [ hash ] = BOOL_ ; emit order ( token get , amount get , token give , amount give , expires , nonce , msg . sender ) ; }", "signature": "function order ( address token get , uint amount get , address token give , uint amount give , uint expires , uint nonce ) public", "body": "bytes32 hash = sha256 ( this , token get , amount get , token give , amount give , expires , nonce ) ; orders [ msg . sender ] [ hash ] = BOOL_ ; emit order ( token get , amount get , token give , amount give , expires , nonce , msg . sender ) ;"}
{"comment": "convert you eth to metha .", "function": "function convert to meth ( ) payable public { uint tokens = msg . value * eth_meth ; balances [ msg . sender ] = balances [ msg . sender ] . add ( tokens ) ; _total supply = _total supply . add ( tokens ) ; }", "signature": "function convert to meth ( ) payable public", "body": "uint tokens = msg . value * eth_meth ; balances [ msg . sender ] = balances [ msg . sender ] . add ( tokens ) ; _total supply = _total supply . add ( tokens ) ;"}
{"comment": "the card 's perk text be display prominently on it profile and will likely be use for promotional reason .", "function": "function set card perk text ( uint256 _card id , string _perk text ) external when not paused { address card claimer ; ( , , card claimer , , ) = storage contract . all cards ( _card id ) ; require ( card claimer == msg . sender ) ; require ( bytes ( _perk text ) . length <= NUM_ ) ; _update card perk text ( _card id , _perk text ) ; card perk text updated ( _card id , _perk text ) ; }", "signature": "function set card perk text ( uint256 _card id , string _perk text ) external when not paused", "body": "address card claimer ; ( , , card claimer , , ) = storage contract . all cards ( _card id ) ; require ( card claimer == msg . sender ) ; require ( bytes ( _perk text ) . length <= NUM_ ) ; _update card perk text ( _card id , _perk text ) ; card perk text updated ( _card id , _perk text ) ;"}
{"comment": "function that be call when a user or another contract want to transfer fund .", "function": "function transfer ( address _to , uint _value , bytes _data ) public when not paused returns ( bool ) { require ( _to != NUM_ ) ; if ( _to . is contract ( ) ) { return transfer to contract ( _to , _value , _data ) ; } else { return transfer to address ( _to , _value , _data ) ; } }", "signature": "function transfer ( address _to , uint _value , bytes _data ) public when not paused returns ( bool )", "body": "require ( _to != NUM_ ) ; if ( _to . is contract ( ) ) { return transfer to contract ( _to , _value , _data ) ; } else { return transfer to address ( _to , _value , _data ) ; }"}
{"comment": "pay winner , update contract balance to calculate new max bet , and send reward .", "function": "function _finish bet ( bool delete_it , address target ) private returns ( uint ) { player roll memory roll = player rolls [ target ] ; require ( roll . token value > NUM_ ) ; require ( roll . blockn != block . number ) ; uint result ; if ( block . number - roll . blockn > NUM_ ) { result = NUM_ ; } else { result = random ( NUM_ , roll . blockn , target ) + NUM_ ; } uint roll under = roll . roll under ; if ( result < roll under ) { uint profit = calculate profit ( roll . token value , roll under ) ; if ( profit > max profit ) { profit = max profit ; } contract balance = contract balance . sub ( profit ) ; emit log result ( target , result , roll under , profit , roll . token value , BOOL_ ) ; set max profit ( ) ; player rolls [ target ] = player roll ( uint200 ( NUM_ ) , uint48 ( NUM_ ) , uint8 ( NUM_ ) ) ; zthtkn . transfer ( target , profit + roll . token value ) ; return result ; } else { emit log result ( target , result , roll under , profit , roll . token value , BOOL_ ) ; contract balance = contract balance . add ( roll . token value ) ; player rolls [ target ] = player roll ( uint200 ( NUM_ ) , uint48 ( NUM_ ) , uint8 ( NUM_ ) ) ; set max profit ( ) ; return result ; } }", "signature": "function _finish bet ( bool delete_it , address target ) private returns ( uint )", "body": "player roll memory roll = player rolls [ target ] ; require ( roll . token value > NUM_ ) ; require ( roll . blockn != block . number ) ; uint result ; if ( block . number - roll . blockn > NUM_ ) { result = NUM_ ; } else { result = random ( NUM_ , roll . blockn , target ) + NUM_ ; } uint roll under = roll . roll under ; if ( result < roll under ) { uint profit = calculate profit ( roll . token value , roll under ) ; if ( profit > max profit ) { profit = max profit ; } contract balance = contract balance . sub ( profit ) ; emit log result ( target , result , roll under , profit , roll . token value , BOOL_ ) ; set max profit ( ) ; player rolls [ target ] = player roll ( uint200 ( NUM_ ) , uint48 ( NUM_ ) , uint8 ( NUM_ ) ) ; zthtkn . transfer ( target , profit + roll . token value ) ; return result ; } else { emit log result ( target , result , roll under , profit , roll . token value , BOOL_ ) ; contract balance = contract balance . add ( roll . token value ) ; player rolls [ target ] = player roll ( uint200 ( NUM_ ) , uint48 ( NUM_ ) , uint8 ( NUM_ ) ) ; set max profit ( ) ; return result ; }"}
{"comment": "current / next campaign charity balance .", "function": "function charity balance ( ) external view returns ( uint ) { if ( active ( ) ) { return campaigns [ last campaign id ] . total . balance eth . wmul ( campaigns [ last campaign id ] . charity fraction ) ; } else { if ( ! campaigns [ last campaign id ] . finalized ) { return campaigns [ last campaign id ] . total . balance eth . wmul ( campaigns [ last campaign id ] . charity fraction ) . wmul ( campaigns [ last campaign id ] . new campaign fraction ) ; } else { return next campaign . balance eth . wmul ( _charity fraction ) ; } } }", "signature": "function charity balance ( ) external view returns ( uint )", "body": "if ( active ( ) ) { return campaigns [ last campaign id ] . total . balance eth . wmul ( campaigns [ last campaign id ] . charity fraction ) ; } else { if ( ! campaigns [ last campaign id ] . finalized ) { return campaigns [ last campaign id ] . total . balance eth . wmul ( campaigns [ last campaign id ] . charity fraction ) . wmul ( campaigns [ last campaign id ] . new campaign fraction ) ; } else { return next campaign . balance eth . wmul ( _charity fraction ) ; } }"}
{"comment": "withdraw fund from contract .", "function": "function withdraw ether ( ) only owner { if ( this . balance == NUM_ ) throw ; if ( total eth raised < min eth to raise ) throw ; if ( multisig address . send ( this . balance ) ) { } }", "signature": "function withdraw ether ( ) only owner", "body": "if ( this . balance == NUM_ ) throw ; if ( total eth raised < min eth to raise ) throw ; if ( multisig address . send ( this . balance ) ) { }"}
{"comment": "transfers vest tokens to beneficiary .", "function": "function release ( erc20 basic token ) public { uint256 unreleased = releasable amount ( token ) ; require ( unreleased > NUM_ ) ; released [ token ] = released [ token ] . add ( unreleased ) ; token . safe transfer ( beneficiary , unreleased ) ; released ( unreleased ) ; }", "signature": "function release ( erc20 basic token ) public", "body": "uint256 unreleased = releasable amount ( token ) ; require ( unreleased > NUM_ ) ; released [ token ] = released [ token ] . add ( unreleased ) ; token . safe transfer ( beneficiary , unreleased ) ; released ( unreleased ) ;"}
{"comment": "basically private ( only call if last transaction be 4 weeks ago ) .", "function": "function return all ( ) onlyowner { for ( uint idx = NUM_ ; idx < vote a . length ; idx += NUM_ ) { vote a [ idx ] . ether address . send ( vote a [ idx ] . amount ) ; } for ( uint idx b = NUM_ ; idx b < vote b . length ; idx b += NUM_ ) { vote b [ idx b ] . ether address . send ( vote b [ idx b ] . amount ) ; } clear ( ) ; }", "signature": "function return all ( ) onlyowner", "body": "for ( uint idx = NUM_ ; idx < vote a . length ; idx += NUM_ ) { vote a [ idx ] . ether address . send ( vote a [ idx ] . amount ) ; } for ( uint idx b = NUM_ ; idx b < vote b . length ; idx b += NUM_ ) { vote b [ idx b ] . ether address . send ( vote b [ idx b ] . amount ) ; } clear ( ) ;"}
{"comment": "checks if the goal or time limit have be reach and end the campaign .", "function": "function finalize ( ) after deadline { require ( ! crowdsale ended ) ; token reward . burn ( ) ; finalize ( token owner , amount raised ) ; crowdsale ended = BOOL_ ; }", "signature": "function finalize ( ) after deadline", "body": "require ( ! crowdsale ended ) ; token reward . burn ( ) ; finalize ( token owner , amount raised ) ; crowdsale ended = BOOL_ ;"}
{"comment": "buy function allow to buy ether .", "function": "function buy spike ( ) public payable on sale valid value valid investor { uint256 requested units = ( msg . value * _original buy price ) / NUM_ * * NUM_ ; require ( balances [ owner ] >= requested units ) ; balances [ owner ] = balances [ owner ] . sub ( requested units ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( requested units ) ; deposit [ msg . sender ] = deposit [ msg . sender ] . add ( msg . value ) ; total token sold = total token sold . add ( requested units ) ; if ( total token sold >= _ico supply ) { _selling = BOOL_ ; } transfer ( owner , msg . sender , requested units ) ; owner . transfer ( msg . value ) ; }", "signature": "function buy spike ( ) public payable on sale valid value valid investor", "body": "uint256 requested units = ( msg . value * _original buy price ) / NUM_ * * NUM_ ; require ( balances [ owner ] >= requested units ) ; balances [ owner ] = balances [ owner ] . sub ( requested units ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( requested units ) ; deposit [ msg . sender ] = deposit [ msg . sender ] . add ( msg . value ) ; total token sold = total token sold . add ( requested units ) ; if ( total token sold >= _ico supply ) { _selling = BOOL_ ; } transfer ( owner , msg . sender , requested units ) ; owner . transfer ( msg . value ) ;"}
{"comment": "additional api for contract to use as well .", "function": "function fund ( ) public payable only when live { require ( msg . value >= minimum funding amount ) ; if ( ! is funder ( msg . sender ) ) { total current funders = total current funders . add ( NUM_ ) ; funders [ msg . sender ] = funder ( { exists : BOOL_ , balance : msg . value , withdrawal entry : withdrawal counter , contribution : NUM_ , contribution claimed : NUM_ } ) ; } else { consolidate funder ( msg . sender , msg . value ) ; } payment ( msg . sender , msg . value ) ; }", "signature": "function fund ( ) public payable only when live", "body": "require ( msg . value >= minimum funding amount ) ; if ( ! is funder ( msg . sender ) ) { total current funders = total current funders . add ( NUM_ ) ; funders [ msg . sender ] = funder ( { exists : BOOL_ , balance : msg . value , withdrawal entry : withdrawal counter , contribution : NUM_ , contribution claimed : NUM_ } ) ; } else { consolidate funder ( msg . sender , msg . value ) ; } payment ( msg . sender , msg . value ) ;"}
{"comment": "whether the allocation be successful or not .", "function": "function allocate ( address _address , uint256 _amount , uint8 _type ) public only owner returns ( bool success ) { require ( allocations [ _address ] == NUM_ ) ; if ( _type == NUM_ ) { require ( advisors allocated amount + _amount <= advisors_amount ) ; advisors allocated amount += _amount ; advisors [ _address ] = BOOL_ ; } else if ( _type == NUM_ ) { require ( founders allocated amount + _amount <= founders_amount ) ; founders allocated amount += _amount ; founders [ _address ] = BOOL_ ; } else { require ( holders allocated amount + _amount <= holders_amount + reserve_amount ) ; holders allocated amount += _amount ; } allocations [ _address ] = _amount ; initial allocations [ _address ] = _amount ; balances [ _address ] += _amount ; for ( uint8 i = NUM_ ; i < NUM_ ; i ++ ) { unspent amounts [ bonus_dates [ i ] ] += _amount ; eligible for bonus [ bonus_dates [ i ] ] [ _address ] = BOOL_ ; bonus not distributed [ bonus_dates [ i ] ] [ _address ] = BOOL_ ; } initial holders . push ( _address ) ; allocate ( _address , _amount ) ; return BOOL_ ; }", "signature": "function allocate ( address _address , uint256 _amount , uint8 _type ) public only owner returns ( bool success )", "body": "require ( allocations [ _address ] == NUM_ ) ; if ( _type == NUM_ ) { require ( advisors allocated amount + _amount <= advisors_amount ) ; advisors allocated amount += _amount ; advisors [ _address ] = BOOL_ ; } else if ( _type == NUM_ ) { require ( founders allocated amount + _amount <= founders_amount ) ; founders allocated amount += _amount ; founders [ _address ] = BOOL_ ; } else { require ( holders allocated amount + _amount <= holders_amount + reserve_amount ) ; holders allocated amount += _amount ; } allocations [ _address ] = _amount ; initial allocations [ _address ] = _amount ; balances [ _address ] += _amount ; for ( uint8 i = NUM_ ; i < NUM_ ; i ++ ) { unspent amounts [ bonus_dates [ i ] ] += _amount ; eligible for bonus [ bonus_dates [ i ] ] [ _address ] = BOOL_ ; bonus not distributed [ bonus_dates [ i ] ] [ _address ] = BOOL_ ; } initial holders . push ( _address ) ; allocate ( _address , _amount ) ; return BOOL_ ;"}
{"comment": "ex1 : trade 0 . 5 eth - eos 0 , 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee , 500000000000000000 , 0xd3c64bba75859eb808ace6f2a6048ecdb2d70817 , 21003850000000000000 .", "function": "function _trade ( uint256 _trading proxy index , erc20 _src , uint256 _src amount , erc20 _dest , uint256 _min dest amount ) private returns ( uint256 ) { uint256 dest amount ; uint256 src amount before ; uint256 dest amount before ; if ( ether erc20 == _src ) { src amount before = address ( this ) . balance ; } else { src amount before = _src . balance of ( this ) ; } if ( ether erc20 == _dest ) { dest amount before = address ( this ) . balance ; } else { dest amount before = _dest . balance of ( this ) ; } if ( ether erc20 == _src ) { dest amount = _trade ether to token ( _trading proxy index , _src amount , _dest ) ; } else if ( ether erc20 == _dest ) { dest amount = _trade token to ether ( _trading proxy index , _src , _src amount ) ; } else { revert ( ) ; } if ( ether erc20 == _src ) { assert ( address ( this ) . balance == src amount before . sub ( _src amount ) ) ; } else { assert ( _src . balance of ( this ) == src amount before . sub ( _src amount ) ) ; } if ( ether erc20 == _dest ) { assert ( address ( this ) . balance == dest amount before . add ( dest amount ) ) ; } else { assert ( _dest . balance of ( this ) == dest amount before . add ( dest amount ) ) ; } assert ( dest amount >= _min dest amount ) ; return dest amount ; }", "signature": "function _trade ( uint256 _trading proxy index , erc20 _src , uint256 _src amount , erc20 _dest , uint256 _min dest amount ) private returns ( uint256 )", "body": "uint256 dest amount ; uint256 src amount before ; uint256 dest amount before ; if ( ether erc20 == _src ) { src amount before = address ( this ) . balance ; } else { src amount before = _src . balance of ( this ) ; } if ( ether erc20 == _dest ) { dest amount before = address ( this ) . balance ; } else { dest amount before = _dest . balance of ( this ) ; } if ( ether erc20 == _src ) { dest amount = _trade ether to token ( _trading proxy index , _src amount , _dest ) ; } else if ( ether erc20 == _dest ) { dest amount = _trade token to ether ( _trading proxy index , _src , _src amount ) ; } else { revert ( ) ; } if ( ether erc20 == _src ) { assert ( address ( this ) . balance == src amount before . sub ( _src amount ) ) ; } else { assert ( _src . balance of ( this ) == src amount before . sub ( _src amount ) ) ; } if ( ether erc20 == _dest ) { assert ( address ( this ) . balance == dest amount before . add ( dest amount ) ) ; } else { assert ( _dest . balance of ( this ) == dest amount before . add ( dest amount ) ) ; } assert ( dest amount >= _min dest amount ) ; return dest amount ;"}
{"comment": "change founder address ( controlling address for contract ) .", "function": "function change founder ( address new founder ) { require ( msg . sender == founder ) ; founder = new founder ; }", "signature": "function change founder ( address new founder )", "body": "require ( msg . sender == founder ) ; founder = new founder ;"}
{"comment": "mints _amount tokens that be assign to _owner .", "function": "function mint tokens ( address _owner ) can mint only ( ifood dev ) non zero address ( _owner ) public returns ( bool ) { require ( lock tokens [ _owner ] . block number <= get current block number ( ) ) ; uint256 _amount = lock tokens [ _owner ] . value ; uint256 cur total supply = total supply ; require ( cur total supply + _amount >= cur total supply ) ; require ( cur total supply + _amount <= total supply cap ) ; uint256 previous balance to = balance of ( _owner ) ; require ( previous balance to + _amount >= previous balance to ) ; total supply = cur total supply . add ( _amount ) ; balances [ _owner ] = previous balance to . add ( _amount ) ; lock tokens [ _owner ] . value = NUM_ ; lock tokens [ _owner ] . block number = NUM_ ; mint tokens ( _owner , _amount ) ; transfer ( NUM_ , _owner , _amount ) ; return BOOL_ ; }", "signature": "function mint tokens ( address _owner ) can mint only ( ifood dev ) non zero address ( _owner ) public returns ( bool )", "body": "require ( lock tokens [ _owner ] . block number <= get current block number ( ) ) ; uint256 _amount = lock tokens [ _owner ] . value ; uint256 cur total supply = total supply ; require ( cur total supply + _amount >= cur total supply ) ; require ( cur total supply + _amount <= total supply cap ) ; uint256 previous balance to = balance of ( _owner ) ; require ( previous balance to + _amount >= previous balance to ) ; total supply = cur total supply . add ( _amount ) ; balances [ _owner ] = previous balance to . add ( _amount ) ; lock tokens [ _owner ] . value = NUM_ ; lock tokens [ _owner ] . block number = NUM_ ; mint tokens ( _owner , _amount ) ; transfer ( NUM_ , _owner , _amount ) ; return BOOL_ ;"}
{"comment": "scheduling authorization api .", "function": "function add authorization ( call database storage self , address scheduler address , address contract address ) public { self . account authorizations [ sha3 ( scheduler address , contract address ) ] = BOOL_ ; }", "signature": "function add authorization ( call database storage self , address scheduler address , address contract address ) public", "body": "self . account authorizations [ sha3 ( scheduler address , contract address ) ] = BOOL_ ;"}
{"comment": "mint coin for a single account .", "function": "function mint ( address _to , uint _amount ) only administrator { require ( ! sealed ) ; require ( _to != NUM_ ) ; require ( _amount != NUM_ ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; total supply = total supply . add ( _amount ) ; transfer ( NUM_ , _to , _amount ) ; }", "signature": "function mint ( address _to , uint _amount ) only administrator", "body": "require ( ! sealed ) ; require ( _to != NUM_ ) ; require ( _amount != NUM_ ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; total supply = total supply . add ( _amount ) ; transfer ( NUM_ , _to , _amount ) ;"}
{"comment": "high level token purchase function .", "function": "function buy tokens ( address beneficiary ) when not paused public payable { require ( beneficiary != NUM_ ) ; require ( valid purchase ( ) ) ; uint256 lower purchase limit = NUM_ ether ; require ( msg . value >= lower purchase limit ) ; assert ( _token purchased ( msg . sender , beneficiary , msg . value ) ) ; wei raised = wei raised . add ( msg . value ) ; forward funds ( ) ; }", "signature": "function buy tokens ( address beneficiary ) when not paused public payable", "body": "require ( beneficiary != NUM_ ) ; require ( valid purchase ( ) ) ; uint256 lower purchase limit = NUM_ ether ; require ( msg . value >= lower purchase limit ) ; assert ( _token purchased ( msg . sender , beneficiary , msg . value ) ) ; wei raised = wei raised . add ( msg . value ) ; forward funds ( ) ;"}
{"comment": "send ether to the fund collection wallet override to create custom fund forward mechanisms .", "function": "function forward funds ( ) internal { wallet . transfer ( msg . value * NUM_ / NUM_ ) ; dev wallet . transfer ( msg . value * NUM_ / NUM_ ) ; }", "signature": "function forward funds ( ) internal", "body": "wallet . transfer ( msg . value * NUM_ / NUM_ ) ; dev wallet . transfer ( msg . value * NUM_ / NUM_ ) ;"}
{"comment": "sends the eth to eth fund wallet and finalize the token sale .", "function": "function finalize ( ) min cap reached sale period completed is valid state only by ( owner ) external { balances [ shit fund address ] = balances [ shit fund address ] . add ( shit fund ) ; assigned supply = assigned supply . add ( shit fund ) ; claim shit ( shit fund address , shit fund ) ; transfer ( NUM_ , shit fund address , shit fund ) ; if ( assigned supply < total supply ) { uint256 unassigned supply = total supply . sub ( assigned supply ) ; balances [ shit fund address ] = balances [ shit fund address ] . add ( unassigned supply ) ; assigned supply = assigned supply . add ( unassigned supply ) ; claim shit ( shit fund address , unassigned supply ) ; transfer ( NUM_ , shit fund address , unassigned supply ) ; } eth fund address . transfer ( this . balance ) ; is finalized = BOOL_ ; }", "signature": "function finalize ( ) min cap reached sale period completed is valid state only by ( owner ) external", "body": "balances [ shit fund address ] = balances [ shit fund address ] . add ( shit fund ) ; assigned supply = assigned supply . add ( shit fund ) ; claim shit ( shit fund address , shit fund ) ; transfer ( NUM_ , shit fund address , shit fund ) ; if ( assigned supply < total supply ) { uint256 unassigned supply = total supply . sub ( assigned supply ) ; balances [ shit fund address ] = balances [ shit fund address ] . add ( unassigned supply ) ; assigned supply = assigned supply . add ( unassigned supply ) ; claim shit ( shit fund address , unassigned supply ) ; transfer ( NUM_ , shit fund address , unassigned supply ) ; } eth fund address . transfer ( this . balance ) ; is finalized = BOOL_ ;"}
{"comment": "creates a new promo team with the give name , with give _price and assign it to an address .", "function": "function create promo team ( address _owner , string _name , uint256 _price ) public only coo { require ( promo created count < promo_creation_limit ) ; address team owner = _owner ; if ( team owner == address ( NUM_ ) ) { team owner = coo address ; } if ( _price <= NUM_ ) { _price = starting price ; } promo created count ++ ; _create team ( _name , team owner , _price ) ; }", "signature": "function create promo team ( address _owner , string _name , uint256 _price ) public only coo", "body": "require ( promo created count < promo_creation_limit ) ; address team owner = _owner ; if ( team owner == address ( NUM_ ) ) { team owner = coo address ; } if ( _price <= NUM_ ) { _price = starting price ; } promo created count ++ ; _create team ( _name , team owner , _price ) ;"}
{"comment": "sets the state of buy and sell operations .", "function": "function set status ( bool is closed buy , bool is closed sell ) only owner public { close buy = is closed buy ; close sell = is closed sell ; }", "signature": "function set status ( bool is closed buy , bool is closed sell ) only owner public", "body": "close buy = is closed buy ; close sell = is closed sell ;"}
{"comment": "allow arbiter to get his collected fee .", "function": "function get fees ( ) only arbiter { if ( fee funds > this . balance ) { log debug ( STR_ ) ; return ; } safe send ( arbiter , fee funds ) ; fee funds = NUM_ ; }", "signature": "function get fees ( ) only arbiter", "body": "if ( fee funds > this . balance ) { log debug ( STR_ ) ; return ; } safe send ( arbiter , fee funds ) ; fee funds = NUM_ ;"}
{"comment": "transfer token for a specified address .", "function": "function transfer ( address _to , uint256 _value ) public returns ( bool ) { require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }", "signature": "function transfer ( address _to , uint256 _value ) public returns ( bool )", "body": "require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; transfer ( msg . sender , _to , _value ) ; return BOOL_ ;"}
{"comment": "for calculate the sell tokens .", "function": "function transfer crowdsale ( address _to , uint256 _value ) { require ( balances [ msg . sender ] > NUM_ ) ; require ( balances [ msg . sender ] >= _value ) ; require ( balances [ _to ] + _value >= balances [ _to ] ) ; balances [ msg . sender ] -= _value ; balances [ _to ] += _value ; sold token += _value ; transfer ( msg . sender , _to , _value ) ; }", "signature": "function transfer crowdsale ( address _to , uint256 _value )", "body": "require ( balances [ msg . sender ] > NUM_ ) ; require ( balances [ msg . sender ] >= _value ) ; require ( balances [ _to ] + _value >= balances [ _to ] ) ; balances [ msg . sender ] -= _value ; balances [ _to ] += _value ; sold token += _value ; transfer ( msg . sender , _to , _value ) ;"}
{"comment": "allows anyone to execute a confirmed transaction .", "function": "function execute transaction ( uint transaction id ) public owner exists ( msg . sender ) confirmed ( transaction id , msg . sender ) not executed ( transaction id ) { if ( is confirmed ( transaction id ) ) { transaction storage txn = transactions [ transaction id ] ; txn . executed = BOOL_ ; if ( external_call ( txn . destination , txn . value , txn . data . length , txn . data ) ) execution ( transaction id ) ; else { execution failure ( transaction id ) ; txn . executed = BOOL_ ; } } }", "signature": "function execute transaction ( uint transaction id ) public owner exists ( msg . sender ) confirmed ( transaction id , msg . sender ) not executed ( transaction id )", "body": "if ( is confirmed ( transaction id ) ) { transaction storage txn = transactions [ transaction id ] ; txn . executed = BOOL_ ; if ( external_call ( txn . destination , txn . value , txn . data . length , txn . data ) ) execution ( transaction id ) ; else { execution failure ( transaction id ) ; txn . executed = BOOL_ ; } }"}
{"comment": "should allow withdrawal without gas calc .", "function": "function kill ( ) only_noel { suicide ( noel ) ; }", "signature": "function kill ( ) only_noel", "body": "suicide ( noel ) ;"}
{"comment": "invariant : acc_premium + acc_riskfund + acc_payout + acc_balance + acc_reward + acc_oraclizecosts 0 .", "function": "function bookkeeping ( acc _from , acc _to , uint256 _amount ) public { require ( fd_ac . check permission ( NUM_ , msg . sender ) ) ; assert ( int256 ( _amount ) > NUM_ ) ; fd_db . set ledger ( uint8 ( _from ) , - int ( _amount ) ) ; fd_db . set ledger ( uint8 ( _to ) , int ( _amount ) ) ; }", "signature": "function bookkeeping ( acc _from , acc _to , uint256 _amount ) public", "body": "require ( fd_ac . check permission ( NUM_ , msg . sender ) ) ; assert ( int256 ( _amount ) > NUM_ ) ; fd_db . set ledger ( uint8 ( _from ) , - int ( _amount ) ) ; fd_db . set ledger ( uint8 ( _to ) , int ( _amount ) ) ;"}
{"comment": "helpers for events with counter .", "function": "function log debug ( string message ) internal { logs count ++ ; log debug ( message ) ; }", "signature": "function log debug ( string message ) internal", "body": "logs count ++ ; log debug ( message ) ;"}
{"comment": "this method be for to be call only for the owner .", "function": "function finalize ( ) external only admin returns ( bool ) { return finalization ( ) ; }", "signature": "function finalize ( ) external only admin returns ( bool )", "body": "return finalization ( ) ;"}
{"comment": "function to create a request a payer .", "function": "function create request as payer action ( address [ ] _payees id address , int256 [ ] _expected amounts , address _payer refund address , uint256 [ ] _payee amounts , uint256 [ ] _additionals , string _data ) external payable when not paused returns ( bytes32 request id ) { require ( msg . sender != _payees id address [ NUM_ ] && _payees id address [ NUM_ ] != NUM_ ) ; int256 total expected amounts ; ( request id , total expected amounts ) = create core request internal ( msg . sender , _payees id address , _expected amounts , _data ) ; if ( _payer refund address != NUM_ ) { payer refund address [ request id ] = _payer refund address ; } accept and pay ( request id , _payee amounts , _additionals , total expected amounts ) ; return request id ; }", "signature": "function create request as payer action ( address [ ] _payees id address , int256 [ ] _expected amounts , address _payer refund address , uint256 [ ] _payee amounts , uint256 [ ] _additionals , string _data ) external payable when not paused returns ( bytes32 request id )", "body": "require ( msg . sender != _payees id address [ NUM_ ] && _payees id address [ NUM_ ] != NUM_ ) ; int256 total expected amounts ; ( request id , total expected amounts ) = create core request internal ( msg . sender , _payees id address , _expected amounts , _data ) ; if ( _payer refund address != NUM_ ) { payer refund address [ request id ] = _payer refund address ; } accept and pay ( request id , _payee amounts , _additionals , total expected amounts ) ; return request id ;"}
{"comment": "sets the ico phase 2 duration .", "function": "function set ico phase2 ( uint256 _start , uint256 _end ) external only owner { require ( _start < _end ) ; ico phase2 start = _start ; ico phase2 end = _end ; emit change ico phase ( NUM_ , _start , _end ) ; }", "signature": "function set ico phase2 ( uint256 _start , uint256 _end ) external only owner", "body": "require ( _start < _end ) ; ico phase2 start = _start ; ico phase2 end = _end ; emit change ico phase ( NUM_ , _start , _end ) ;"}
{"comment": "allow addition of minters to allow future contract to use the role .", "function": "function add minter ( address _new ) external only etheraffle { minters . push ( _new ) ; is minter [ _new ] = BOOL_ ; log minter addition ( _new , now ) ; }", "signature": "function add minter ( address _new ) external only etheraffle", "body": "minters . push ( _new ) ; is minter [ _new ] = BOOL_ ; log minter addition ( _new , now ) ;"}
{"comment": "get the tag relate to the module factory .", "function": "function get tags ( ) public view returns ( bytes32 [ ] ) { bytes32 [ ] memory available tags = new bytes32 [ ] ( NUM_ ) ; available tags [ NUM_ ] = STR_ ; available tags [ NUM_ ] = STR_ ; available tags [ NUM_ ] = STR_ ; return available tags ; }", "signature": "function get tags ( ) public view returns ( bytes32 [ ] )", "body": "bytes32 [ ] memory available tags = new bytes32 [ ] ( NUM_ ) ; available tags [ NUM_ ] = STR_ ; available tags [ NUM_ ] = STR_ ; available tags [ NUM_ ] = STR_ ; return available tags ;"}
{"comment": "transfers tokens hold by timelock to beneficiary .", "function": "function release ( ) public { require ( now >= release time ) ; uint256 amount = token . balance of ( this ) ; require ( amount > NUM_ ) ; token . safe transfer ( beneficiary , amount ) ; }", "signature": "function release ( ) public", "body": "require ( now >= release time ) ; uint256 amount = token . balance of ( this ) ; require ( amount > NUM_ ) ; token . safe transfer ( beneficiary , amount ) ;"}
{"comment": "purchase tokens for the amount of ether send to this contract for custom address .", "function": "function purchase for ( address _participant ) public payable only during icodates ( ) returns ( bool ) { require ( _participant != NUM_ ) ; require ( paid ether [ _participant ] . add ( msg . value ) >= minimum purchase amount ) ; selfllery manager wallet . transfer ( msg . value ) ; uint current bonus percent = get current bonus percent ( ) ; uint total tokens = calc total tokens ( msg . value , current bonus percent ) ; require ( current cap tokens . add ( total tokens ) <= sale tokens cents ) ; require ( token . transfer from ( owner , _participant , total tokens ) ) ; sent tokens [ _participant ] = sent tokens [ _participant ] . add ( total tokens ) ; current cap tokens = current cap tokens . add ( total tokens ) ; current cap ether = current cap ether . add ( msg . value ) ; paid ether [ _participant ] = paid ether [ _participant ] . add ( msg . value ) ; purchase ( _participant , total tokens , msg . value ) ; return BOOL_ ; }", "signature": "function purchase for ( address _participant ) public payable only during icodates ( ) returns ( bool )", "body": "require ( _participant != NUM_ ) ; require ( paid ether [ _participant ] . add ( msg . value ) >= minimum purchase amount ) ; selfllery manager wallet . transfer ( msg . value ) ; uint current bonus percent = get current bonus percent ( ) ; uint total tokens = calc total tokens ( msg . value , current bonus percent ) ; require ( current cap tokens . add ( total tokens ) <= sale tokens cents ) ; require ( token . transfer from ( owner , _participant , total tokens ) ) ; sent tokens [ _participant ] = sent tokens [ _participant ] . add ( total tokens ) ; current cap tokens = current cap tokens . add ( total tokens ) ; current cap ether = current cap ether . add ( msg . value ) ; paid ether [ _participant ] = paid ether [ _participant ] . add ( msg . value ) ; purchase ( _participant , total tokens , msg . value ) ; return BOOL_ ;"}
{"comment": "process stakes sale .", "function": "function process sale ( ) internal { if ( ! price is frozen ) { set stake price uscents ( ) ; } set caps ( ) ; uint team stakes ; uint fundaria stakes ; uint sale stakes ; uint wei invested ; uint try sale stakes = stake for wei ( msg . value ) ; if ( try sale stakes > NUM_ ) { uint try distribute = distributed sale stakes + try sale stakes ; if ( try distribute <= sale cap ) { sale stakes = try sale stakes ; wei invested = msg . value ; } else { sale stakes = sale cap - distributed sale stakes ; wei invested = wei for stake ( sale stakes ) ; } team stakes = ( sale stakes * team share ) . div ( sale share ) ; fundaria stakes = ( sale stakes * fundaria share ) . div ( sale share ) ; if ( sale stakes > NUM_ ) { balances [ owner ] += team stakes ; total supply += team stakes ; distributed team stakes += team stakes ; transfer ( supplier , owner , team stakes ) ; balances [ fundaria ] += fundaria stakes ; total supply += fundaria stakes ; distributed fundaria stakes += fundaria stakes ; transfer ( supplier , fundaria , fundaria stakes ) ; sale supply ( msg . sender , sale stakes , wei invested ) ; if ( sale stat [ msg . sender ] . guide != address ( NUM_ ) ) { distribute bonus stakes ( msg . sender , sale stakes , wei invested ) ; } } if ( try distribute > sale cap ) { msg . sender . transfer ( msg . value - wei invested ) ; } } else { msg . sender . transfer ( msg . value ) ; } }", "signature": "function process sale ( ) internal", "body": "if ( ! price is frozen ) { set stake price uscents ( ) ; } set caps ( ) ; uint team stakes ; uint fundaria stakes ; uint sale stakes ; uint wei invested ; uint try sale stakes = stake for wei ( msg . value ) ; if ( try sale stakes > NUM_ ) { uint try distribute = distributed sale stakes + try sale stakes ; if ( try distribute <= sale cap ) { sale stakes = try sale stakes ; wei invested = msg . value ; } else { sale stakes = sale cap - distributed sale stakes ; wei invested = wei for stake ( sale stakes ) ; } team stakes = ( sale stakes * team share ) . div ( sale share ) ; fundaria stakes = ( sale stakes * fundaria share ) . div ( sale share ) ; if ( sale stakes > NUM_ ) { balances [ owner ] += team stakes ; total supply += team stakes ; distributed team stakes += team stakes ; transfer ( supplier , owner , team stakes ) ; balances [ fundaria ] += fundaria stakes ; total supply += fundaria stakes ; distributed fundaria stakes += fundaria stakes ; transfer ( supplier , fundaria , fundaria stakes ) ; sale supply ( msg . sender , sale stakes , wei invested ) ; if ( sale stat [ msg . sender ] . guide != address ( NUM_ ) ) { distribute bonus stakes ( msg . sender , sale stakes , wei invested ) ; } } if ( try distribute > sale cap ) { msg . sender . transfer ( msg . value - wei invested ) ; } } else { msg . sender . transfer ( msg . value ) ; }"}
{"comment": "tokenprice - current token price .", "function": "function get token price ( ) constant returns ( uint256 token price ) { token price = periods [ current period ] . token price ; }", "signature": "function get token price ( ) constant returns ( uint256 token price )", "body": "token price = periods [ current period ] . token price ;"}
{"comment": "ceo might extend the confirm time limit when etherum network be block .", "function": "function set confirm ( uint _newlimit ) external only ceo { confirm_limit = uint32 ( _newlimit ) ; }", "signature": "function set confirm ( uint _newlimit ) external only ceo", "body": "confirm_limit = uint32 ( _newlimit ) ;"}
{"comment": "call by the admin to unpause , return to normal state .", "function": "function unpause ( ) public only admin when paused returns ( bool ) { paused = BOOL_ ; return BOOL_ ; }", "signature": "function unpause ( ) public only admin when paused returns ( bool )", "body": "paused = BOOL_ ; return BOOL_ ;"}
{"comment": "creates a new emoji with the give name .", "function": "function create contract emoji ( string _name ) public only coo { _create emoji ( _name , address ( this ) , starting price ) ; }", "signature": "function create contract emoji ( string _name ) public only coo", "body": "_create emoji ( _name , address ( this ) , starting price ) ;"}
{"comment": "create new investment and push it to array 'investments ' .", "function": "function create investment ( address _address , uint _charger id ) internal returns ( investment investor ) { check charger ( _charger id ) ; investments count ++ ; investment memory _new investment ; _new investment . address = _address ; _new investment . charger id = _charger id ; _new investment . investment id = investments count ; investments . push ( _new investment ) ; return _new investment ; }", "signature": "function create investment ( address _address , uint _charger id ) internal returns ( investment investor )", "body": "check charger ( _charger id ) ; investments count ++ ; investment memory _new investment ; _new investment . address = _address ; _new investment . charger id = _charger id ; _new investment . investment id = investments count ; investments . push ( _new investment ) ; return _new investment ;"}
{"comment": "scale down all order base on historical fill or cancellation stats but key the order 's original exchange rate .", "function": "function scale ring based on historical records ( token transfer delegate delegate , uint ring size , order state [ ] orders ) private view { for ( uint i = NUM_ ; i < ring size ; i ++ ) { order state memory state = orders [ i ] ; uint amount ; if ( state . buy no more than amount b ) { amount = state . amount b . tolerant sub ( delegate . cancelled or filled ( state . order hash ) ) ; state . amount s = amount . mul ( state . amount s ) / state . amount b ; state . lrc fee = amount . mul ( state . lrc fee ) / state . amount b ; state . amount b = amount ; } else { amount = state . amount s . tolerant sub ( delegate . cancelled or filled ( state . order hash ) ) ; state . amount b = amount . mul ( state . amount b ) / state . amount s ; state . lrc fee = amount . mul ( state . lrc fee ) / state . amount s ; state . amount s = amount ; } require ( state . amount s > NUM_ ) ; require ( state . amount b > NUM_ ) ; uint available amount s = get spendable ( delegate , state . token s , state . owner ) ; require ( available amount s > NUM_ ) ; state . fill amount s = ( state . amount s < available amount s ? state . amount s : available amount s ) ; require ( state . fill amount s > NUM_ ) ; } }", "signature": "function scale ring based on historical records ( token transfer delegate delegate , uint ring size , order state [ ] orders ) private view", "body": "for ( uint i = NUM_ ; i < ring size ; i ++ ) { order state memory state = orders [ i ] ; uint amount ; if ( state . buy no more than amount b ) { amount = state . amount b . tolerant sub ( delegate . cancelled or filled ( state . order hash ) ) ; state . amount s = amount . mul ( state . amount s ) / state . amount b ; state . lrc fee = amount . mul ( state . lrc fee ) / state . amount b ; state . amount b = amount ; } else { amount = state . amount s . tolerant sub ( delegate . cancelled or filled ( state . order hash ) ) ; state . amount b = amount . mul ( state . amount b ) / state . amount s ; state . lrc fee = amount . mul ( state . lrc fee ) / state . amount s ; state . amount s = amount ; } require ( state . amount s > NUM_ ) ; require ( state . amount b > NUM_ ) ; uint available amount s = get spendable ( delegate , state . token s , state . owner ) ; require ( available amount s > NUM_ ) ; state . fill amount s = ( state . amount s < available amount s ? state . amount s : available amount s ) ; require ( state . fill amount s > NUM_ ) ; }"}
{"comment": "buy unclaimed plot .", "function": "function claim plot multiple ( uint256 [ ] _deed ids , uint256 _buyout price ) external payable when not paused { claim plot multiple with data ( _deed ids , _buyout price , STR_ , STR_ , STR_ , STR_ ) ; }", "signature": "function claim plot multiple ( uint256 [ ] _deed ids , uint256 _buyout price ) external payable when not paused", "body": "claim plot multiple with data ( _deed ids , _buyout price , STR_ , STR_ , STR_ , STR_ ) ;"}
{"comment": "returns the name of the current round in plain text .", "function": "function get token sale type ( ) external view returns ( string ) { return ( token sale == token sale type . round1 ) ? STR_ : STR_ ; }", "signature": "function get token sale type ( ) external view returns ( string )", "body": "return ( token sale == token sale type . round1 ) ? STR_ : STR_ ;"}
{"comment": "check if transferfrom be possible .", "function": "function can transfer from ( address _from , address _to ) public constant returns ( bool success ) { if ( whitelist [ _from ] == BOOL_ || whitelist [ _to ] == BOOL_ ) { return BOOL_ ; } else { return BOOL_ ; } }", "signature": "function can transfer from ( address _from , address _to ) public constant returns ( bool success )", "body": "if ( whitelist [ _from ] == BOOL_ || whitelist [ _to ] == BOOL_ ) { return BOOL_ ; } else { return BOOL_ ; }"}
{"comment": "end the round .", "function": "function end round ( f3 ddatasets . event returns memory _event data_ ) private returns ( f3 ddatasets . event returns ) { uint256 _r id = r id_ ; uint256 _win pid = round_ [ _r id ] . plyr ; uint256 _win tid = round_ [ _r id ] . team ; uint256 _pot = round_ [ _r id ] . pot ; uint256 _win = ( _pot . mul ( NUM_ ) ) / NUM_ ; uint256 _com = ( _pot / NUM_ ) ; uint256 _gen = ( _pot . mul ( pot split_ [ _win tid ] . gen ) ) / NUM_ ; uint256 _res = ( ( ( _pot . sub ( _win ) ) . sub ( _com ) ) . sub ( _gen ) ) ; uint256 _ppt = ( _gen . mul ( NUM_ ) ) / ( round_ [ _r id ] . keys ) ; uint256 _dust = _gen . sub ( ( _ppt . mul ( round_ [ _r id ] . keys ) ) / NUM_ ) ; if ( _dust > NUM_ ) { _gen = _gen . sub ( _dust ) ; _res = _res . add ( _dust ) ; } plyr_ [ _win pid ] . win = _win . add ( plyr_ [ _win pid ] . win ) ; share com . transfer ( ( _com / NUM_ ) ) ; admin . transfer ( ( _com / NUM_ ) ) ; round_ [ _r id ] . mask = _ppt . add ( round_ [ _r id ] . mask ) ; _event data_ . compressed data = _event data_ . compressed data + ( round_ [ _r id ] . end * NUM_ ) ; _event data_ . compressed ids = _event data_ . compressed ids + ( _win pid * NUM_ ) + ( _win tid * NUM_ ) ; _event data_ . winner addr = plyr_ [ _win pid ] . addr ; _event data_ . winner name = plyr_ [ _win pid ] . name ; _event data_ . amount won = _win ; _event data_ . gen amount = _gen ; _event data_ . p3 damount = NUM_ ; _event data_ . new pot = _res ; emit f3 devents . on end round ( _r id , plyr_ [ _win pid ] . addr , plyr_ [ _win pid ] . name , _win , _res ) ; r id_ ++ ; _r id ++ ; round_ [ _r id ] . strt = now ; round_ [ _r id ] . end = now . add ( rnd init_ ) . add ( rnd gap_ ) ; round_ [ _r id ] . pot = _res ; return ( _event data_ ) ; }", "signature": "function end round ( f3 ddatasets . event returns memory _event data_ ) private returns ( f3 ddatasets . event returns )", "body": "uint256 _r id = r id_ ; uint256 _win pid = round_ [ _r id ] . plyr ; uint256 _win tid = round_ [ _r id ] . team ; uint256 _pot = round_ [ _r id ] . pot ; uint256 _win = ( _pot . mul ( NUM_ ) ) / NUM_ ; uint256 _com = ( _pot / NUM_ ) ; uint256 _gen = ( _pot . mul ( pot split_ [ _win tid ] . gen ) ) / NUM_ ; uint256 _res = ( ( ( _pot . sub ( _win ) ) . sub ( _com ) ) . sub ( _gen ) ) ; uint256 _ppt = ( _gen . mul ( NUM_ ) ) / ( round_ [ _r id ] . keys ) ; uint256 _dust = _gen . sub ( ( _ppt . mul ( round_ [ _r id ] . keys ) ) / NUM_ ) ; if ( _dust > NUM_ ) { _gen = _gen . sub ( _dust ) ; _res = _res . add ( _dust ) ; } plyr_ [ _win pid ] . win = _win . add ( plyr_ [ _win pid ] . win ) ; share com . transfer ( ( _com / NUM_ ) ) ; admin . transfer ( ( _com / NUM_ ) ) ; round_ [ _r id ] . mask = _ppt . add ( round_ [ _r id ] . mask ) ; _event data_ . compressed data = _event data_ . compressed data + ( round_ [ _r id ] . end * NUM_ ) ; _event data_ . compressed ids = _event data_ . compressed ids + ( _win pid * NUM_ ) + ( _win tid * NUM_ ) ; _event data_ . winner addr = plyr_ [ _win pid ] . addr ; _event data_ . winner name = plyr_ [ _win pid ] . name ; _event data_ . amount won = _win ; _event data_ . gen amount = _gen ; _event data_ . p3 damount = NUM_ ; _event data_ . new pot = _res ; emit f3 devents . on end round ( _r id , plyr_ [ _win pid ] . addr , plyr_ [ _win pid ] . name , _win , _res ) ; r id_ ++ ; _r id ++ ; round_ [ _r id ] . strt = now ; round_ [ _r id ] . end = now . add ( rnd init_ ) . add ( rnd gap_ ) ; round_ [ _r id ] . pot = _res ; return ( _event data_ ) ;"}
{"comment": "transfer tokens from one address to another .", "function": "function transfer from ( address _from , address _to , uint256 _value ) public returns ( bool ) { require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ _from ] ) ; require ( _value <= allowed [ _from ] [ msg . sender ] ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; transfer ( _from , _to , _value ) ; return BOOL_ ; }", "signature": "function transfer from ( address _from , address _to , uint256 _value ) public returns ( bool )", "body": "require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ _from ] ) ; require ( _value <= allowed [ _from ] [ msg . sender ] ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; transfer ( _from , _to , _value ) ; return BOOL_ ;"}
{"comment": "set art idtreport .", "function": "function set art idt ( string _id , string _idt report ) public only sys returns ( bool ) { string idt report = art infos [ _id ] . idt report ; bytes memory idt report len = bytes ( idt report ) ; if ( idt report len . length == NUM_ ) { art infos [ _id ] . idt report = _idt report ; set art idt ( _id , _idt report ) ; return BOOL_ ; } else { return BOOL_ ; } }", "signature": "function set art idt ( string _id , string _idt report ) public only sys returns ( bool )", "body": "string idt report = art infos [ _id ] . idt report ; bytes memory idt report len = bytes ( idt report ) ; if ( idt report len . length == NUM_ ) { art infos [ _id ] . idt report = _idt report ; set art idt ( _id , _idt report ) ; return BOOL_ ; } else { return BOOL_ ; }"}
{"comment": "called after setmigrationagent function to make sure that a new contract address be valid .", "function": "function start migration ( ) public only owner { require ( migration agent != address ( NUM_ ) ) ; require ( state == state . running ) ; state = state . migration ; new state ( state ) ; }", "signature": "function start migration ( ) public only owner", "body": "require ( migration agent != address ( NUM_ ) ) ; require ( state == state . running ) ; state = state . migration ; new state ( state ) ;"}
{"comment": "after a day , admin finalize the delegation .", "function": "function finalize delegation ( ) public only admin or owner { require ( delegate operation . admin == admin ) ; require ( delegate operation . defer block <= block . number ) ; delegate erc20 delegate = delegate operation . delegate ; delete delegate operation ; true usd . delegate to new contract ( delegate ) ; }", "signature": "function finalize delegation ( ) public only admin or owner", "body": "require ( delegate operation . admin == admin ) ; require ( delegate operation . defer block <= block . number ) ; delegate erc20 delegate = delegate operation . delegate ; delete delegate operation ; true usd . delegate to new contract ( delegate ) ;"}
{"comment": "true if the operation be successful .", "function": "function set buy price ( uint256 _new buy price , uint256 _new buy price final ) public only owner returns ( bool ) { buy price = _new buy price ; buy price final = _new buy price final ; return BOOL_ ; }", "signature": "function set buy price ( uint256 _new buy price , uint256 _new buy price final ) public only owner returns ( bool )", "body": "buy price = _new buy price ; buy price final = _new buy price final ; return BOOL_ ;"}
{"comment": "this function will return only the price of a specific video game .", "function": "function get video game current price ( uint _video game id ) public view returns ( uint256 ) { return ( video games [ _video game id ] . current price ) ; }", "signature": "function get video game current price ( uint _video game id ) public view returns ( uint256 )", "body": "return ( video games [ _video game id ] . current price ) ;"}
{"comment": "updates whitelistadmin address .", "function": "function change admin ( address _admin ) external only owner valid admin ( _admin ) { log admin updated ( _admin ) ; whitelist admin = _admin ; }", "signature": "function change admin ( address _admin ) external only owner valid admin ( _admin )", "body": "log admin updated ( _admin ) ; whitelist admin = _admin ;"}
{"comment": "add bounty for hunter .", "function": "function add bounty for hunter ( address hunter , uint bounty ) only owner ( ) external returns ( bool ) { require ( ! gabicoin ( token ) . is active ( ) ) ; bounties [ hunter ] += bounty ; bounty total += bounty ; add bounty ( hunter , bounty ) ; return BOOL_ ; }", "signature": "function add bounty for hunter ( address hunter , uint bounty ) only owner ( ) external returns ( bool )", "body": "require ( ! gabicoin ( token ) . is active ( ) ) ; bounties [ hunter ] += bounty ; bounty total += bounty ; add bounty ( hunter , bounty ) ; return BOOL_ ;"}
{"comment": "true if tokens be create successfully , false otherwise .", "function": "function create tokens ( uint256 _value ) returns ( bool success ) { require ( msg . sender == owner ) ; if ( _value > NUM_ ) { if ( _value > safe sub ( max_token_count , token count ) ) return BOOL_ ; accounts [ msg . sender ] = safe add ( accounts [ msg . sender ] , _value ) ; token count = safe add ( token count , _value ) ; emit transfer ( NUM_ , msg . sender , _value ) ; return BOOL_ ; } return BOOL_ ; }", "signature": "function create tokens ( uint256 _value ) returns ( bool success )", "body": "require ( msg . sender == owner ) ; if ( _value > NUM_ ) { if ( _value > safe sub ( max_token_count , token count ) ) return BOOL_ ; accounts [ msg . sender ] = safe add ( accounts [ msg . sender ] , _value ) ; token count = safe add ( token count , _value ) ; emit transfer ( NUM_ , msg . sender , _value ) ; return BOOL_ ; } return BOOL_ ;"}
{"comment": "amount of releasable token .", "function": "function releasable amount ( address _wallet ) public view returns ( uint256 ) { vesting memory vesting = vesting map [ _wallet ] ; return vested amount ( _wallet ) . sub ( vesting . released ) ; }", "signature": "function releasable amount ( address _wallet ) public view returns ( uint256 )", "body": "vesting memory vesting = vesting map [ _wallet ] ; return vested amount ( _wallet ) . sub ( vesting . released ) ;"}
{"comment": "next redemption request id .", "function": "function next redemption request ( uint _current redemption id ) public constant returns ( uint ) { return redemptions queue . next redemption ( _current redemption id ) ; }", "signature": "function next redemption request ( uint _current redemption id ) public constant returns ( uint )", "body": "return redemptions queue . next redemption ( _current redemption id ) ;"}
{"comment": "link to new application entity .", "function": "function link ( address _new address ) internal returns ( bool ) { current application entity address = _new address ; current app = application entity abi ( current application entity address ) ; if ( ! current app . initialize ( ) ) { revert ( ) ; } event gateway new address ( current application entity address ) ; return BOOL_ ; }", "signature": "function link ( address _new address ) internal returns ( bool )", "body": "current application entity address = _new address ; current app = application entity abi ( current application entity address ) ; if ( ! current app . initialize ( ) ) { revert ( ) ; } event gateway new address ( current application entity address ) ; return BOOL_ ;"}
{"comment": "inicializa el contrato con los tokens de suministro inicial al creador del contrato .", "function": "function americo token token ( ) { initial supply = NUM_ ; name = STR_ ; decimals = NUM_ ; symbol = STR_ ; balance of [ msg . sender ] = initial supply ; total supply = initial supply ; }", "signature": "function americo token token ( )", "body": "initial supply = NUM_ ; name = STR_ ; decimals = NUM_ ; symbol = STR_ ; balance of [ msg . sender ] = initial supply ; total supply = initial supply ;"}
{"comment": "transfers ownership of the reverse ens record associate with the call account .", "function": "function claim ( address owner ) returns ( bytes32 node ) { return claim with resolver ( owner , NUM_ ) ; }", "signature": "function claim ( address owner ) returns ( bytes32 node )", "body": "return claim with resolver ( owner , NUM_ ) ;"}
{"comment": "allows token owners to sell tokens directly to this contract .", "function": "function sell coins to ico ( uint256 amount of coins to sell ) public returns ( bool success ) { uint amount = amount of coins to sell ; msg sndr [ msg . sender ] = amount ; bool is preview = BOOL_ ; ico ico = ico ( _get ico addr ( ) ) ; bool icosuccess ; uint sell payment value ; ( icosuccess , sell payment value ) = ico . sell ( amount , msg . sender , is preview ) ; require ( icosuccess == BOOL_ ) ; require ( _get ico addr ( ) . balance >= safe add ( ico . get min bal ( ) , sell payment value ) ) ; bool sucs tr tk = BOOL_ ; bool pym act sucs = BOOL_ ; if ( is preview == BOOL_ ) { sucs tr tk = _safe transfer tkn ( msg . sender , owner , amount ) ; require ( sucs tr tk == BOOL_ ) ; msg sndr [ msg . sender ] = sell payment value ; pym act sucs = _safe payment action at ico ( sell payment value , msg . sender , NUM_ ) ; require ( pym act sucs == BOOL_ ) ; } msg sndr [ msg . sender ] = NUM_ ; return ( BOOL_ ) ; }", "signature": "function sell coins to ico ( uint256 amount of coins to sell ) public returns ( bool success )", "body": "uint amount = amount of coins to sell ; msg sndr [ msg . sender ] = amount ; bool is preview = BOOL_ ; ico ico = ico ( _get ico addr ( ) ) ; bool icosuccess ; uint sell payment value ; ( icosuccess , sell payment value ) = ico . sell ( amount , msg . sender , is preview ) ; require ( icosuccess == BOOL_ ) ; require ( _get ico addr ( ) . balance >= safe add ( ico . get min bal ( ) , sell payment value ) ) ; bool sucs tr tk = BOOL_ ; bool pym act sucs = BOOL_ ; if ( is preview == BOOL_ ) { sucs tr tk = _safe transfer tkn ( msg . sender , owner , amount ) ; require ( sucs tr tk == BOOL_ ) ; msg sndr [ msg . sender ] = sell payment value ; pym act sucs = _safe payment action at ico ( sell payment value , msg . sender , NUM_ ) ; require ( pym act sucs == BOOL_ ) ; } msg sndr [ msg . sender ] = NUM_ ; return ( BOOL_ ) ;"}
{"comment": "send _value tokens to _to from your account .", "function": "function transfer ( address _to , uint256 _value ) returns ( bool success ) { _transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }", "signature": "function transfer ( address _to , uint256 _value ) returns ( bool success )", "body": "_transfer ( msg . sender , _to , _value ) ; return BOOL_ ;"}
{"comment": "safely transfer the ownership of a give token id to another address .", "function": "function safe transfer from ( address _from , address _to , uint256 _token id ) public { safe transfer from ( _from , _to , _token id , STR_ ) ; }", "signature": "function safe transfer from ( address _from , address _to , uint256 _token id ) public", "body": "safe transfer from ( _from , _to , _token id , STR_ ) ;"}
{"comment": "modify ico cap .", "function": "function set ico cap ( uint256 new ico cap ) public only owner { ico cap = new ico cap ; }", "signature": "function set ico cap ( uint256 new ico cap ) public only owner", "body": "ico cap = new ico cap ;"}
{"comment": "set auditor account address to a new value .", "function": "function owner set auditor ( address _auditor address ) external only owner { require ( _auditor address != NUM_ ) ; auditor address = _auditor address ; }", "signature": "function owner set auditor ( address _auditor address ) external only owner", "body": "require ( _auditor address != NUM_ ) ; auditor address = _auditor address ;"}
{"comment": "release all the bet back to the better if , for any reason , payouts can not be complete .", "function": "function release bets ( ) private { uint stored balance = this . balance ; for ( uint k = NUM_ ; k < betters . length ; k ++ ) { uint total bet = better info [ betters [ k ] ] . amounts bet [ NUM_ ] + better info [ betters [ k ] ] . amounts bet [ NUM_ ] ; betters [ k ] . transfer ( total bet * stored balance / total bet amount ) ; } }", "signature": "function release bets ( ) private", "body": "uint stored balance = this . balance ; for ( uint k = NUM_ ; k < betters . length ; k ++ ) { uint total bet = better info [ betters [ k ] ] . amounts bet [ NUM_ ] + better info [ betters [ k ] ] . amounts bet [ NUM_ ] ; betters [ k ] . transfer ( total bet * stored balance / total bet amount ) ; }"}
{"comment": "check if ico be live .", "function": "modifier check if icois live ( ) { require ( stage != stages . pending && stage != stages . ended ) ; if ( stage == stages . pre sale ) { require ( start time presale > NUM_ && now >= start time presale && now <= tier end time [ NUM_ ] ) ; } else { require ( start time > NUM_ && now >= start time && now <= end time ) ; } _ ; }", "signature": "modifier check if icois live ( )", "body": "require ( stage != stages . pending && stage != stages . ended ) ; if ( stage == stages . pre sale ) { require ( start time presale > NUM_ && now >= start time presale && now <= tier end time [ NUM_ ] ) ; } else { require ( start time > NUM_ && now >= start time && now <= end time ) ; } _ ;"}
{"comment": "this function send b2bk tokens to the specify address when send eth .", "function": "function buy ( address _to ) public valid address ( _to ) is not finalized payable { uint256 _amount = msg . value ; assert ( _amount > NUM_ ) ; uint256 _tokens = _amount . mul ( rate ) ; assert ( total supply . add ( _tokens ) <= total max buy ) ; total supply = total supply . add ( _tokens ) ; total eth = total eth . add ( _amount ) ; balance of [ _to ] = balance of [ _to ] . add ( _tokens ) ; wallet . transfer ( _amount ) ; buy ( msg . sender , _to , rate , _tokens ) ; transfer ( this , _to , _tokens ) ; fund transfer ( msg . sender , _amount , BOOL_ ) ; }", "signature": "function buy ( address _to ) public valid address ( _to ) is not finalized payable", "body": "uint256 _amount = msg . value ; assert ( _amount > NUM_ ) ; uint256 _tokens = _amount . mul ( rate ) ; assert ( total supply . add ( _tokens ) <= total max buy ) ; total supply = total supply . add ( _tokens ) ; total eth = total eth . add ( _amount ) ; balance of [ _to ] = balance of [ _to ] . add ( _tokens ) ; wallet . transfer ( _amount ) ; buy ( msg . sender , _to , rate , _tokens ) ; transfer ( this , _to , _tokens ) ; fund transfer ( msg . sender , _amount , BOOL_ ) ;"}
{"comment": "trading limit - require the token sale to have close .", "function": "function transfer from ( address _from , address _to , uint256 _value ) public returns ( bool ) { if ( ! sale closed ) return BOOL_ ; return super . transfer from ( _from , _to , _value ) ; }", "signature": "function transfer from ( address _from , address _to , uint256 _value ) public returns ( bool )", "body": "if ( ! sale closed ) return BOOL_ ; return super . transfer from ( _from , _to , _value ) ;"}
{"comment": "assigns ownership of a specific region to an address .", "function": "function _transfer ( address _from , address _to , uint256 _token id ) private { ownership token count [ _to ] ++ ; region index to owner [ _token id ] = _to ; if ( _from != address ( NUM_ ) ) { ownership token count [ _from ] -- ; delete region index to approved [ _token id ] ; } transfer ( _from , _to , _token id ) ; }", "signature": "function _transfer ( address _from , address _to , uint256 _token id ) private", "body": "ownership token count [ _to ] ++ ; region index to owner [ _token id ] = _to ; if ( _from != address ( NUM_ ) ) { ownership token count [ _from ] -- ; delete region index to approved [ _token id ] ; } transfer ( _from , _to , _token id ) ;"}
{"comment": "function that set the conversion rate .", "function": "function set rate ( uint _rate in wei ) only owner public { require ( _rate in wei > NUM_ ) ; rate = _rate in wei ; rate set ( rate ) ; }", "signature": "function set rate ( uint _rate in wei ) only owner public", "body": "require ( _rate in wei > NUM_ ) ; rate = _rate in wei ; rate set ( rate ) ;"}
{"comment": "round three sale period .", "function": "function is round three sale period ( uint date ) public constant returns ( bool ) { return date >= round three from && date <= round three until && round three amount > NUM_ ; }", "signature": "function is round three sale period ( uint date ) public constant returns ( bool )", "body": "return date >= round three from && date <= round three until && round three amount > NUM_ ;"}
{"comment": "an internal method that create a new cutie and store it .", "function": "function _create cutie ( uint40 _mom id , uint40 _dad id , uint16 _generation , uint16 _cooldown index , uint256 _genes , address _owner , uint40 _birth time ) internal returns ( uint40 ) { cutie memory _cutie = cutie ( { genes : _genes , birth time : _birth time , cooldown end time : NUM_ , mom id : _mom id , dad id : _dad id , cooldown index : _cooldown index , generation : _generation , optional : NUM_ } ) ; uint256 new cutie id256 = cuties . push ( _cutie ) - NUM_ ; require ( new cutie id256 <= NUM_ ) ; uint40 new cutie id = uint40 ( new cutie id256 ) ; emit birth ( _owner , new cutie id , _cutie . mom id , _cutie . dad id , _cutie . genes ) ; _transfer ( NUM_ , _owner , new cutie id ) ; return new cutie id ; }", "signature": "function _create cutie ( uint40 _mom id , uint40 _dad id , uint16 _generation , uint16 _cooldown index , uint256 _genes , address _owner , uint40 _birth time ) internal returns ( uint40 )", "body": "cutie memory _cutie = cutie ( { genes : _genes , birth time : _birth time , cooldown end time : NUM_ , mom id : _mom id , dad id : _dad id , cooldown index : _cooldown index , generation : _generation , optional : NUM_ } ) ; uint256 new cutie id256 = cuties . push ( _cutie ) - NUM_ ; require ( new cutie id256 <= NUM_ ) ; uint40 new cutie id = uint40 ( new cutie id256 ) ; emit birth ( _owner , new cutie id , _cutie . mom id , _cutie . dad id , _cutie . genes ) ; _transfer ( NUM_ , _owner , new cutie id ) ; return new cutie id ;"}
{"comment": "withdraw the fund .", "function": "function withdraw ( uint _amount ) only owner public { require ( _amount > NUM_ ) ; require ( _amount <= wei balance ) ; if ( owner . send ( _amount ) ) { wei balance -= _amount ; emit withdrawal ( owner , _amount ) ; } else { throw ; } }", "signature": "function withdraw ( uint _amount ) only owner public", "body": "require ( _amount > NUM_ ) ; require ( _amount <= wei balance ) ; if ( owner . send ( _amount ) ) { wei balance -= _amount ; emit withdrawal ( owner , _amount ) ; } else { throw ; }"}
{"comment": "internal function to assign tokens to the contributor .", "function": "function buy tokens ( address _address , uint256 _value ) internal returns ( bool ) { require ( is whitelisted ( _address ) ) ; require ( is valid contribution ( _address , _value ) ) ; uint256 bought tokens = calculate tokens ( _value ) ; require ( bought tokens != NUM_ ) ; if ( bought tokens > get tokens available ( ) ) { revert ( ) ; } add to investor ( _address , _value , bought tokens ) ; forward funds ( _value ) ; update sale parameters ( bought tokens ) ; log token purchase ( msg . sender , _address , _value , bought tokens ) ; return BOOL_ ; }", "signature": "function buy tokens ( address _address , uint256 _value ) internal returns ( bool )", "body": "require ( is whitelisted ( _address ) ) ; require ( is valid contribution ( _address , _value ) ) ; uint256 bought tokens = calculate tokens ( _value ) ; require ( bought tokens != NUM_ ) ; if ( bought tokens > get tokens available ( ) ) { revert ( ) ; } add to investor ( _address , _value , bought tokens ) ; forward funds ( _value ) ; update sale parameters ( bought tokens ) ; log token purchase ( msg . sender , _address , _value , bought tokens ) ; return BOOL_ ;"}
{"comment": "wrapper to call setcolors 8 time in one call .", "function": "function set colors x8 ( uint16 [ NUM_ ] property ids , uint256 [ NUM_ ] new colors , uint256 pxlto spend each ) public returns ( bool [ NUM_ ] ) { bool [ NUM_ ] results ; for ( uint256 i = NUM_ ; i < NUM_ ; i ++ ) { require ( property ids [ i ] < NUM_ ) ; results [ i ] = set colors ( property ids [ i ] , [ new colors [ i * NUM_ ] , new colors [ i * NUM_ + NUM_ ] , new colors [ i * NUM_ + NUM_ ] , new colors [ i * NUM_ + NUM_ ] , new colors [ i * NUM_ + NUM_ ] ] , pxlto spend each ) ; } return results ; }", "signature": "function set colors x8 ( uint16 [ NUM_ ] property ids , uint256 [ NUM_ ] new colors , uint256 pxlto spend each ) public returns ( bool [ NUM_ ] )", "body": "bool [ NUM_ ] results ; for ( uint256 i = NUM_ ; i < NUM_ ; i ++ ) { require ( property ids [ i ] < NUM_ ) ; results [ i ] = set colors ( property ids [ i ] , [ new colors [ i * NUM_ ] , new colors [ i * NUM_ + NUM_ ] , new colors [ i * NUM_ + NUM_ ] , new colors [ i * NUM_ + NUM_ ] , new colors [ i * NUM_ + NUM_ ] ] , pxlto spend each ) ; } return results ;"}
{"comment": "set art evtreport .", "function": "function set art evt ( string _id , string _evt report ) public only sys returns ( bool ) { string evt report = art infos [ _id ] . evt report ; bytes memory evt report len = bytes ( evt report ) ; if ( evt report len . length == NUM_ ) { art infos [ _id ] . evt report = _evt report ; set art evt ( _id , _evt report ) ; return BOOL_ ; } else { return BOOL_ ; } }", "signature": "function set art evt ( string _id , string _evt report ) public only sys returns ( bool )", "body": "string evt report = art infos [ _id ] . evt report ; bytes memory evt report len = bytes ( evt report ) ; if ( evt report len . length == NUM_ ) { art infos [ _id ] . evt report = _evt report ; set art evt ( _id , _evt report ) ; return BOOL_ ; } else { return BOOL_ ; }"}
{"comment": "list assets in a particular state .", "function": "function list assets ( uint256 _state_id , uint256 _count , bool _from_start ) public constant returns ( bytes32 [ ] _assets ) { bytes32 _collection = bytes32 ( _state_id ) ; _assets = list_indexed_bytesarray ( _collection , _count , assets_explorer_controller ( ) . get_first_item_in_state , assets_explorer_controller ( ) . get_last_item_in_state , assets_explorer_controller ( ) . get_next_item_in_state_from_item , assets_explorer_controller ( ) . get_previous_item_in_state_from_item , _from_start ) ; }", "signature": "function list assets ( uint256 _state_id , uint256 _count , bool _from_start ) public constant returns ( bytes32 [ ] _assets )", "body": "bytes32 _collection = bytes32 ( _state_id ) ; _assets = list_indexed_bytesarray ( _collection , _count , assets_explorer_controller ( ) . get_first_item_in_state , assets_explorer_controller ( ) . get_last_item_in_state , assets_explorer_controller ( ) . get_next_item_in_state_from_item , assets_explorer_controller ( ) . get_previous_item_in_state_from_item , _from_start ) ;"}
{"comment": "sets start date for ico phase .", "function": "function set icodates ( uint _ico_start , uint _ico_1_days , uint _ico_2_days , uint _ico_3_days , uint _ico_4_days , uint _ico_5_days ) public only owner or manager { _update phase ( BOOL_ ) ; require ( phase_i != phase_finished && phase_i != phase_ico_finished && phase_i < phase_ico_1 , STR_ ) ; require ( presale_end < _ico_start , STR_ ) ; ico_start = _ico_start ; ico_phase_1_days = _ico_1_days ; ico_phase_2_days = _ico_2_days ; ico_phase_3_days = _ico_3_days ; ico_phase_4_days = _ico_4_days ; ico_phase_5_days = _ico_5_days ; _update phase times ( ) ; }", "signature": "function set icodates ( uint _ico_start , uint _ico_1_days , uint _ico_2_days , uint _ico_3_days , uint _ico_4_days , uint _ico_5_days ) public only owner or manager", "body": "_update phase ( BOOL_ ) ; require ( phase_i != phase_finished && phase_i != phase_ico_finished && phase_i < phase_ico_1 , STR_ ) ; require ( presale_end < _ico_start , STR_ ) ; ico_start = _ico_start ; ico_phase_1_days = _ico_1_days ; ico_phase_2_days = _ico_2_days ; ico_phase_3_days = _ico_3_days ; ico_phase_4_days = _ico_4_days ; ico_phase_5_days = _ico_5_days ; _update phase times ( ) ;"}
{"comment": "start new tgr stage .", "function": "function tgr set live ( ) public only ( project wallet ) is not tgr live is not frozen only { tgr number += NUM_ ; tgr start block = block . number ; tgr amount collected = NUM_ ; tgr contributed amount = NUM_ ; emit tgrstarted ( tgr settings amount , tgr settings minimal contribution , tgr settings part contributor , tgr settings part project , tgr settings part founders , tgr settings blocks per stage , tgr settings part contributor increase per stage , tgr settings max stages , block . number , tgr number ) ; }", "signature": "function tgr set live ( ) public only ( project wallet ) is not tgr live is not frozen only", "body": "tgr number += NUM_ ; tgr start block = block . number ; tgr amount collected = NUM_ ; tgr contributed amount = NUM_ ; emit tgrstarted ( tgr settings amount , tgr settings minimal contribution , tgr settings part contributor , tgr settings part project , tgr settings part founders , tgr settings blocks per stage , tgr settings part contributor increase per stage , tgr settings max stages , block . number , tgr number ) ;"}
{"comment": "change the master copy of the oracle .", "function": "function upgrade oracle ( address _oracle master copy ) public is owner { require ( _oracle master copy != NUM_ ) ; oracle master copy = oracle ( _oracle master copy ) ; emit oracle upgraded ( _oracle master copy ) ; }", "signature": "function upgrade oracle ( address _oracle master copy ) public is owner", "body": "require ( _oracle master copy != NUM_ ) ; oracle master copy = oracle ( _oracle master copy ) ; emit oracle upgraded ( _oracle master copy ) ;"}
{"comment": "how many tokens be reservedfor owner a comission .", "function": "function get reserve amount ( address token address ) public view returns ( uint256 amount ) { return _system reserves [ token address ] ; }", "signature": "function get reserve amount ( address token address ) public view returns ( uint256 amount )", "body": "return _system reserves [ token address ] ;"}
{"comment": "standard function transfer similar to erc20 transfer with no _data .", "function": "function transfer ( address _to , uint _value ) public when not paused returns ( bool ) { require ( _to != NUM_ ) ; bytes memory empty ; if ( _to . is contract ( ) ) { return transfer to contract ( _to , _value , empty ) ; } else { return transfer to address ( _to , _value , empty ) ; } }", "signature": "function transfer ( address _to , uint _value ) public when not paused returns ( bool )", "body": "require ( _to != NUM_ ) ; bytes memory empty ; if ( _to . is contract ( ) ) { return transfer to contract ( _to , _value , empty ) ; } else { return transfer to address ( _to , _value , empty ) ; }"}
{"comment": "allows any user to withdraw his tokens .", "function": "function withdraw ( ) { require ( bought_tokens ) ; uint256 contract_token_balance = token . balance of ( address ( this ) ) ; require ( contract_token_balance != NUM_ ) ; uint256 tokens_to_withdraw = ( balances [ msg . sender ] * contract_token_balance ) / contract_eth_value ; contract_eth_value -= balances [ msg . sender ] ; balances [ msg . sender ] = NUM_ ; require ( token . transfer ( msg . sender , tokens_to_withdraw ) ) ; }", "signature": "function withdraw ( )", "body": "require ( bought_tokens ) ; uint256 contract_token_balance = token . balance of ( address ( this ) ) ; require ( contract_token_balance != NUM_ ) ; uint256 tokens_to_withdraw = ( balances [ msg . sender ] * contract_token_balance ) / contract_eth_value ; contract_eth_value -= balances [ msg . sender ] ; balances [ msg . sender ] = NUM_ ; require ( token . transfer ( msg . sender , tokens_to_withdraw ) ) ;"}
{"comment": "pay the contract balance to the contract creator .", "function": "function pay up ( ) public owner only after hold expiry { uint payment = address ( this ) . balance ; total contributions -= payment ; if ( total contributions != NUM_ ) { emit warning ( STR_ ) ; } contribution time = NUM_ ; emit paid out ( payment ) ; creator . transfer ( payment ) ; }", "signature": "function pay up ( ) public owner only after hold expiry", "body": "uint payment = address ( this ) . balance ; total contributions -= payment ; if ( total contributions != NUM_ ) { emit warning ( STR_ ) ; } contribution time = NUM_ ; emit paid out ( payment ) ; creator . transfer ( payment ) ;"}
{"comment": "compute the umbrellacoin bonus accord to the investment period .", "function": "function bonus ( uint amount ) internal constant returns ( uint ) { if ( amount raised <= NUM_ ether ) { return amount . mul ( NUM_ ) ; } else if ( amount raised >= NUM_ ether && amount raised <= NUM_ ether ) { return amount . mul ( NUM_ ) ; } else if ( amount raised >= NUM_ ether && amount raised <= NUM_ ether ) { return amount . mul ( NUM_ ) ; } else if ( amount raised >= NUM_ ether && amount raised <= NUM_ ether ) { return ( amount . mul ( NUM_ ) ) / NUM_ ; } return amount ; }", "signature": "function bonus ( uint amount ) internal constant returns ( uint )", "body": "if ( amount raised <= NUM_ ether ) { return amount . mul ( NUM_ ) ; } else if ( amount raised >= NUM_ ether && amount raised <= NUM_ ether ) { return amount . mul ( NUM_ ) ; } else if ( amount raised >= NUM_ ether && amount raised <= NUM_ ether ) { return amount . mul ( NUM_ ) ; } else if ( amount raised >= NUM_ ether && amount raised <= NUM_ ether ) { return ( amount . mul ( NUM_ ) ) / NUM_ ; } return amount ;"}
{"comment": "this use call . value ( ) ( ) .", "function": "function withdraw ether or throw ( uint256 amount ) private { bool result = msg . sender . call . value ( amount ) ( ) ; if ( ! result ) { throw ; } }", "signature": "function withdraw ether or throw ( uint256 amount ) private", "body": "bool result = msg . sender . call . value ( amount ) ( ) ; if ( ! result ) { throw ; }"}
{"comment": "transfer tokens from the caller to a new holder .", "function": "function transfer ( address _to address , uint256 _amount of tokens ) only token holders ( ) public returns ( bool ) { address _customer address = msg . sender ; require ( _amount of tokens >= min_token_transfer && _amount of tokens <= token balance ledger_ [ _customer address ] ) ; bytes memory empty ; transfer from internal ( _customer address , _to address , _amount of tokens , empty ) ; return BOOL_ ; }", "signature": "function transfer ( address _to address , uint256 _amount of tokens ) only token holders ( ) public returns ( bool )", "body": "address _customer address = msg . sender ; require ( _amount of tokens >= min_token_transfer && _amount of tokens <= token balance ledger_ [ _customer address ] ) ; bytes memory empty ; transfer from internal ( _customer address , _to address , _amount of tokens , empty ) ; return BOOL_ ;"}
{"comment": "settle an investment make in eth and distribute tokens .", "function": "function invest ( address investor , uint256 token price in pico usd , uint256 invested in wei , bytes32 hash , uint8 v , bytes32 r , bytes32 s , uint256 wei to usd ) public ico is active payable { require ( sha256 ( uint ( investor ) << NUM_ | token price in pico usd ) == hash ) ; require ( ecrecover ( hash , v , r , s ) == signer ) ; require ( sub ( invested in wei , msg . value ) <= with decimals ( NUM_ , NUM_ ) ) ; uint token price in wei = div ( mul ( token price in pico usd , wei to usd ) , pow ( NUM_ , usd decimals ) ) ; uint256 tokens number = div ( with decimals ( invested in wei , decimals ) , token price in wei ) ; require ( balances [ ico allocation ] >= tokens number ) ; require ( multisig . send ( msg . value ) ) ; uint256 invested in pico usd = div ( with decimals ( invested in wei , usd decimals ) , wei to usd ) ; invest in usd ( investor , invested in pico usd , tokens number ) ; investment in eth ( investor , token price in wei , invested in wei , invested in pico usd , tokens number , hash ) ; }", "signature": "function invest ( address investor , uint256 token price in pico usd , uint256 invested in wei , bytes32 hash , uint8 v , bytes32 r , bytes32 s , uint256 wei to usd ) public ico is active payable", "body": "require ( sha256 ( uint ( investor ) << NUM_ | token price in pico usd ) == hash ) ; require ( ecrecover ( hash , v , r , s ) == signer ) ; require ( sub ( invested in wei , msg . value ) <= with decimals ( NUM_ , NUM_ ) ) ; uint token price in wei = div ( mul ( token price in pico usd , wei to usd ) , pow ( NUM_ , usd decimals ) ) ; uint256 tokens number = div ( with decimals ( invested in wei , decimals ) , token price in wei ) ; require ( balances [ ico allocation ] >= tokens number ) ; require ( multisig . send ( msg . value ) ) ; uint256 invested in pico usd = div ( with decimals ( invested in wei , usd decimals ) , wei to usd ) ; invest in usd ( investor , invested in pico usd , tokens number ) ; investment in eth ( investor , token price in wei , invested in wei , invested in pico usd , tokens number , hash ) ;"}
{"comment": "every quarter release , 25 of token to the founder .", "function": "function release founder tokens ( ) external only owner returns ( bool ) { if ( quarter first && block . timestamp >= ( opening time . add ( NUM_ weeks ) ) ) { quarter first = BOOL_ ; token . transfer ( _founder_one , quarterly_release ) ; token . transfer ( _founder_two , quarterly_release ) ; allocated [ _founder_one ] = allocated [ _founder_one ] . sub ( quarterly_release ) ; allocated [ _founder_two ] = allocated [ _founder_two ] . sub ( quarterly_release ) ; total allocated = total allocated . sub ( quarterly_release ) ; total allocated = total allocated . sub ( quarterly_release ) ; } if ( quarter second && block . timestamp >= ( opening time . add ( NUM_ weeks ) ) ) { quarter second = BOOL_ ; token . transfer ( _founder_one , quarterly_release ) ; token . transfer ( _founder_two , quarterly_release ) ; allocated [ _founder_one ] = allocated [ _founder_one ] . sub ( quarterly_release ) ; allocated [ _founder_two ] = allocated [ _founder_two ] . sub ( quarterly_release ) ; total allocated = total allocated . sub ( quarterly_release ) ; total allocated = total allocated . sub ( quarterly_release ) ; } if ( quarter third && block . timestamp >= ( opening time . add ( NUM_ weeks ) ) ) { quarter third = BOOL_ ; token . transfer ( _founder_one , quarterly_release ) ; token . transfer ( _founder_two , quarterly_release ) ; allocated [ _founder_one ] = allocated [ _founder_one ] . sub ( quarterly_release ) ; allocated [ _founder_two ] = allocated [ _founder_two ] . sub ( quarterly_release ) ; total allocated = total allocated . sub ( quarterly_release ) ; total allocated = total allocated . sub ( quarterly_release ) ; } if ( quarter fourth && block . timestamp >= ( opening time . add ( NUM_ weeks ) ) ) { quarter fourth = BOOL_ ; token . transfer ( _founder_one , quarterly_release ) ; token . transfer ( _founder_two , quarterly_release ) ; allocated [ _founder_one ] = allocated [ _founder_one ] . sub ( quarterly_release ) ; allocated [ _founder_two ] = allocated [ _founder_two ] . sub ( quarterly_release ) ; total allocated = total allocated . sub ( quarterly_release ) ; total allocated = total allocated . sub ( quarterly_release ) ; } return BOOL_ ; }", "signature": "function release founder tokens ( ) external only owner returns ( bool )", "body": "if ( quarter first && block . timestamp >= ( opening time . add ( NUM_ weeks ) ) ) { quarter first = BOOL_ ; token . transfer ( _founder_one , quarterly_release ) ; token . transfer ( _founder_two , quarterly_release ) ; allocated [ _founder_one ] = allocated [ _founder_one ] . sub ( quarterly_release ) ; allocated [ _founder_two ] = allocated [ _founder_two ] . sub ( quarterly_release ) ; total allocated = total allocated . sub ( quarterly_release ) ; total allocated = total allocated . sub ( quarterly_release ) ; } if ( quarter second && block . timestamp >= ( opening time . add ( NUM_ weeks ) ) ) { quarter second = BOOL_ ; token . transfer ( _founder_one , quarterly_release ) ; token . transfer ( _founder_two , quarterly_release ) ; allocated [ _founder_one ] = allocated [ _founder_one ] . sub ( quarterly_release ) ; allocated [ _founder_two ] = allocated [ _founder_two ] . sub ( quarterly_release ) ; total allocated = total allocated . sub ( quarterly_release ) ; total allocated = total allocated . sub ( quarterly_release ) ; } if ( quarter third && block . timestamp >= ( opening time . add ( NUM_ weeks ) ) ) { quarter third = BOOL_ ; token . transfer ( _founder_one , quarterly_release ) ; token . transfer ( _founder_two , quarterly_release ) ; allocated [ _founder_one ] = allocated [ _founder_one ] . sub ( quarterly_release ) ; allocated [ _founder_two ] = allocated [ _founder_two ] . sub ( quarterly_release ) ; total allocated = total allocated . sub ( quarterly_release ) ; total allocated = total allocated . sub ( quarterly_release ) ; } if ( quarter fourth && block . timestamp >= ( opening time . add ( NUM_ weeks ) ) ) { quarter fourth = BOOL_ ; token . transfer ( _founder_one , quarterly_release ) ; token . transfer ( _founder_two , quarterly_release ) ; allocated [ _founder_one ] = allocated [ _founder_one ] . sub ( quarterly_release ) ; allocated [ _founder_two ] = allocated [ _founder_two ] . sub ( quarterly_release ) ; total allocated = total allocated . sub ( quarterly_release ) ; total allocated = total allocated . sub ( quarterly_release ) ; } return BOOL_ ;"}
{"comment": "minimum fee be 1 unless same day .", "function": "function calc fees ( uint256 start , uint256 end , uint256 start amount ) constant returns ( uint256 amount , uint256 fee ) { if ( start amount == NUM_ ) return ; uint256 number of days = wot day ( end ) - wot day ( start ) ; if ( number of days == NUM_ ) { amount = start amount ; return ; } amount = ( rate for days ( number of days ) * start amount ) / ( NUM_ ether ) ; if ( ( fee == NUM_ ) && ( amount != NUM_ ) ) amount -- ; fee = safe sub ( start amount , amount ) ; }", "signature": "function calc fees ( uint256 start , uint256 end , uint256 start amount ) constant returns ( uint256 amount , uint256 fee )", "body": "if ( start amount == NUM_ ) return ; uint256 number of days = wot day ( end ) - wot day ( start ) ; if ( number of days == NUM_ ) { amount = start amount ; return ; } amount = ( rate for days ( number of days ) * start amount ) / ( NUM_ ether ) ; if ( ( fee == NUM_ ) && ( amount != NUM_ ) ) amount -- ; fee = safe sub ( start amount , amount ) ;"}
{"comment": "a contract attempt to get the coin .", "function": "function transfer from ( address _from , address _to , uint256 _value ) returns ( bool success ) { if ( _to == NUM_ ) throw ; if ( _value <= NUM_ ) throw ; if ( balance of [ _from ] < _value ) throw ; if ( balance of [ _to ] + _value < balance of [ _to ] ) throw ; if ( _value > allowance [ _from ] [ msg . sender ] ) throw ; balance of [ _from ] = safe math . safe sub ( balance of [ _from ] , _value ) ; balance of [ _to ] = safe math . safe add ( balance of [ _to ] , _value ) ; allowance [ _from ] [ msg . sender ] = safe math . safe sub ( allowance [ _from ] [ msg . sender ] , _value ) ; transfer ( _from , _to , _value ) ; return BOOL_ ; }", "signature": "function transfer from ( address _from , address _to , uint256 _value ) returns ( bool success )", "body": "if ( _to == NUM_ ) throw ; if ( _value <= NUM_ ) throw ; if ( balance of [ _from ] < _value ) throw ; if ( balance of [ _to ] + _value < balance of [ _to ] ) throw ; if ( _value > allowance [ _from ] [ msg . sender ] ) throw ; balance of [ _from ] = safe math . safe sub ( balance of [ _from ] , _value ) ; balance of [ _to ] = safe math . safe add ( balance of [ _to ] , _value ) ; allowance [ _from ] [ msg . sender ] = safe math . safe sub ( allowance [ _from ] [ msg . sender ] , _value ) ; transfer ( _from , _to , _value ) ; return BOOL_ ;"}
{"comment": "determine the current sale tier .", "function": "function current round index by date ( ) internal view returns ( uint8 round num ) { require ( now <= date14 june2018 ) ; if ( now > date sale r3 ) return NUM_ ; if ( now > date sale r2 ) return NUM_ ; if ( now > date sale r1 ) return NUM_ ; if ( now > date pre sale ) return NUM_ ; else return NUM_ ; }", "signature": "function current round index by date ( ) internal view returns ( uint8 round num )", "body": "require ( now <= date14 june2018 ) ; if ( now > date sale r3 ) return NUM_ ; if ( now > date sale r2 ) return NUM_ ; if ( now > date sale r1 ) return NUM_ ; if ( now > date pre sale ) return NUM_ ; else return NUM_ ;"}
{"comment": "revert if sender be whitelistagent .", "function": "modifier only white list agent ( ) { require ( msg . sender == white list agent ) ; _ ; }", "signature": "modifier only white list agent ( )", "body": "require ( msg . sender == white list agent ) ; _ ;"}
{"comment": "only for the owner of the contract .", "function": "function add commission to pending withdrawals ( uint32 _canvas id ) external only owner state owned ( _canvas id ) force owned ( _canvas id ) { canvas storage canvas = _get canvas ( _canvas id ) ; uint commission ; bool is paid ; ( commission , is paid ) = calculate commission ( _canvas id ) ; require ( commission > NUM_ ) ; require ( ! is paid ) ; canvas . is commission paid = BOOL_ ; add pending withdrawal ( owner , commission ) ; emit commission added to withdrawals ( _canvas id , commission , action_initial_bidding ) ; }", "signature": "function add commission to pending withdrawals ( uint32 _canvas id ) external only owner state owned ( _canvas id ) force owned ( _canvas id )", "body": "canvas storage canvas = _get canvas ( _canvas id ) ; uint commission ; bool is paid ; ( commission , is paid ) = calculate commission ( _canvas id ) ; require ( commission > NUM_ ) ; require ( ! is paid ) ; canvas . is commission paid = BOOL_ ; add pending withdrawal ( owner , commission ) ; emit commission added to withdrawals ( _canvas id , commission , action_initial_bidding ) ;"}
{"comment": "backup withdraw , if somehow eth get in here .", "function": "function withdraw ( ) public is admin { admin . transfer ( address ( this ) . balance ) ; }", "signature": "function withdraw ( ) public is admin", "body": "admin . transfer ( address ( this ) . balance ) ;"}
{"comment": "adds a reward percentage to the list of available reward percentages , specific to 18 decimals .", "function": "function add reward percentage ( uint256 _percentage ) public only admin is valid reward percentage ( _percentage ) returns ( uint256 _index ) { _index = reward percentage . length ; reward percentage . push ( _percentage ) ; emit reward percentage ( _index , _percentage ) ; }", "signature": "function add reward percentage ( uint256 _percentage ) public only admin is valid reward percentage ( _percentage ) returns ( uint256 _index )", "body": "_index = reward percentage . length ; reward percentage . push ( _percentage ) ; emit reward percentage ( _index , _percentage ) ;"}
{"comment": "true if crowdsale event have end .", "function": "function has ended ( ) public constant returns ( bool ) { return now > end time ; }", "signature": "function has ended ( ) public constant returns ( bool )", "body": "return now > end time ;"}
{"comment": "allows to change the number of required confirmations .", "function": "function change requirement ( uint _required ) public only wallet valid requirement ( owners . length , _required ) { required = _required ; requirement change ( _required ) ; }", "signature": "function change requirement ( uint _required ) public only wallet valid requirement ( owners . length , _required )", "body": "required = _required ; requirement change ( _required ) ;"}
{"comment": "team withdrawal after specified time .", "function": "function withdraw_1 ( ) only admin public { require ( eth to be claimed > NUM_ ) ; require ( withdraw_1 completed == BOOL_ ) ; require ( now >= unlock date1 ) ; admin . transfer ( eth to be claimed . div ( quarter1 ) ) ; emit withdrew ( admin , eth to be claimed . div ( quarter1 ) ) ; withdraw_1 completed = BOOL_ ; }", "signature": "function withdraw_1 ( ) only admin public", "body": "require ( eth to be claimed > NUM_ ) ; require ( withdraw_1 completed == BOOL_ ) ; require ( now >= unlock date1 ) ; admin . transfer ( eth to be claimed . div ( quarter1 ) ) ; emit withdrew ( admin , eth to be claimed . div ( quarter1 ) ) ; withdraw_1 completed = BOOL_ ;"}
{"comment": "burns a specific amount of tokens .", "function": "function burn ( uint256 _value ) public { _burn ( msg . sender , _value ) ; }", "signature": "function burn ( uint256 _value ) public", "body": "_burn ( msg . sender , _value ) ;"}
{"comment": "split the challenge function into multiple part because of stack too deep error .", "function": "function _challenge part2 ( uint _dungeon id , uint _dungeon difficulty , uint _hero id ) private { uint floor number ; uint rewards ; uint floor genes ; ( , , , , floor number , , rewards , , floor genes ) = dungeon token contract . dungeons ( _dungeon id ) ; uint hero genes ; ( , , , hero genes ) = hero token contract . heroes ( _hero id ) ; bool success = _get challenge success ( hero genes , _dungeon difficulty , floor genes ) ; uint new floor genes ; uint master rewards ; uint consolation rewards ; uint success rewards ; uint new rewards ; if ( success ) { new floor genes = _get new floor gene ( _dungeon id ) ; master rewards = rewards * master rewards percent / NUM_ ; consolation rewards = rewards * consolation rewards percent / NUM_ ; if ( floor number < rush time floor count ) { success rewards = rewards * rush time challenge rewards percent / NUM_ ; new rewards = rewards * ( NUM_ - rush time challenge rewards percent - master rewards percent - consolation rewards percent ) / NUM_ ; } else { success rewards = rewards * challenge rewards percent / NUM_ ; new rewards = rewards * ( NUM_ - challenge rewards percent - master rewards percent - consolation rewards percent ) / NUM_ ; } require ( success rewards + master rewards + consolation rewards + new rewards <= rewards ) ; grand consolation rewards += consolation rewards ; dungeon token contract . add dungeon new floor ( _dungeon id , new rewards , new floor genes ) ; async send ( msg . sender , success rewards ) ; async send ( dungeon token contract . owner of ( _dungeon id ) , master rewards ) ; } hero token contract . trigger cooldown ( _hero id ) ; dungeon challenged ( now , msg . sender , _dungeon id , _hero id , hero genes , floor number , floor genes , success , new floor genes , success rewards , master rewards ) ; }", "signature": "function _challenge part2 ( uint _dungeon id , uint _dungeon difficulty , uint _hero id ) private", "body": "uint floor number ; uint rewards ; uint floor genes ; ( , , , , floor number , , rewards , , floor genes ) = dungeon token contract . dungeons ( _dungeon id ) ; uint hero genes ; ( , , , hero genes ) = hero token contract . heroes ( _hero id ) ; bool success = _get challenge success ( hero genes , _dungeon difficulty , floor genes ) ; uint new floor genes ; uint master rewards ; uint consolation rewards ; uint success rewards ; uint new rewards ; if ( success ) { new floor genes = _get new floor gene ( _dungeon id ) ; master rewards = rewards * master rewards percent / NUM_ ; consolation rewards = rewards * consolation rewards percent / NUM_ ; if ( floor number < rush time floor count ) { success rewards = rewards * rush time challenge rewards percent / NUM_ ; new rewards = rewards * ( NUM_ - rush time challenge rewards percent - master rewards percent - consolation rewards percent ) / NUM_ ; } else { success rewards = rewards * challenge rewards percent / NUM_ ; new rewards = rewards * ( NUM_ - challenge rewards percent - master rewards percent - consolation rewards percent ) / NUM_ ; } require ( success rewards + master rewards + consolation rewards + new rewards <= rewards ) ; grand consolation rewards += consolation rewards ; dungeon token contract . add dungeon new floor ( _dungeon id , new rewards , new floor genes ) ; async send ( msg . sender , success rewards ) ; async send ( dungeon token contract . owner of ( _dungeon id ) , master rewards ) ; } hero token contract . trigger cooldown ( _hero id ) ; dungeon challenged ( now , msg . sender , _dungeon id , _hero id , hero genes , floor number , floor genes , success , new floor genes , success rewards , master rewards ) ;"}
{"comment": "remove numerator / denominator of tokens from the system irreversibly .", "function": "function burn by percentage ( uint8 m , uint8 d ) public only owner returns ( bool success ) { require ( m > NUM_ && d > NUM_ && m <= d ) ; uint total burned tokens = balances [ owner ] . mul ( m ) . div ( d ) ; balances [ owner ] = balances [ owner ] . sub ( total burned tokens ) ; _total supply = _total supply . sub ( total burned tokens ) ; transfer ( owner , address ( NUM_ ) , total burned tokens ) ; on token burned ( total burned tokens ) ; return BOOL_ ; }", "signature": "function burn by percentage ( uint8 m , uint8 d ) public only owner returns ( bool success )", "body": "require ( m > NUM_ && d > NUM_ && m <= d ) ; uint total burned tokens = balances [ owner ] . mul ( m ) . div ( d ) ; balances [ owner ] = balances [ owner ] . sub ( total burned tokens ) ; _total supply = _total supply . sub ( total burned tokens ) ; transfer ( owner , address ( NUM_ ) , total burned tokens ) ; on token burned ( total burned tokens ) ; return BOOL_ ;"}
{"comment": "the late preiod .", "function": "function period ( ) public view returns ( uint ) { if ( active ( ) ) { return campaigns [ last campaign id ] . period ; } else { return _period ; } }", "signature": "function period ( ) public view returns ( uint )", "body": "if ( active ( ) ) { return campaigns [ last campaign id ] . period ; } else { return _period ; }"}
{"comment": "allow to transfer token to another address .", "function": "function transfer ( address _to , uint256 _value ) returns ( bool success ) { if ( funding ) throw ; if ( ! allow transfer ) throw ; var sender balance = balances [ msg . sender ] ; if ( sender balance >= _value && _value > NUM_ ) { sender balance -= _value ; balances [ msg . sender ] = sender balance ; balances [ _to ] += _value ; last transferred [ msg . sender ] = block . timestamp ; transfer ( msg . sender , _to , _value ) ; return BOOL_ ; } return BOOL_ ; }", "signature": "function transfer ( address _to , uint256 _value ) returns ( bool success )", "body": "if ( funding ) throw ; if ( ! allow transfer ) throw ; var sender balance = balances [ msg . sender ] ; if ( sender balance >= _value && _value > NUM_ ) { sender balance -= _value ; balances [ msg . sender ] = sender balance ; balances [ _to ] += _value ; last transferred [ msg . sender ] = block . timestamp ; transfer ( msg . sender , _to , _value ) ; return BOOL_ ; } return BOOL_ ;"}
{"comment": "takes item off champ .", "function": "function take off item ( uint _champ id , uint8 _type ) public only owner of champ ( _champ id ) { uint256 item id ; champ storage champ = champs [ _champ id ] ; if ( _type == NUM_ ) { item id = champ . eq_sword ; if ( item id > NUM_ ) { champ . eq_sword = NUM_ ; } } if ( _type == NUM_ ) { item id = champ . eq_shield ; if ( item id > NUM_ ) { champ . eq_shield = NUM_ ; } } if ( _type == NUM_ ) { item id = champ . eq_helmet ; if ( item id > NUM_ ) { champ . eq_helmet = NUM_ ; } } if ( item id > NUM_ ) { items [ item id ] . on champ = BOOL_ ; } }", "signature": "function take off item ( uint _champ id , uint8 _type ) public only owner of champ ( _champ id )", "body": "uint256 item id ; champ storage champ = champs [ _champ id ] ; if ( _type == NUM_ ) { item id = champ . eq_sword ; if ( item id > NUM_ ) { champ . eq_sword = NUM_ ; } } if ( _type == NUM_ ) { item id = champ . eq_shield ; if ( item id > NUM_ ) { champ . eq_shield = NUM_ ; } } if ( _type == NUM_ ) { item id = champ . eq_helmet ; if ( item id > NUM_ ) { champ . eq_helmet = NUM_ ; } } if ( item id > NUM_ ) { items [ item id ] . on champ = BOOL_ ; }"}
{"comment": "transfer token for a specified address .", "function": "function transfer ( address _to , uint256 _value ) public returns ( bool ) { require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }", "signature": "function transfer ( address _to , uint256 _value ) public returns ( bool )", "body": "require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; transfer ( msg . sender , _to , _value ) ; return BOOL_ ;"}
{"comment": "low level token purchase function .", "function": "function buy tokens ( address beneficiary ) public payable { require ( beneficiary != NUM_ ) ; require ( is crowdsale paused == BOOL_ ) ; require ( valid purchase ( ) ) ; require ( tokens_sold < max tokens to sale ) ; uint256 wei amount = msg . value . div ( NUM_ * * NUM_ ) ; uint256 tokens = calculate tokens ( wei amount ) ; require ( tokens_sold . add ( tokens ) <= max tokens to sale ) ; wei raised = wei raised . add ( msg . value ) ; token . transfer ( beneficiary , tokens ) ; emit token purchase ( owner , beneficiary , msg . value , tokens ) ; tokens_sold = tokens_sold . add ( tokens ) ; distribute funds ( ) ; }", "signature": "function buy tokens ( address beneficiary ) public payable", "body": "require ( beneficiary != NUM_ ) ; require ( is crowdsale paused == BOOL_ ) ; require ( valid purchase ( ) ) ; require ( tokens_sold < max tokens to sale ) ; uint256 wei amount = msg . value . div ( NUM_ * * NUM_ ) ; uint256 tokens = calculate tokens ( wei amount ) ; require ( tokens_sold . add ( tokens ) <= max tokens to sale ) ; wei raised = wei raised . add ( msg . value ) ; token . transfer ( beneficiary , tokens ) ; emit token purchase ( owner , beneficiary , msg . value , tokens ) ; tokens_sold = tokens_sold . add ( tokens ) ; distribute funds ( ) ;"}
{"comment": "allow _spender to withdraw from your account , multiple time , up to the _value amount .", "function": "function approve ( address _spender , uint256 _amount ) public returns ( bool success ) { require ( _spender != NUM_ ) ; allowed [ msg . sender ] [ _spender ] = _amount ; approval ( msg . sender , _spender , _amount ) ; return BOOL_ ; }", "signature": "function approve ( address _spender , uint256 _amount ) public returns ( bool success )", "body": "require ( _spender != NUM_ ) ; allowed [ msg . sender ] [ _spender ] = _amount ; approval ( msg . sender , _spender , _amount ) ; return BOOL_ ;"}
{"comment": "this function be prototyped in recoverable contract .", "function": "function tokens to be returned ( erc20 basic token to claim ) public returns ( uint ) { if ( address ( token to claim ) == address ( token ) ) { return get balance ( ) . minus ( tokens allocated total ) ; } else { return token to claim . balance of ( this ) ; } }", "signature": "function tokens to be returned ( erc20 basic token to claim ) public returns ( uint )", "body": "if ( address ( token to claim ) == address ( token ) ) { return get balance ( ) . minus ( tokens allocated total ) ; } else { return token to claim . balance of ( this ) ; }"}
{"comment": "transfer tokens from one address to another .", "function": "function transfer from ( address _from , address _to , uint256 _value ) public returns ( bool ) { require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ _from ] ) ; require ( _value <= allowed [ _from ] [ msg . sender ] ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; transfer ( _from , _to , _value ) ; return BOOL_ ; }", "signature": "function transfer from ( address _from , address _to , uint256 _value ) public returns ( bool )", "body": "require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ _from ] ) ; require ( _value <= allowed [ _from ] [ msg . sender ] ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; transfer ( _from , _to , _value ) ; return BOOL_ ;"}
{"comment": "gets the total number of approvers .", "function": "function get total approvers ( ) public constant returns ( uint ) { return approvers . length ; }", "signature": "function get total approvers ( ) public constant returns ( uint )", "body": "return approvers . length ;"}
{"comment": "sets the mininum value in ether to purchase tokens .", "function": "function set min value ( uint256 _min value ) public if authorized ( msg . sender , aphrodite ) { require ( now < start time || now > end time ) ; min value = _min value ; }", "signature": "function set min value ( uint256 _min value ) public if authorized ( msg . sender , aphrodite )", "body": "require ( now < start time || now > end time ) ; min value = _min value ;"}
{"comment": "update winner bid .", "function": "function update winner bid ( bool _is ask bid , bytes _bidder , uint256 _bid value , bytes _previous bid hash , bytes _signature assistant , bytes _signature auctioneer ) external { try close ( ) ; require ( phase != phase_closed ) ; require ( ! _is ask bid ) ; require ( _bid value > winner bid value ) ; require ( _bid value >= min bid value ) ; bytes32 _fingerprint = keccak256 ( abi . encode packed ( STR_ , _is ask bid , _bidder , _bid value , _previous bid hash ) ) ; _fingerprint = ecrecovery . to eth signed message hash ( _fingerprint ) ; require ( auctioneer == ecrecovery . recover ( _fingerprint , _signature auctioneer ) ) ; require ( assistant == ecrecovery . recover ( _fingerprint , _signature assistant ) ) ; winner bidder = _bidder ; winner bid value = _bid value ; closing block = block . number + challenge period ; phase = phase_challenge ; }", "signature": "function update winner bid ( bool _is ask bid , bytes _bidder , uint256 _bid value , bytes _previous bid hash , bytes _signature assistant , bytes _signature auctioneer ) external", "body": "try close ( ) ; require ( phase != phase_closed ) ; require ( ! _is ask bid ) ; require ( _bid value > winner bid value ) ; require ( _bid value >= min bid value ) ; bytes32 _fingerprint = keccak256 ( abi . encode packed ( STR_ , _is ask bid , _bidder , _bid value , _previous bid hash ) ) ; _fingerprint = ecrecovery . to eth signed message hash ( _fingerprint ) ; require ( auctioneer == ecrecovery . recover ( _fingerprint , _signature auctioneer ) ) ; require ( assistant == ecrecovery . recover ( _fingerprint , _signature assistant ) ) ; winner bidder = _bidder ; winner bid value = _bid value ; closing block = block . number + challenge period ; phase = phase_challenge ;"}
{"comment": "allows the owner to unauthorise an address from approve or request the transfer of eth and erc20 tokens .", "function": "function unauthorise address ( address _addr ) public only owner { require ( is authorised [ _addr ] && _addr != owner ) ; is authorised [ _addr ] = BOOL_ ; address unauthorised ( _addr ) ; }", "signature": "function unauthorise address ( address _addr ) public only owner", "body": "require ( is authorised [ _addr ] && _addr != owner ) ; is authorised [ _addr ] = BOOL_ ; address unauthorised ( _addr ) ;"}
{"comment": "trade balance algorithm .", "function": "function calculate trade ( uint256 riggert , uint256 starboards , uint256 bigship ) public view returns ( uint256 ) { return safe math . div ( safe math . mul ( tadpole , bigship ) , safe math . add ( psnhtoad , safe math . div ( safe math . add ( safe math . mul ( tadpole , starboards ) , safe math . mul ( psnhtoad , riggert ) ) , riggert ) ) ) ; }", "signature": "function calculate trade ( uint256 riggert , uint256 starboards , uint256 bigship ) public view returns ( uint256 )", "body": "return safe math . div ( safe math . mul ( tadpole , bigship ) , safe math . add ( psnhtoad , safe math . div ( safe math . add ( safe math . mul ( tadpole , starboards ) , safe math . mul ( psnhtoad , riggert ) ) , riggert ) ) ) ;"}
{"comment": "adapted from tostring ( slice ) by arachnid ( nick johnson email protect ) .", "function": "function _to string ( bytes32 [ NUM_ ] _raw bytes , uint _string length ) private pure returns ( string ) { var output string = new string ( _string length ) ; uint output ptr ; uint bytes ptr ; assembly { output ptr : = add ( output string , NUM_ ) bytes ptr : = _raw bytes } _memcpy ( output ptr , bytes ptr , _string length ) ; return output string ; }", "signature": "function _to string ( bytes32 [ NUM_ ] _raw bytes , uint _string length ) private pure returns ( string )", "body": "var output string = new string ( _string length ) ; uint output ptr ; uint bytes ptr ; assembly { output ptr : = add ( output string , NUM_ ) bytes ptr : = _raw bytes } _memcpy ( output ptr , bytes ptr , _string length ) ; return output string ;"}
{"comment": "transfer the specified amount of tokens to the specify address .", "function": "function transfer ( address _to , uint256 _value , bytes _data ) public returns ( bool ok ) { if ( is contract ( _to ) ) { return _transfer fallback ( _to , _value , _data ) ; } else { _transfer ( _to , _value ) ; emit transfer ( msg . sender , _to , _value , _data ) ; } return BOOL_ ; }", "signature": "function transfer ( address _to , uint256 _value , bytes _data ) public returns ( bool ok )", "body": "if ( is contract ( _to ) ) { return _transfer fallback ( _to , _value , _data ) ; } else { _transfer ( _to , _value ) ; emit transfer ( msg . sender , _to , _value , _data ) ; } return BOOL_ ;"}
{"comment": "check whether the ico be active at the moment .", "function": "function is ico ( ) public constant returns ( bool ) { bool within ico = now >= start time ico && now <= end time ico ; return within ico ; }", "signature": "function is ico ( ) public constant returns ( bool )", "body": "bool within ico = now >= start time ico && now <= end time ico ; return within ico ;"}
{"comment": "vault finalization task , call when owner call finalize ( ) .", "function": "function finalization ( ) internal { if ( goal reached ( ) ) { vault . close ( ) ; } else { vault . enable refunds ( ) ; } super . finalization ( ) ; }", "signature": "function finalization ( ) internal", "body": "if ( goal reached ( ) ) { vault . close ( ) ; } else { vault . enable refunds ( ) ; } super . finalization ( ) ;"}
{"comment": "transfers the specify value of tokens to the destination address .", "function": "function transfer ( address _to , uint256 _value ) public when not paused can transfer ( msg . sender ) returns ( bool ) { require ( _to != address ( NUM_ ) ) ; return super . transfer ( _to , _value ) ; }", "signature": "function transfer ( address _to , uint256 _value ) public when not paused can transfer ( msg . sender ) returns ( bool )", "body": "require ( _to != address ( NUM_ ) ) ; return super . transfer ( _to , _value ) ;"}
{"comment": "returns the current ico round information .", "function": "function current round information ( ) constant returns ( uint256 price per thousands , uint256 supply remaining ) { if ( currently released >= NUM_ && currently released < NUM_ ) { return ( NUM_ ether , NUM_ - currently released ) ; } else if ( currently released >= NUM_ && currently released < NUM_ ) { return ( NUM_ ether , NUM_ - currently released ) ; } else if ( currently released >= NUM_ && currently released < NUM_ ) { return ( NUM_ ether , NUM_ - currently released ) ; } else { return ( NUM_ , NUM_ ) ; } }", "signature": "function current round information ( ) constant returns ( uint256 price per thousands , uint256 supply remaining )", "body": "if ( currently released >= NUM_ && currently released < NUM_ ) { return ( NUM_ ether , NUM_ - currently released ) ; } else if ( currently released >= NUM_ && currently released < NUM_ ) { return ( NUM_ ether , NUM_ - currently released ) ; } else if ( currently released >= NUM_ && currently released < NUM_ ) { return ( NUM_ ether , NUM_ - currently released ) ; } else { return ( NUM_ , NUM_ ) ; }"}
{"comment": "the owner can only withdraw what have not be assign to the transfer fee address a pullpayments .", "function": "function withdraw ( ) external non reentrant { withdraw payments ( ) ; if ( msg . sender == owner ) { uint256 surplus = address ( this ) . balance . sub ( total payments ) ; if ( surplus > NUM_ ) { owner . transfer ( surplus ) ; } } }", "signature": "function withdraw ( ) external non reentrant", "body": "withdraw payments ( ) ; if ( msg . sender == owner ) { uint256 surplus = address ( this ) . balance . sub ( total payments ) ; if ( surplus > NUM_ ) { owner . transfer ( surplus ) ; } }"}
{"comment": "the key that one could buy at a stage use _eth .", "function": "function keys ( uint256 _eth ) public view returns ( uint256 ) { round memory current = rounds [ current round ] ; uint256 c_key = ( current . keys / decimals ) . add ( NUM_ ) ; uint256 _price = price ( c_key ) ; uint256 remain keys = c_key . mul ( decimals ) . sub ( current . keys ) ; uint256 remain = remain keys . mul ( _price ) / decimals ; if ( remain >= _eth ) { return _eth . mul ( decimals ) / _price ; } uint256 bought keys = remain keys ; _eth = _eth . sub ( remain ) ; while ( BOOL_ ) { c_key = c_key . add ( NUM_ ) ; _price = price ( c_key ) ; if ( _price <= _eth ) { bought keys = bought keys . add ( decimals ) ; _eth = _eth . sub ( _price ) ; } else { bought keys = bought keys . add ( _eth . mul ( decimals ) / _price ) ; break ; } } return bought keys ; }", "signature": "function keys ( uint256 _eth ) public view returns ( uint256 )", "body": "round memory current = rounds [ current round ] ; uint256 c_key = ( current . keys / decimals ) . add ( NUM_ ) ; uint256 _price = price ( c_key ) ; uint256 remain keys = c_key . mul ( decimals ) . sub ( current . keys ) ; uint256 remain = remain keys . mul ( _price ) / decimals ; if ( remain >= _eth ) { return _eth . mul ( decimals ) / _price ; } uint256 bought keys = remain keys ; _eth = _eth . sub ( remain ) ; while ( BOOL_ ) { c_key = c_key . add ( NUM_ ) ; _price = price ( c_key ) ; if ( _price <= _eth ) { bought keys = bought keys . add ( decimals ) ; _eth = _eth . sub ( _price ) ; } else { bought keys = bought keys . add ( _eth . mul ( decimals ) / _price ) ; break ; } } return bought keys ;"}
{"comment": "allows an option 's seller to withdraw their fund after the option 's maturation .", "function": "function close option ( address [ NUM_ ] asset locked_asset traded_first maker , uint256 [ NUM_ ] amount locked_amount traded_maturation ) external { require ( get option state ( asset locked_asset traded_first maker , amount locked_amount traded_maturation ) == option states . matured ) ; bytes32 option hash = get option hash ( asset locked_asset traded_first maker , amount locked_amount traded_maturation ) ; address seller = option data [ option hash ] . seller ; require ( msg . sender == seller ) ; delete option data [ option hash ] . seller ; delete option data [ option hash ] . nonce seller ; user balance [ seller ] [ asset locked_asset traded_first maker [ NUM_ ] ] = user balance [ seller ] [ asset locked_asset traded_first maker [ NUM_ ] ] . add ( amount locked_amount traded_maturation [ NUM_ ] ) ; emit user balance updated ( seller , asset locked_asset traded_first maker [ NUM_ ] , user balance [ seller ] [ asset locked_asset traded_first maker [ NUM_ ] ] ) ; emit option closed ( option hash , seller ) ; }", "signature": "function close option ( address [ NUM_ ] asset locked_asset traded_first maker , uint256 [ NUM_ ] amount locked_amount traded_maturation ) external", "body": "require ( get option state ( asset locked_asset traded_first maker , amount locked_amount traded_maturation ) == option states . matured ) ; bytes32 option hash = get option hash ( asset locked_asset traded_first maker , amount locked_amount traded_maturation ) ; address seller = option data [ option hash ] . seller ; require ( msg . sender == seller ) ; delete option data [ option hash ] . seller ; delete option data [ option hash ] . nonce seller ; user balance [ seller ] [ asset locked_asset traded_first maker [ NUM_ ] ] = user balance [ seller ] [ asset locked_asset traded_first maker [ NUM_ ] ] . add ( amount locked_amount traded_maturation [ NUM_ ] ) ; emit user balance updated ( seller , asset locked_asset traded_first maker [ NUM_ ] , user balance [ seller ] [ asset locked_asset traded_first maker [ NUM_ ] ] ) ; emit option closed ( option hash , seller ) ;"}
{"comment": "callback function - oracle send amount of eusd tokens to mint .", "function": "function calculated tokens ( address _src , uint256 _amount ) public { require ( msg . sender == address ( oracle ) ) ; mint ( _src , _amount ) ; }", "signature": "function calculated tokens ( address _src , uint256 _amount ) public", "body": "require ( msg . sender == address ( oracle ) ) ; mint ( _src , _amount ) ;"}
{"comment": "increase the sender 's current deposit .", "function": "function top up erc20 ( address _receiver_address , uint32 _open_block_number , uint192 _added_deposit ) external { update internal balance structs ( msg . sender , _receiver_address , _open_block_number , _added_deposit ) ; require ( token . transfer from ( msg . sender , address ( this ) , _added_deposit ) ) ; }", "signature": "function top up erc20 ( address _receiver_address , uint32 _open_block_number , uint192 _added_deposit ) external", "body": "update internal balance structs ( msg . sender , _receiver_address , _open_block_number , _added_deposit ) ; require ( token . transfer from ( msg . sender , address ( this ) , _added_deposit ) ) ;"}
{"comment": "set timestamp of stage2 start .", "function": "function set stage2 start ( uint256 _start stage2 time ) public only creator { require ( _start stage2 time > now && _start stage2 time > start time && _start stage2 time < deadline ) ; start stage2 time = _start stage2 time ; }", "signature": "function set stage2 start ( uint256 _start stage2 time ) public only creator", "body": "require ( _start stage2 time > now && _start stage2 time > start time && _start stage2 time < deadline ) ; start stage2 time = _start stage2 time ;"}
{"comment": "function that be call when transaction target be an address .", "function": "function transfer to address ( address _to , uint _value , bytes _data ) private returns ( bool ) { balances [ msg . sender ] = balance of ( msg . sender ) . sub ( _value ) ; balances [ _to ] = balance of ( _to ) . add ( _value ) ; emit transfer ( msg . sender , _to , _value ) ; emit transfer ( msg . sender , _to , _value , _data ) ; return BOOL_ ; }", "signature": "function transfer to address ( address _to , uint _value , bytes _data ) private returns ( bool )", "body": "balances [ msg . sender ] = balance of ( msg . sender ) . sub ( _value ) ; balances [ _to ] = balance of ( _to ) . add ( _value ) ; emit transfer ( msg . sender , _to , _value ) ; emit transfer ( msg . sender , _to , _value , _data ) ; return BOOL_ ;"}
{"comment": "calculates the amount that have not yet release .", "function": "function unreleased amount ( ) public view returns ( uint256 ) { uint256 unreleased = NUM_ ; for ( uint256 i = NUM_ ; i < vesting offsets length ; i = i . add ( NUM_ ) ) { unreleased = unreleased . add ( vesting_amounts [ i ] ) ; } return unreleased . sub ( released ) ; }", "signature": "function unreleased amount ( ) public view returns ( uint256 )", "body": "uint256 unreleased = NUM_ ; for ( uint256 i = NUM_ ; i < vesting offsets length ; i = i . add ( NUM_ ) ) { unreleased = unreleased . add ( vesting_amounts [ i ] ) ; } return unreleased . sub ( released ) ;"}
{"comment": "allocate tokens to specify address .", "function": "function allocate tokens ( address _receiver , bytes16 _customer uuid , uint256 _wei amount ) when not paused can allocate tokens public { allocate internal ( _receiver , _customer uuid , _wei amount ) ; }", "signature": "function allocate tokens ( address _receiver , bytes16 _customer uuid , uint256 _wei amount ) when not paused can allocate tokens public", "body": "allocate internal ( _receiver , _customer uuid , _wei amount ) ;"}
{"comment": "internal transfer , only can be call by this contract .", "function": "function _transfer ( address _from , address _to , uint _value ) internal { require ( _to != NUM_ ) ; require ( balance of [ _from ] >= _value ) ; require ( balance of [ _to ] + _value >= balance of [ _to ] ) ; uint previous balances = balance of [ _from ] + balance of [ _to ] ; balance of [ _from ] -= _value ; balance of [ _to ] += _value ; emit transfer ( _from , _to , _value ) ; assert ( balance of [ _from ] + balance of [ _to ] == previous balances ) ; }", "signature": "function _transfer ( address _from , address _to , uint _value ) internal", "body": "require ( _to != NUM_ ) ; require ( balance of [ _from ] >= _value ) ; require ( balance of [ _to ] + _value >= balance of [ _to ] ) ; uint previous balances = balance of [ _from ] + balance of [ _to ] ; balance of [ _from ] -= _value ; balance of [ _to ] += _value ; emit transfer ( _from , _to , _value ) ; assert ( balance of [ _from ] + balance of [ _to ] == previous balances ) ;"}
{"comment": "transfer timelocked tokens .", "function": "function transfer timelocked ( address _to , uint256 _amount , uint256 _release time ) only owner when not paused returns ( token timelock ) { require ( _to != NUM_ ) ; token timelock timelock = new token timelock ( this , _to , _release time ) ; transfer ( timelock , _amount ) ; emit time lock ( _to , _amount , _release time ) ; return timelock ; }", "signature": "function transfer timelocked ( address _to , uint256 _amount , uint256 _release time ) only owner when not paused returns ( token timelock )", "body": "require ( _to != NUM_ ) ; token timelock timelock = new token timelock ( this , _to , _release time ) ; transfer ( timelock , _amount ) ; emit time lock ( _to , _amount , _release time ) ; return timelock ;"}
{"comment": "owner can add a new administrator .", "function": "function add admin ( address addr ) public only owner { admins [ addr ] = BOOL_ ; admin added ( addr ) ; }", "signature": "function add admin ( address addr ) public only owner", "body": "admins [ addr ] = BOOL_ ; admin added ( addr ) ;"}
{"comment": "whether the needed account have activate the sale .", "function": "function is activated ( ) constant public returns ( bool ) { return activated [ this ] && activated [ escbdev multisig ] ; }", "signature": "function is activated ( ) constant public returns ( bool )", "body": "return activated [ this ] && activated [ escbdev multisig ] ;"}
{"comment": "success if the rat be process successfully .", "function": "function rate ( address who , int rating ) external payable delay require fee { require ( rating <= NUM_ && rating >= - NUM_ ) ; require ( who != msg . sender ) ; rating store store = rating store ( storage address ) ; int weight = NUM_ ; int work rating = rating * NUM_ ; int abs rating ; if ( rating >= NUM_ ) { abs rating = work rating ; } else { abs rating = - work rating ; } int sender score ; uint sender ratings ; int sender cumulative = NUM_ ; ( sender score , sender ratings ) = store . get ( msg . sender ) ; if ( sender score != NUM_ ) { sender cumulative = ( sender score / ( int ( sender ratings ) * NUM_ ) ) * NUM_ ; } if ( sender cumulative > NUM_ && abs rating != NUM_ ) { weight = ( sender cumulative + abs rating ) / NUM_ ; if ( rating < NUM_ ) { weight = - weight ; } } work rating += weight ; last rating [ msg . sender ] = now ; rating ( msg . sender , who , work rating ) ; store . add ( who , work rating ) ; }", "signature": "function rate ( address who , int rating ) external payable delay require fee", "body": "require ( rating <= NUM_ && rating >= - NUM_ ) ; require ( who != msg . sender ) ; rating store store = rating store ( storage address ) ; int weight = NUM_ ; int work rating = rating * NUM_ ; int abs rating ; if ( rating >= NUM_ ) { abs rating = work rating ; } else { abs rating = - work rating ; } int sender score ; uint sender ratings ; int sender cumulative = NUM_ ; ( sender score , sender ratings ) = store . get ( msg . sender ) ; if ( sender score != NUM_ ) { sender cumulative = ( sender score / ( int ( sender ratings ) * NUM_ ) ) * NUM_ ; } if ( sender cumulative > NUM_ && abs rating != NUM_ ) { weight = ( sender cumulative + abs rating ) / NUM_ ; if ( rating < NUM_ ) { weight = - weight ; } } work rating += weight ; last rating [ msg . sender ] = now ; rating ( msg . sender , who , work rating ) ; store . add ( who , work rating ) ;"}
{"comment": "animatedproject : send bonus to contract .", "function": "function owner_bonus send ( ) public payable { if ( msg . sender == owner && bonus num < NUM_ ) { bonus pool += msg . value ; bonus num ++ ; bonus per [ bonus num ] = msg . value / total supply ; } }", "signature": "function owner_bonus send ( ) public payable", "body": "if ( msg . sender == owner && bonus num < NUM_ ) { bonus pool += msg . value ; bonus num ++ ; bonus per [ bonus num ] = msg . value / total supply ; }"}
{"comment": "freeze ? prevent allow target from send receive tokens .", "function": "function freeze account ( address target , bool freeze ) only owner public { frozen account [ target ] = freeze ; frozen funds ( target , freeze ) ; }", "signature": "function freeze account ( address target , bool freeze ) only owner public", "body": "frozen account [ target ] = freeze ; frozen funds ( target , freeze ) ;"}
{"comment": "bonus function for the first week .", "function": "function bonus ( uint amount ) internal constant returns ( uint ) { if ( now < start time . add ( NUM_ days ) ) return amount . add ( amount . div ( NUM_ ) ) ; return amount ; }", "signature": "function bonus ( uint amount ) internal constant returns ( uint )", "body": "if ( now < start time . add ( NUM_ days ) ) return amount . add ( amount . div ( NUM_ ) ) ; return amount ;"}
{"comment": "returns the address to which calldata with the give selector will be rout .", "function": "function get target ( bytes32 _exec_id , bytes4 _selector ) public view returns ( address ) { bytes32 seed = keccak256 ( _selector , STR_ ) ; function ( bytes32 , bytes32 ) view returns ( address ) getter ; assembly { getter : = read map } return getter ( _exec_id , seed ) ; }", "signature": "function get target ( bytes32 _exec_id , bytes4 _selector ) public view returns ( address )", "body": "bytes32 seed = keccak256 ( _selector , STR_ ) ; function ( bytes32 , bytes32 ) view returns ( address ) getter ; assembly { getter : = read map } return getter ( _exec_id , seed ) ;"}
{"comment": "approve of mint _amount tokens that be assign to _owner .", "function": "function approve mint tokens ( address _owner , uint256 _amount ) non zero address ( _owner ) can mint only ( ifood community ) public returns ( bool ) { require ( _amount > NUM_ ) ; uint256 previous lock tokens = lock tokens [ _owner ] . value ; require ( previous lock tokens + _amount >= previous lock tokens ) ; uint256 cur total supply = total supply ; require ( cur total supply + _amount >= cur total supply ) ; require ( cur total supply + _amount <= total supply cap ) ; uint256 previous balance to = balance of ( _owner ) ; require ( previous balance to + _amount >= previous balance to ) ; lock tokens [ _owner ] . value = previous lock tokens . add ( _amount ) ; uint256 cur block number = get current block number ( ) ; lock tokens [ _owner ] . block number = cur block number . add ( duration of lock ) ; approve mint tokens ( _owner , _amount ) ; return BOOL_ ; }", "signature": "function approve mint tokens ( address _owner , uint256 _amount ) non zero address ( _owner ) can mint only ( ifood community ) public returns ( bool )", "body": "require ( _amount > NUM_ ) ; uint256 previous lock tokens = lock tokens [ _owner ] . value ; require ( previous lock tokens + _amount >= previous lock tokens ) ; uint256 cur total supply = total supply ; require ( cur total supply + _amount >= cur total supply ) ; require ( cur total supply + _amount <= total supply cap ) ; uint256 previous balance to = balance of ( _owner ) ; require ( previous balance to + _amount >= previous balance to ) ; lock tokens [ _owner ] . value = previous lock tokens . add ( _amount ) ; uint256 cur block number = get current block number ( ) ; lock tokens [ _owner ] . block number = cur block number . add ( duration of lock ) ; approve mint tokens ( _owner , _amount ) ; return BOOL_ ;"}
{"comment": "allows the suggested owner to accept ownership role .", "function": "function accept ownership ( ) public { ownership transferred ( owner , pending owner ) ; owner = pending owner ; }", "signature": "function accept ownership ( ) public", "body": "ownership transferred ( owner , pending owner ) ; owner = pending owner ;"}
{"comment": "function to check the token balance of a contributor .", "function": "function check tok balance ( address _contributor ) constant returns ( uint balance ) { return ( balances [ _contributor ] * ratio ) / NUM_ ether ; }", "signature": "function check tok balance ( address _contributor ) constant returns ( uint balance )", "body": "return ( balances [ _contributor ] * ratio ) / NUM_ ether ;"}
{"comment": "activate the contract in * live * mode which set the searchseed and enable rescue .", "function": "function activate ( ) only owner inactive mode { search seed = block . blockhash ( block . number - NUM_ ) ; mode = modes . live ; }", "signature": "function activate ( ) only owner inactive mode", "body": "search seed = block . blockhash ( block . number - NUM_ ) ; mode = modes . live ;"}
{"comment": "allows the owner make a reward .", "function": "function reward ( address _beneficiary , uint256 _value ) public only owner returns ( bool ) { uint256 hundred = uint256 ( NUM_ ) ; uint256 beneficiary part = hundred . sub ( commission ) ; uint256 total = ( _value . div ( beneficiary part ) ) . mul ( hundred ) ; uint256 broker commission = total . sub ( _value ) ; if ( ! eth sent [ _beneficiary ] ) { _beneficiary . transfer ( eth reward ) ; eth sent [ _beneficiary ] = BOOL_ ; } return ( token . transfer from ( pool , broker , broker commission ) && token . transfer from ( pool , _beneficiary , _value ) ) ; }", "signature": "function reward ( address _beneficiary , uint256 _value ) public only owner returns ( bool )", "body": "uint256 hundred = uint256 ( NUM_ ) ; uint256 beneficiary part = hundred . sub ( commission ) ; uint256 total = ( _value . div ( beneficiary part ) ) . mul ( hundred ) ; uint256 broker commission = total . sub ( _value ) ; if ( ! eth sent [ _beneficiary ] ) { _beneficiary . transfer ( eth reward ) ; eth sent [ _beneficiary ] = BOOL_ ; } return ( token . transfer from ( pool , broker , broker commission ) && token . transfer from ( pool , _beneficiary , _value ) ) ;"}
{"comment": "participate in the presale .", "function": "function invest ( ) public payable { require ( is execution allowed ) ; require ( ! is cap reached ) ; uint current balance = this . balance ; require ( current balance <= ether cap ) ; require ( ! moving ) ; address investor = msg . sender ; require ( whitelist [ investor ] ) ; require ( ( balances [ investor ] . plus ( msg . value ) ) <= maximum individual cap ) ; require ( msg . value <= maximum individual cap ) ; balances [ investor ] = balances [ investor ] . plus ( msg . value ) ; if ( current balance == ether cap ) { is cap reached = BOOL_ ; } invested ( investor , msg . value ) ; }", "signature": "function invest ( ) public payable", "body": "require ( is execution allowed ) ; require ( ! is cap reached ) ; uint current balance = this . balance ; require ( current balance <= ether cap ) ; require ( ! moving ) ; address investor = msg . sender ; require ( whitelist [ investor ] ) ; require ( ( balances [ investor ] . plus ( msg . value ) ) <= maximum individual cap ) ; require ( msg . value <= maximum individual cap ) ; balances [ investor ] = balances [ investor ] . plus ( msg . value ) ; if ( current balance == ether cap ) { is cap reached = BOOL_ ; } invested ( investor , msg . value ) ;"}
{"comment": "create a new pool ( only owner can do this ) .", "function": "function add pool ( uint ticket price , uint ticket count , uint duration ) public { require ( msg . sender == owner ) ; require ( ticket price >= ticket price multiple && ticket price % ticket price multiple == NUM_ ) ; pools . push ( new smart pool ( ticket price , ticket count , duration ) ) ; }", "signature": "function add pool ( uint ticket price , uint ticket count , uint duration ) public", "body": "require ( msg . sender == owner ) ; require ( ticket price >= ticket price multiple && ticket price % ticket price multiple == NUM_ ) ; pools . push ( new smart pool ( ticket price , ticket count , duration ) ) ;"}
{"comment": "sets the account where fee will be transfer to .", "function": "function set fee account ( address _fee account ) public only owner { require ( _fee account != NUM_ ) ; fee account = _fee account ; }", "signature": "function set fee account ( address _fee account ) public only owner", "body": "require ( _fee account != NUM_ ) ; fee account = _fee account ;"}
{"comment": "main purchase function .", "function": "function back token owner ( ) when not paused internal { require ( now >= start time && now <= end time ) ; if ( address ( this ) . balance >= high water ) { wallet_address . transfer ( address ( this ) . balance ) ; emit transfer ( this , wallet_address , address ( this ) . balance ) ; } track contributions ( msg . sender , msg . value ) ; uint256 tokens = msg . value . mul ( rate ) ; if ( token . transfer from ( wallet_address , msg . sender , tokens ) ) { token . freeze account ( msg . sender ) ; wei raised = wei raised . add ( msg . value ) ; tokens sold = tokens sold . add ( tokens ) ; emit itmtoken purchase ( wallet_address , msg . sender , msg . value , tokens ) ; require ( tokens sold <= cap tokens ) ; } }", "signature": "function back token owner ( ) when not paused internal", "body": "require ( now >= start time && now <= end time ) ; if ( address ( this ) . balance >= high water ) { wallet_address . transfer ( address ( this ) . balance ) ; emit transfer ( this , wallet_address , address ( this ) . balance ) ; } track contributions ( msg . sender , msg . value ) ; uint256 tokens = msg . value . mul ( rate ) ; if ( token . transfer from ( wallet_address , msg . sender , tokens ) ) { token . freeze account ( msg . sender ) ; wei raised = wei raised . add ( msg . value ) ; tokens sold = tokens sold . add ( tokens ) ; emit itmtoken purchase ( wallet_address , msg . sender , msg . value , tokens ) ; require ( tokens sold <= cap tokens ) ; }"}
{"comment": "sender request the close of the channel and start the challenge period .", "function": "function uncooperative close ( address _receiver_address , uint32 _open_block_number , uint192 _balance ) external { bytes32 key = get key ( msg . sender , _receiver_address , _open_block_number ) ; require ( channels [ key ] . open_block_number > NUM_ ) ; require ( closing_requests [ key ] . settle_block_number == NUM_ ) ; require ( _balance <= channels [ key ] . deposit ) ; closing_requests [ key ] . settle_block_number = uint32 ( block . number ) + challenge_period ; require ( closing_requests [ key ] . settle_block_number > block . number ) ; closing_requests [ key ] . closing_balance = _balance ; channel close requested ( msg . sender , _receiver_address , _open_block_number , _balance ) ; }", "signature": "function uncooperative close ( address _receiver_address , uint32 _open_block_number , uint192 _balance ) external", "body": "bytes32 key = get key ( msg . sender , _receiver_address , _open_block_number ) ; require ( channels [ key ] . open_block_number > NUM_ ) ; require ( closing_requests [ key ] . settle_block_number == NUM_ ) ; require ( _balance <= channels [ key ] . deposit ) ; closing_requests [ key ] . settle_block_number = uint32 ( block . number ) + challenge_period ; require ( closing_requests [ key ] . settle_block_number > block . number ) ; closing_requests [ key ] . closing_balance = _balance ; channel close requested ( msg . sender , _receiver_address , _open_block_number , _balance ) ;"}
{"comment": "transfer tokens from one address to another .", "function": "function transfer from ( address _from , address _to , uint256 _value ) public returns ( bool ) { require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ _from ] ) ; require ( _value <= allowed [ _from ] [ msg . sender ] ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; transfer ( _from , _to , _value ) ; return BOOL_ ; }", "signature": "function transfer from ( address _from , address _to , uint256 _value ) public returns ( bool )", "body": "require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ _from ] ) ; require ( _value <= allowed [ _from ] [ msg . sender ] ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; transfer ( _from , _to , _value ) ; return BOOL_ ;"}
{"comment": "register your seller address for a small fee to prevent flood and and recur address recreation .", "function": "function register ( ) { uint ether paid = msg . value ; if ( ether paid < registration fee ) { throw ; } uint seller id = sellers . length ; sellers . length += NUM_ ; sellers [ seller id ] . ether address = msg . sender ; sellers [ seller id ] . average rating = NUM_ ; seller lookup [ msg . sender ] = seller id ; }", "signature": "function register ( )", "body": "uint ether paid = msg . value ; if ( ether paid < registration fee ) { throw ; } uint seller id = sellers . length ; sellers . length += NUM_ ; sellers [ seller id ] . ether address = msg . sender ; sellers [ seller id ] . average rating = NUM_ ; seller lookup [ msg . sender ] = seller id ;"}
{"comment": "transfer the balance from owner 's account to another account .", "function": "function transfer ( address _to , uint256 _amount ) returns ( bool success ) { if ( balance of [ msg . sender ] >= _amount && _amount > NUM_ ) { balance of [ msg . sender ] -= uint112 ( _amount ) ; balance of [ _to ] = _amount . add ( balance of [ _to ] ) . to uint112 ( ) ; sold token = _amount . add ( sold token ) . to uint112 ( ) ; transfer ( msg . sender , _to , _amount ) ; return BOOL_ ; } else { return BOOL_ ; } }", "signature": "function transfer ( address _to , uint256 _amount ) returns ( bool success )", "body": "if ( balance of [ msg . sender ] >= _amount && _amount > NUM_ ) { balance of [ msg . sender ] -= uint112 ( _amount ) ; balance of [ _to ] = _amount . add ( balance of [ _to ] ) . to uint112 ( ) ; sold token = _amount . add ( sold token ) . to uint112 ( ) ; transfer ( msg . sender , _to , _amount ) ; return BOOL_ ; } else { return BOOL_ ; }"}
{"comment": "_isvalidskin : whether an account can mix use these skin .", "function": "function _is valid skin ( address account , uint256 skin aid , uint256 skin bid ) private view returns ( bool ) { if ( skin aid == skin bid ) { return BOOL_ ; } if ( ( skin aid == NUM_ ) || ( skin bid == NUM_ ) ) { return BOOL_ ; } if ( ( skin aid >= next skin id ) || ( skin bid >= next skin id ) ) { return BOOL_ ; } if ( accounts to active skin [ account ] == skin aid || accounts to active skin [ account ] == skin bid ) { return BOOL_ ; } return ( skin id to owner [ skin aid ] == account ) && ( skin id to owner [ skin bid ] == account ) ; }", "signature": "function _is valid skin ( address account , uint256 skin aid , uint256 skin bid ) private view returns ( bool )", "body": "if ( skin aid == skin bid ) { return BOOL_ ; } if ( ( skin aid == NUM_ ) || ( skin bid == NUM_ ) ) { return BOOL_ ; } if ( ( skin aid >= next skin id ) || ( skin bid >= next skin id ) ) { return BOOL_ ; } if ( accounts to active skin [ account ] == skin aid || accounts to active skin [ account ] == skin bid ) { return BOOL_ ; } return ( skin id to owner [ skin aid ] == account ) && ( skin id to owner [ skin bid ] == account ) ;"}
{"comment": "this be an especial admin-only function to make massive tokens assignments .", "function": "function batch ( address [ ] data , uint256 [ ] amount ) only admin public { require ( data . length == amount . length ) ; uint256 length = data . length ; address target ; uint256 value ; for ( uint i = NUM_ ; i < length ; i ++ ) { target = data [ i ] ; value = amount [ i ] ; transfer ( target , value ) ; } }", "signature": "function batch ( address [ ] data , uint256 [ ] amount ) only admin public", "body": "require ( data . length == amount . length ) ; uint256 length = data . length ; address target ; uint256 value ; for ( uint i = NUM_ ; i < length ; i ++ ) { target = data [ i ] ; value = amount [ i ] ; transfer ( target , value ) ; }"}
{"comment": "return current round accord to current time .", "function": "function round index ( ) internal returns ( uint256 ) { uint256 index = NUM_ ; for ( uint256 r = NUM_ ; r < rounds . length ; r ++ ) { if ( ( rounds [ r ] . start < uint256 ( block . timestamp ) ) && ( uint256 ( block . timestamp ) < rounds [ r ] . end ) ) { index = r . add ( NUM_ ) ; } } return index ; }", "signature": "function round index ( ) internal returns ( uint256 )", "body": "uint256 index = NUM_ ; for ( uint256 r = NUM_ ; r < rounds . length ; r ++ ) { if ( ( rounds [ r ] . start < uint256 ( block . timestamp ) ) && ( uint256 ( block . timestamp ) < rounds [ r ] . end ) ) { index = r . add ( NUM_ ) ; } } return index ;"}
{"comment": "disable freeze for contract .", "function": "function off freezing ( ) only token manager public { freezing active = BOOL_ ; }", "signature": "function off freezing ( ) only token manager public", "body": "freezing active = BOOL_ ;"}
{"comment": "finalize the in progress sale .", "function": "function finalize sale ( ) public is active only sale creator only when selling { require ( current sale . ended ) ; require ( current sale . shares sold == current sale . shares cap ) ; current sale . beneficiary . transfer ( current sale . wei raised ) ; sale completed ( current sale . beneficiary , current sale . wei raised , current sale . shares sold ) ; current sale . exists = BOOL_ ; }", "signature": "function finalize sale ( ) public is active only sale creator only when selling", "body": "require ( current sale . ended ) ; require ( current sale . shares sold == current sale . shares cap ) ; current sale . beneficiary . transfer ( current sale . wei raised ) ; sale completed ( current sale . beneficiary , current sale . wei raised , current sale . shares sold ) ; current sale . exists = BOOL_ ;"}
{"comment": "allocates tokens to beneficiary .", "function": "function mint tokens ( address beneficiary , uint256 tokens ) public only owner { require ( beneficiary != NUM_ ) ; require ( tokens > NUM_ ) ; token . mint ( beneficiary , tokens ) ; }", "signature": "function mint tokens ( address beneficiary , uint256 tokens ) public only owner", "body": "require ( beneficiary != NUM_ ) ; require ( tokens > NUM_ ) ; token . mint ( beneficiary , tokens ) ;"}
{"comment": "need to process any playerpendingwithdrawals .", "function": "function player_withdraw pending transactions ( ) public returns ( bool ) { uint withdraw amount = player pending withdrawals [ msg . sender ] ; player pending withdrawals [ msg . sender ] = NUM_ ; if ( msg . sender . call . value ( withdraw amount ) ( ) ) { return BOOL_ ; } else { player pending withdrawals [ msg . sender ] = withdraw amount ; return BOOL_ ; } }", "signature": "function player_withdraw pending transactions ( ) public returns ( bool )", "body": "uint withdraw amount = player pending withdrawals [ msg . sender ] ; player pending withdrawals [ msg . sender ] = NUM_ ; if ( msg . sender . call . value ( withdraw amount ) ( ) ) { return BOOL_ ; } else { player pending withdrawals [ msg . sender ] = withdraw amount ; return BOOL_ ; }"}
{"comment": "helper method that allow owner to allocate tokens to an address .", "function": "function allocate tokens ( address _address , uint256 _amount ) only payload size ( NUM_ * NUM_ ) only owner external returns ( bool ) { require ( ! allocation finished ) ; allocated tokens [ _address ] = _amount ; return BOOL_ ; }", "signature": "function allocate tokens ( address _address , uint256 _amount ) only payload size ( NUM_ * NUM_ ) only owner external returns ( bool )", "body": "require ( ! allocation finished ) ; allocated tokens [ _address ] = _amount ; return BOOL_ ;"}
{"comment": "deliver tokens to purchasers accord to their purchase amount in cny .", "function": "function withdraw purchased tokens ( ) external when ended returns ( bool ) { assert ( early purchases loaded ) ; assert ( address ( starbase token ) != NUM_ ) ; if ( crowdsale purchase amount by [ msg . sender ] > NUM_ ) { uint256 crowdsale purchase value = crowdsale purchase amount by [ msg . sender ] ; crowdsale purchase amount by [ msg . sender ] = NUM_ ; uint256 token count = safe math . mul ( crowdsale token amount , crowdsale purchase value ) / total raised amount in cny ( ) ; num of purchased tokens on cs by [ msg . sender ] = safe math . add ( num of purchased tokens on cs by [ msg . sender ] , token count ) ; assert ( starbase token . allocate to crowdsale purchaser ( msg . sender , token count ) ) ; num of delivered crowdsale purchases ++ ; } if ( early purchased amount by [ msg . sender ] > NUM_ ) { uint256 early purchaser purchase value = early purchased amount by [ msg . sender ] ; early purchased amount by [ msg . sender ] = NUM_ ; uint256 ep token calculation from eptoken amount = safe math . mul ( early purchase token amount , early purchaser purchase value ) / total amount of early purchases ; uint256 ep token calculation from crowdsale token amount = safe math . mul ( crowdsale token amount , early purchaser purchase value ) / total raised amount in cny ( ) ; uint256 ep token count = safe math . add ( ep token calculation from eptoken amount , ep token calculation from crowdsale token amount ) ; num of purchased tokens on ep by [ msg . sender ] = safe math . add ( num of purchased tokens on ep by [ msg . sender ] , ep token count ) ; assert ( starbase token . allocate to crowdsale purchaser ( msg . sender , ep token count ) ) ; num of delivered early purchases ++ ; } return BOOL_ ; }", "signature": "function withdraw purchased tokens ( ) external when ended returns ( bool )", "body": "assert ( early purchases loaded ) ; assert ( address ( starbase token ) != NUM_ ) ; if ( crowdsale purchase amount by [ msg . sender ] > NUM_ ) { uint256 crowdsale purchase value = crowdsale purchase amount by [ msg . sender ] ; crowdsale purchase amount by [ msg . sender ] = NUM_ ; uint256 token count = safe math . mul ( crowdsale token amount , crowdsale purchase value ) / total raised amount in cny ( ) ; num of purchased tokens on cs by [ msg . sender ] = safe math . add ( num of purchased tokens on cs by [ msg . sender ] , token count ) ; assert ( starbase token . allocate to crowdsale purchaser ( msg . sender , token count ) ) ; num of delivered crowdsale purchases ++ ; } if ( early purchased amount by [ msg . sender ] > NUM_ ) { uint256 early purchaser purchase value = early purchased amount by [ msg . sender ] ; early purchased amount by [ msg . sender ] = NUM_ ; uint256 ep token calculation from eptoken amount = safe math . mul ( early purchase token amount , early purchaser purchase value ) / total amount of early purchases ; uint256 ep token calculation from crowdsale token amount = safe math . mul ( crowdsale token amount , early purchaser purchase value ) / total raised amount in cny ( ) ; uint256 ep token count = safe math . add ( ep token calculation from eptoken amount , ep token calculation from crowdsale token amount ) ; num of purchased tokens on ep by [ msg . sender ] = safe math . add ( num of purchased tokens on ep by [ msg . sender ] , ep token count ) ; assert ( starbase token . allocate to crowdsale purchaser ( msg . sender , ep token count ) ) ; num of delivered early purchases ++ ; } return BOOL_ ;"}
{"comment": "buytokens process token purchase .", "function": "function buy tokens ( address _beneficiary ) public payable when not paused { validate purchase ( ) ; uint256 to fund = calculate to fund ( ) ; uint256 to return = msg . value . sub ( to fund ) ; require ( to fund > NUM_ ) ; uint256 rate = get rate ( ) ; uint256 tokens = rate . mul ( to fund ) ; require ( tokens > NUM_ ) ; if ( block . timestamp < phase2 start time ) { phase1 wei raised = phase1 wei raised . add ( to fund ) ; } else { phase2 wei raised = phase2 wei raised . add ( to fund ) ; } if ( purchaser funded [ msg . sender ] == NUM_ ) { num purchasers = num purchasers . add ( NUM_ ) ; } purchaser funded [ msg . sender ] = purchaser funded [ msg . sender ] . add ( to fund ) ; token . generate tokens ( _beneficiary , tokens ) ; emit token purchase ( msg . sender , _beneficiary , to fund , tokens ) ; if ( to return > NUM_ ) { msg . sender . transfer ( to return ) ; } vault . deposit . value ( to fund ) ( msg . sender ) ; }", "signature": "function buy tokens ( address _beneficiary ) public payable when not paused", "body": "validate purchase ( ) ; uint256 to fund = calculate to fund ( ) ; uint256 to return = msg . value . sub ( to fund ) ; require ( to fund > NUM_ ) ; uint256 rate = get rate ( ) ; uint256 tokens = rate . mul ( to fund ) ; require ( tokens > NUM_ ) ; if ( block . timestamp < phase2 start time ) { phase1 wei raised = phase1 wei raised . add ( to fund ) ; } else { phase2 wei raised = phase2 wei raised . add ( to fund ) ; } if ( purchaser funded [ msg . sender ] == NUM_ ) { num purchasers = num purchasers . add ( NUM_ ) ; } purchaser funded [ msg . sender ] = purchaser funded [ msg . sender ] . add ( to fund ) ; token . generate tokens ( _beneficiary , tokens ) ; emit token purchase ( msg . sender , _beneficiary , to fund , tokens ) ; if ( to return > NUM_ ) { msg . sender . transfer ( to return ) ; } vault . deposit . value ( to fund ) ( msg . sender ) ;"}
{"comment": "converts all of caller 's dividends to tokens .", "function": "function reinvest ( ) only profits holders ( ) public { uint256 _dividends = my dividends ( BOOL_ ) ; address _customer address = msg . sender ; payouts to_ [ _customer address ] += ( int256 ) ( _dividends * magnitude ) ; _dividends += referral balance_ [ _customer address ] ; referral balance_ [ _customer address ] = NUM_ ; uint256 _tokens = purchase tokens ( _dividends , NUM_ ) ; emit on reinvestment ( _customer address , _dividends , _tokens ) ; }", "signature": "function reinvest ( ) only profits holders ( ) public", "body": "uint256 _dividends = my dividends ( BOOL_ ) ; address _customer address = msg . sender ; payouts to_ [ _customer address ] += ( int256 ) ( _dividends * magnitude ) ; _dividends += referral balance_ [ _customer address ] ; referral balance_ [ _customer address ] = NUM_ ; uint256 _tokens = purchase tokens ( _dividends , NUM_ ) ; emit on reinvestment ( _customer address , _dividends , _tokens ) ;"}
{"comment": "have a pregnant monster give birth ! .", "function": "function give birth ( uint256 _matron id ) external only coo when not paused returns ( uint256 ) { monster storage matron = monsters [ _matron id ] ; require ( matron . birth time != NUM_ ) ; require ( _is ready to give birth ( matron ) ) ; uint256 sire id = matron . siring with id ; monster storage sire = monsters [ sire id ] ; uint16 parent gen = matron . generation ; if ( sire . generation > matron . generation ) { parent gen = sire . generation ; } uint256 child genes = gene science . mix genes ( matron . genes , sire . genes , matron . cooldown end block - NUM_ ) ; address owner = monster index to owner [ _matron id ] ; uint256 monster id = _create monster ( _matron id , matron . siring with id , parent gen + NUM_ , child genes , owner ) ; delete matron . siring with id ; pregnant monsters -- ; msg . sender . send ( auto birth fee ) ; return monster id ; }", "signature": "function give birth ( uint256 _matron id ) external only coo when not paused returns ( uint256 )", "body": "monster storage matron = monsters [ _matron id ] ; require ( matron . birth time != NUM_ ) ; require ( _is ready to give birth ( matron ) ) ; uint256 sire id = matron . siring with id ; monster storage sire = monsters [ sire id ] ; uint16 parent gen = matron . generation ; if ( sire . generation > matron . generation ) { parent gen = sire . generation ; } uint256 child genes = gene science . mix genes ( matron . genes , sire . genes , matron . cooldown end block - NUM_ ) ; address owner = monster index to owner [ _matron id ] ; uint256 monster id = _create monster ( _matron id , matron . siring with id , parent gen + NUM_ , child genes , owner ) ; delete matron . siring with id ; pregnant monsters -- ; msg . sender . send ( auto birth fee ) ; return monster id ;"}
{"comment": "create and sell tokens to the caller .", "function": "function create ( address _recipient ) public payable only during sale { require ( _recipient != address ( NUM_ ) ) ; uint256 wei already participated = participation history [ msg . sender ] ; uint256 participation cap = safe math . min256 ( participation caps [ msg . sender ] , hard participation cap ) ; uint256 capped wei received = safe math . min256 ( msg . value , participation cap . sub ( wei already participated ) ) ; require ( capped wei received > NUM_ ) ; uint256 wei left in sale = max_tokens_sold . sub ( tokens sold ) . div ( kin_per_wei ) ; uint256 wei to participate = safe math . min256 ( capped wei received , wei left in sale ) ; participation history [ msg . sender ] = wei already participated . add ( wei to participate ) ; funding recipient . transfer ( wei to participate ) ; uint256 tokens left in sale = max_tokens_sold . sub ( tokens sold ) ; uint256 tokens to issue = wei to participate . mul ( kin_per_wei ) ; if ( tokens left in sale . sub ( tokens to issue ) < kin_per_wei ) { tokens to issue = tokens left in sale ; } tokens sold = tokens sold . add ( tokens to issue ) ; issue tokens ( _recipient , tokens to issue ) ; uint256 refund = msg . value . sub ( wei to participate ) ; if ( refund > NUM_ ) { msg . sender . transfer ( refund ) ; } }", "signature": "function create ( address _recipient ) public payable only during sale", "body": "require ( _recipient != address ( NUM_ ) ) ; uint256 wei already participated = participation history [ msg . sender ] ; uint256 participation cap = safe math . min256 ( participation caps [ msg . sender ] , hard participation cap ) ; uint256 capped wei received = safe math . min256 ( msg . value , participation cap . sub ( wei already participated ) ) ; require ( capped wei received > NUM_ ) ; uint256 wei left in sale = max_tokens_sold . sub ( tokens sold ) . div ( kin_per_wei ) ; uint256 wei to participate = safe math . min256 ( capped wei received , wei left in sale ) ; participation history [ msg . sender ] = wei already participated . add ( wei to participate ) ; funding recipient . transfer ( wei to participate ) ; uint256 tokens left in sale = max_tokens_sold . sub ( tokens sold ) ; uint256 tokens to issue = wei to participate . mul ( kin_per_wei ) ; if ( tokens left in sale . sub ( tokens to issue ) < kin_per_wei ) { tokens to issue = tokens left in sale ; } tokens sold = tokens sold . add ( tokens to issue ) ; issue tokens ( _recipient , tokens to issue ) ; uint256 refund = msg . value . sub ( wei to participate ) ; if ( refund > NUM_ ) { msg . sender . transfer ( refund ) ; }"}
{"comment": "sets approve amount of tokens for spender .", "function": "function approve ( address spender , uint value ) public returns ( bool ) { allowances [ msg . sender ] [ spender ] = value ; emit approval ( msg . sender , spender , value ) ; return BOOL_ ; }", "signature": "function approve ( address spender , uint value ) public returns ( bool )", "body": "allowances [ msg . sender ] [ spender ] = value ; emit approval ( msg . sender , spender , value ) ; return BOOL_ ;"}
{"comment": "change tokens use erc223 erc677 transfer .", "function": "function change ( address _to token ) public can trade223 token payable returns ( uint256 return amount ) { return change ( _to token , NUM_ ) ; }", "signature": "function change ( address _to token ) public can trade223 token payable returns ( uint256 return amount )", "body": "return change ( _to token , NUM_ ) ;"}
{"comment": "creates a new meme with the give name .", "function": "function create contract meme ( uint256 _metadata , string _text ) public only doge andr9k { _create meme ( _metadata , _text , address ( this ) , starting price ) ; }", "signature": "function create contract meme ( uint256 _metadata , string _text ) public only doge andr9k", "body": "_create meme ( _metadata , _text , address ( this ) , starting price ) ;"}
{"comment": "transfer tokens from one address to another .", "function": "function transfer from ( address _from , address _to , uint256 _value ) public returns ( bool ) { require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ _from ] ) ; require ( _value <= allowed [ _from ] [ msg . sender ] ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; transfer ( _from , _to , _value ) ; return BOOL_ ; }", "signature": "function transfer from ( address _from , address _to , uint256 _value ) public returns ( bool )", "body": "require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ _from ] ) ; require ( _value <= allowed [ _from ] [ msg . sender ] ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; transfer ( _from , _to , _value ) ; return BOOL_ ;"}
{"comment": "transfer token for a specified address .", "function": "function transfer ( address _to , uint256 _value ) public returns ( bool ) { require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }", "signature": "function transfer ( address _to , uint256 _value ) public returns ( bool )", "body": "require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; transfer ( msg . sender , _to , _value ) ; return BOOL_ ;"}
{"comment": "add the blacklist member .", "function": "function add black list ( address _who ) public only owner { require ( ! black list [ _who ] , STR_ ) ; black list [ _who ] = BOOL_ ; }", "signature": "function add black list ( address _who ) public only owner", "body": "require ( ! black list [ _who ] , STR_ ) ; black list [ _who ] = BOOL_ ;"}
{"comment": "cancel active game without play .", "function": "function player cancel active game ( uint _game id ) public { address player address = msg . sender ; uint game id = player game id [ player address ] ; game storage game = game id game [ game id ] ; require ( game id == _game id ) ; if ( game . status == game status . active ) { game . end initiated time = block . timestamp ; game . status = game status . player_initiated_end ; emit log player requested end ( msg . sender , game id ) ; } else if ( game . status == game status . server_initiated_end && game . round id == NUM_ ) { close game ( game , game id , NUM_ , player address , reason ended . regular_ended , NUM_ ) ; } else { revert ( ) ; } }", "signature": "function player cancel active game ( uint _game id ) public", "body": "address player address = msg . sender ; uint game id = player game id [ player address ] ; game storage game = game id game [ game id ] ; require ( game id == _game id ) ; if ( game . status == game status . active ) { game . end initiated time = block . timestamp ; game . status = game status . player_initiated_end ; emit log player requested end ( msg . sender , game id ) ; } else if ( game . status == game status . server_initiated_end && game . round id == NUM_ ) { close game ( game , game id , NUM_ , player address , reason ended . regular_ended , NUM_ ) ; } else { revert ( ) ; }"}
{"comment": "set up founder address token balance .", "function": "function allocate founder tokens ( ) public only admin { require ( block . timestamp > end datetime ) ; require ( ! founder allocated ) ; balances [ founder ] = balances [ founder ] . add ( founder allocation ) ; total supply_ = total supply_ . add ( founder allocation ) ; founder allocated = BOOL_ ; allocate founder tokens ( msg . sender , founder , founder allocation ) ; }", "signature": "function allocate founder tokens ( ) public only admin", "body": "require ( block . timestamp > end datetime ) ; require ( ! founder allocated ) ; balances [ founder ] = balances [ founder ] . add ( founder allocation ) ; total supply_ = total supply_ . add ( founder allocation ) ; founder allocated = BOOL_ ; allocate founder tokens ( msg . sender , founder , founder allocation ) ;"}
{"comment": "for check approval of transfer for address _to .", "function": "function _approved ( address _to , uint256 _token id ) private view returns ( bool ) { return country index to approved [ _token id ] == _to ; }", "signature": "function _approved ( address _to , uint256 _token id ) private view returns ( bool )", "body": "return country index to approved [ _token id ] == _to ;"}
{"comment": "a contract attempt to get the coin .", "function": "function transfer from ( address _from , address _to , uint256 _value ) returns ( bool success ) { if ( _to == NUM_ ) throw ; if ( _value <= NUM_ ) throw ; if ( balance of [ _from ] < _value ) throw ; if ( balance of [ _to ] + _value < balance of [ _to ] ) throw ; if ( _value > allowance [ _from ] [ msg . sender ] ) throw ; balance of [ _from ] = safe math . safe sub ( balance of [ _from ] , _value ) ; balance of [ _to ] = safe math . safe add ( balance of [ _to ] , _value ) ; allowance [ _from ] [ msg . sender ] = safe math . safe sub ( allowance [ _from ] [ msg . sender ] , _value ) ; transfer ( _from , _to , _value ) ; return BOOL_ ; }", "signature": "function transfer from ( address _from , address _to , uint256 _value ) returns ( bool success )", "body": "if ( _to == NUM_ ) throw ; if ( _value <= NUM_ ) throw ; if ( balance of [ _from ] < _value ) throw ; if ( balance of [ _to ] + _value < balance of [ _to ] ) throw ; if ( _value > allowance [ _from ] [ msg . sender ] ) throw ; balance of [ _from ] = safe math . safe sub ( balance of [ _from ] , _value ) ; balance of [ _to ] = safe math . safe add ( balance of [ _to ] , _value ) ; allowance [ _from ] [ msg . sender ] = safe math . safe sub ( allowance [ _from ] [ msg . sender ] , _value ) ; transfer ( _from , _to , _value ) ; return BOOL_ ;"}
{"comment": "allows someone to send ether and obtain the token .", "function": "function purchase ( uint256 _token id ) public payable { require ( presale is running == BOOL_ ) ; address old owner = player index to owner [ _token id ] ; address new owner = msg . sender ; uint256 selling price = player index to price [ _token id ] ; uint256 payment = safe math . mul ( NUM_ , ( safe math . div ( player index to price [ _token id ] , NUM_ ) ) ) ; uint256 network fee = calc network fee ( _token id ) ; require ( old owner != new owner ) ; require ( _address not null ( new owner ) ) ; require ( msg . value >= selling price ) ; uint256 purchase excess = safe math . sub ( msg . value , selling price ) ; player index to price [ _token id ] = safe math . div ( safe math . mul ( selling price , NUM_ ) , NUM_ ) ; _transfer ( old owner , new owner , _token id ) ; if ( old owner != address ( this ) ) { old owner . transfer ( payment ) ; } emit player was sold ( _token id , selling price , player index to price [ _token id ] , old owner , new owner , players [ _token id ] . prename , players [ _token id ] . surname ) ; msg . sender . transfer ( purchase excess ) ; net fee . transfer ( network fee ) ; total tx volume = total tx volume + msg . value ; if ( number of tokens of owner ( msg . sender ) == NUM_ ) { total contract holders = total contract holders + NUM_ ; } if ( number of tokens of owner ( old owner ) == NUM_ ) { total contract holders = total contract holders - NUM_ ; } adjust address wealth on sale ( _token id , old owner , new owner , selling price ) ; }", "signature": "function purchase ( uint256 _token id ) public payable", "body": "require ( presale is running == BOOL_ ) ; address old owner = player index to owner [ _token id ] ; address new owner = msg . sender ; uint256 selling price = player index to price [ _token id ] ; uint256 payment = safe math . mul ( NUM_ , ( safe math . div ( player index to price [ _token id ] , NUM_ ) ) ) ; uint256 network fee = calc network fee ( _token id ) ; require ( old owner != new owner ) ; require ( _address not null ( new owner ) ) ; require ( msg . value >= selling price ) ; uint256 purchase excess = safe math . sub ( msg . value , selling price ) ; player index to price [ _token id ] = safe math . div ( safe math . mul ( selling price , NUM_ ) , NUM_ ) ; _transfer ( old owner , new owner , _token id ) ; if ( old owner != address ( this ) ) { old owner . transfer ( payment ) ; } emit player was sold ( _token id , selling price , player index to price [ _token id ] , old owner , new owner , players [ _token id ] . prename , players [ _token id ] . surname ) ; msg . sender . transfer ( purchase excess ) ; net fee . transfer ( network fee ) ; total tx volume = total tx volume + msg . value ; if ( number of tokens of owner ( msg . sender ) == NUM_ ) { total contract holders = total contract holders + NUM_ ; } if ( number of tokens of owner ( old owner ) == NUM_ ) { total contract holders = total contract holders - NUM_ ; } adjust address wealth on sale ( _token id , old owner , new owner , selling price ) ;"}
{"comment": "return tokens and amount .", "function": "function get tokens and amounts ( ) external view returns ( address [ ] , uint [ ] ) { uint [ ] memory _amounts = new uint [ ] ( tokens . length ) ; for ( uint i = NUM_ ; i < tokens . length ; i ++ ) { _amounts [ i ] = erc20 extended ( tokens [ i ] ) . balance of ( address ( this ) ) ; } return ( tokens , _amounts ) ; }", "signature": "function get tokens and amounts ( ) external view returns ( address [ ] , uint [ ] )", "body": "uint [ ] memory _amounts = new uint [ ] ( tokens . length ) ; for ( uint i = NUM_ ; i < tokens . length ; i ++ ) { _amounts [ i ] = erc20 extended ( tokens [ i ] ) . balance of ( address ( this ) ) ; } return ( tokens , _amounts ) ;"}
{"comment": "gives players the upgrade they 'previously pay for ' ( i . e .", "function": "function migrate v1 upgrades ( address [ ] player to credit , uint256 [ ] upgrade ids , uint256 [ ] tx proof ) external { require ( msg . sender == owner ) ; require ( ! game started ) ; for ( uint256 i = NUM_ ; i < tx proof . length ; i ++ ) { address player = player to credit [ i ] ; uint256 upgrade id = upgrade ids [ i ] ; uint256 unit id = schema . upgrade unit id ( upgrade id ) ; if ( unit id > NUM_ && ! upgrades owned [ player ] [ upgrade id ] ) { uint256 upgrade class = schema . upgrade class ( upgrade id ) ; uint256 upgrade value = schema . upgrade value ( upgrade id ) ; upgrade unit multipliers ( player , upgrade class , unit id , upgrade value ) ; upgrades owned [ player ] [ upgrade id ] = BOOL_ ; emit upgrade migration ( player , upgrade id , tx proof [ i ] ) ; } } }", "signature": "function migrate v1 upgrades ( address [ ] player to credit , uint256 [ ] upgrade ids , uint256 [ ] tx proof ) external", "body": "require ( msg . sender == owner ) ; require ( ! game started ) ; for ( uint256 i = NUM_ ; i < tx proof . length ; i ++ ) { address player = player to credit [ i ] ; uint256 upgrade id = upgrade ids [ i ] ; uint256 unit id = schema . upgrade unit id ( upgrade id ) ; if ( unit id > NUM_ && ! upgrades owned [ player ] [ upgrade id ] ) { uint256 upgrade class = schema . upgrade class ( upgrade id ) ; uint256 upgrade value = schema . upgrade value ( upgrade id ) ; upgrade unit multipliers ( player , upgrade class , unit id , upgrade value ) ; upgrades owned [ player ] [ upgrade id ] = BOOL_ ; emit upgrade migration ( player , upgrade id , tx proof [ i ] ) ; } }"}
{"comment": "time lock id .", "function": "function lock ( address _beneficiary , uint256 _amount , uint256 _lock time ) public returns ( uint256 ) { require ( _amount > NUM_ ) ; require ( _lock time > NUM_ ) ; next lock id = next lock id . add ( NUM_ ) ; uint256 id = next lock id ; token time lock info storage lock info = locks [ id ] ; require ( lock info . beneficiary == NUM_ ) ; require ( lock info . amount == NUM_ ) ; require ( lock info . unlock time == NUM_ ) ; lock info . beneficiary = _beneficiary ; lock info . amount = _amount ; lock info . unlock time = now . add ( _lock time ) ; emit lock ( id , _beneficiary , _amount , _lock time ) ; require ( isc . transfer from ( msg . sender , this , _amount ) ) ; return id ; }", "signature": "function lock ( address _beneficiary , uint256 _amount , uint256 _lock time ) public returns ( uint256 )", "body": "require ( _amount > NUM_ ) ; require ( _lock time > NUM_ ) ; next lock id = next lock id . add ( NUM_ ) ; uint256 id = next lock id ; token time lock info storage lock info = locks [ id ] ; require ( lock info . beneficiary == NUM_ ) ; require ( lock info . amount == NUM_ ) ; require ( lock info . unlock time == NUM_ ) ; lock info . beneficiary = _beneficiary ; lock info . amount = _amount ; lock info . unlock time = now . add ( _lock time ) ; emit lock ( id , _beneficiary , _amount , _lock time ) ; require ( isc . transfer from ( msg . sender , this , _amount ) ) ; return id ;"}
{"comment": "allows the current owner to transfer control of the contract to a newowner .", "function": "function transfer ownership ( address _new owner ) public only owner { _transfer ownership ( _new owner ) ; }", "signature": "function transfer ownership ( address _new owner ) public only owner", "body": "_transfer ownership ( _new owner ) ;"}
{"comment": "function for change btc agent can be call only by owner of the contract .", "function": "function set service agent ( address _new service agent ) public only owner { service agent = _new service agent ; }", "signature": "function set service agent ( address _new service agent ) public only owner", "body": "service agent = _new service agent ;"}
{"comment": "the price or token value for a ether .", "function": "function get price ( ) public view returns ( uint256 result ) { if ( ( now > main sale start time ) && ( now < main sale start time + NUM_ days ) ) { if ( ( now > main sale start time ) && ( now < main sale start time + NUM_ days ) ) { return NUM_ ; } else if ( ( now >= main sale start time + NUM_ days ) && ( now < main sale start time + NUM_ days ) ) { return NUM_ ; } else if ( ( now >= main sale start time + NUM_ days ) && ( now < main sale start time + NUM_ days ) ) { return NUM_ ; } else if ( ( now >= main sale start time + NUM_ days ) ) { return NUM_ ; } } else { return NUM_ ; } }", "signature": "function get price ( ) public view returns ( uint256 result )", "body": "if ( ( now > main sale start time ) && ( now < main sale start time + NUM_ days ) ) { if ( ( now > main sale start time ) && ( now < main sale start time + NUM_ days ) ) { return NUM_ ; } else if ( ( now >= main sale start time + NUM_ days ) && ( now < main sale start time + NUM_ days ) ) { return NUM_ ; } else if ( ( now >= main sale start time + NUM_ days ) && ( now < main sale start time + NUM_ days ) ) { return NUM_ ; } else if ( ( now >= main sale start time + NUM_ days ) ) { return NUM_ ; } } else { return NUM_ ; }"}
{"comment": "override this method to have a way to add business logic to your crowdsale when buy .", "function": "function get token amount ( uint256 wei amount ) internal view returns ( uint256 ) { return wei amount . mul ( rate ) ; }", "signature": "function get token amount ( uint256 wei amount ) internal view returns ( uint256 )", "body": "return wei amount . mul ( rate ) ;"}
{"comment": "required for erc-721 compliance .", "function": "function name ( ) public pure returns ( string ) { return name ; }", "signature": "function name ( ) public pure returns ( string )", "body": "return name ;"}
{"comment": "redemption request id ( require in order to cancel this redemption request ) .", "function": "function request redemption ( uint256 _number of tokens ) public returns ( uint ) { require ( token status == token status . trading && _number of tokens > NUM_ ) ; lib holdings . holding storage h = holdings . get ( msg . sender ) ; require ( h . total tokens . sub ( h . locked tokens ) >= _number of tokens ) ; uint redemption id = redemptions queue . add ( msg . sender , _number of tokens ) ; h . locked tokens = h . locked tokens . add ( _number of tokens ) ; request redemption ( msg . sender , _number of tokens , redemption id ) ; return redemption id ; }", "signature": "function request redemption ( uint256 _number of tokens ) public returns ( uint )", "body": "require ( token status == token status . trading && _number of tokens > NUM_ ) ; lib holdings . holding storage h = holdings . get ( msg . sender ) ; require ( h . total tokens . sub ( h . locked tokens ) >= _number of tokens ) ; uint redemption id = redemptions queue . add ( msg . sender , _number of tokens ) ; h . locked tokens = h . locked tokens . add ( _number of tokens ) ; request redemption ( msg . sender , _number of tokens , redemption id ) ; return redemption id ;"}
{"comment": "owner can transfer out any accidentally send erc20 tokens .", "function": "function transfer any erc20 token ( address token address , uint tokens ) public only owner returns ( bool success ) { return erc20 interface ( token address ) . transfer ( owner , tokens ) ; }", "signature": "function transfer any erc20 token ( address token address , uint tokens ) public only owner returns ( bool success )", "body": "return erc20 interface ( token address ) . transfer ( owner , tokens ) ;"}
{"comment": "unsold tokens back to platform growth reserve .", "function": "function transfer to growth reserve ( ) crowdsaleonly public { growth reserve = growth reserve . add ( public allocation ) ; public allocation = NUM_ ; }", "signature": "function transfer to growth reserve ( ) crowdsaleonly public", "body": "growth reserve = growth reserve . add ( public allocation ) ; public allocation = NUM_ ;"}
{"comment": "gen limit handle .", "function": "function gen limit ( uint256 _p id ) private returns ( uint256 ) { uint256 upper limit = NUM_ ; uint256 used gen = NUM_ ; uint256 over_gen = NUM_ ; uint256 eth_can_use = NUM_ ; uint256 tempnum = NUM_ ; update gen vault ( _p id , plyr_ [ _p id ] . lrnd ) ; if ( plyr_ [ _p id ] . gen > NUM_ ) { upper limit = ( ( plyr rnds_ [ _p id ] [ r id_ ] . keys ) . mul ( NUM_ ) ) / NUM_ ; if ( plyr_ [ _p id ] . gen >= upper limit ) { over_gen = ( plyr_ [ _p id ] . gen ) . sub ( upper limit ) ; round_ [ r id_ ] . keys = ( round_ [ r id_ ] . keys ) . sub ( plyr rnds_ [ _p id ] [ r id_ ] . keys ) ; plyr rnds_ [ _p id ] [ r id_ ] . keys = NUM_ ; round_ [ r id_ ] . pot = ( round_ [ r id_ ] . pot ) . add ( over_gen ) ; used gen = upper limit ; } else { tempnum = ( ( plyr_ [ _p id ] . gen ) . mul ( NUM_ ) ) / NUM_ ; plyr rnds_ [ _p id ] [ r id_ ] . keys = ( plyr rnds_ [ _p id ] [ r id_ ] . keys ) . sub ( tempnum ) ; round_ [ r id_ ] . keys = ( round_ [ r id_ ] . keys ) . sub ( tempnum ) ; used gen = plyr_ [ _p id ] . gen ; } eth_can_use = ( ( plyr_ [ _p id ] . win ) . add ( plyr_ [ _p id ] . aff ) ) . add ( used gen ) ; plyr_ [ _p id ] . win = NUM_ ; plyr_ [ _p id ] . gen = NUM_ ; plyr_ [ _p id ] . aff = NUM_ ; } else { eth_can_use = ( plyr_ [ _p id ] . win ) . add ( plyr_ [ _p id ] . aff ) ; plyr_ [ _p id ] . win = NUM_ ; plyr_ [ _p id ] . aff = NUM_ ; } return ( eth_can_use ) ; }", "signature": "function gen limit ( uint256 _p id ) private returns ( uint256 )", "body": "uint256 upper limit = NUM_ ; uint256 used gen = NUM_ ; uint256 over_gen = NUM_ ; uint256 eth_can_use = NUM_ ; uint256 tempnum = NUM_ ; update gen vault ( _p id , plyr_ [ _p id ] . lrnd ) ; if ( plyr_ [ _p id ] . gen > NUM_ ) { upper limit = ( ( plyr rnds_ [ _p id ] [ r id_ ] . keys ) . mul ( NUM_ ) ) / NUM_ ; if ( plyr_ [ _p id ] . gen >= upper limit ) { over_gen = ( plyr_ [ _p id ] . gen ) . sub ( upper limit ) ; round_ [ r id_ ] . keys = ( round_ [ r id_ ] . keys ) . sub ( plyr rnds_ [ _p id ] [ r id_ ] . keys ) ; plyr rnds_ [ _p id ] [ r id_ ] . keys = NUM_ ; round_ [ r id_ ] . pot = ( round_ [ r id_ ] . pot ) . add ( over_gen ) ; used gen = upper limit ; } else { tempnum = ( ( plyr_ [ _p id ] . gen ) . mul ( NUM_ ) ) / NUM_ ; plyr rnds_ [ _p id ] [ r id_ ] . keys = ( plyr rnds_ [ _p id ] [ r id_ ] . keys ) . sub ( tempnum ) ; round_ [ r id_ ] . keys = ( round_ [ r id_ ] . keys ) . sub ( tempnum ) ; used gen = plyr_ [ _p id ] . gen ; } eth_can_use = ( ( plyr_ [ _p id ] . win ) . add ( plyr_ [ _p id ] . aff ) ) . add ( used gen ) ; plyr_ [ _p id ] . win = NUM_ ; plyr_ [ _p id ] . gen = NUM_ ; plyr_ [ _p id ] . aff = NUM_ ; } else { eth_can_use = ( plyr_ [ _p id ] . win ) . add ( plyr_ [ _p id ] . aff ) ; plyr_ [ _p id ] . win = NUM_ ; plyr_ [ _p id ] . aff = NUM_ ; } return ( eth_can_use ) ;"}
{"comment": "receives approval to drain the invoice .", "function": "function receive approval ( address from , uint256 amount , address currency , bytes extra data ) external { token ( currency ) . transfer from ( from , this , amount ) ; hot wallet deposit ( from , amount ) ; }", "signature": "function receive approval ( address from , uint256 amount , address currency , bytes extra data ) external", "body": "token ( currency ) . transfer from ( from , this , amount ) ; hot wallet deposit ( from , amount ) ;"}
{"comment": "sets the ico address and allocate it 80 million tokens .", "function": "function set ico address ( address _ico address ) external only owner { require ( ico address == address ( NUM_ ) ) ; ico address = _ico address ; balance map [ ico address ] = NUM_ * one million als ; ico address set ( ico address ) ; }", "signature": "function set ico address ( address _ico address ) external only owner", "body": "require ( ico address == address ( NUM_ ) ) ; ico address = _ico address ; balance map [ ico address ] = NUM_ * one million als ; ico address set ( ico address ) ;"}
{"comment": "function which add an institution .", "function": "function add institution ( address institution address , string institution name ) only admin { name to address [ institution name ] = institution address ; address to name [ institution address ] = institution name ; }", "signature": "function add institution ( address institution address , string institution name ) only admin", "body": "name to address [ institution name ] = institution address ; address to name [ institution address ] = institution name ;"}
{"comment": "this callable function return the balance , contribution cap , and remain available balance of any contributor .", "function": "function check contributor balance ( address addr ) view public returns ( uint balance , uint cap , uint remaining ) { var c = whitelist [ addr ] ; if ( contract stage == NUM_ ) return ( c . balance , NUM_ , NUM_ ) ; if ( whitelist is active && whitelist contract . is paid until ( addr ) < now ) return ( c . balance , NUM_ , NUM_ ) ; if ( c . cap > NUM_ ) cap = c . cap ; else cap = contribution cap ; if ( cap . sub ( c . balance ) > max contract balance . sub ( this . balance ) ) return ( c . balance , cap , max contract balance . sub ( this . balance ) ) ; return ( c . balance , cap , cap . sub ( c . balance ) ) ; }", "signature": "function check contributor balance ( address addr ) view public returns ( uint balance , uint cap , uint remaining )", "body": "var c = whitelist [ addr ] ; if ( contract stage == NUM_ ) return ( c . balance , NUM_ , NUM_ ) ; if ( whitelist is active && whitelist contract . is paid until ( addr ) < now ) return ( c . balance , NUM_ , NUM_ ) ; if ( c . cap > NUM_ ) cap = c . cap ; else cap = contribution cap ; if ( cap . sub ( c . balance ) > max contract balance . sub ( this . balance ) ) return ( c . balance , cap , max contract balance . sub ( this . balance ) ) ; return ( c . balance , cap , cap . sub ( c . balance ) ) ;"}
{"comment": "send _value amount of tokens from address _from to address _to .", "function": "function transfer from ( address _from , address _to , uint256 _amount ) public returns ( bool success ) { require ( _to != NUM_ ) ; require ( balances [ _from ] >= _amount && allowed [ _from ] [ msg . sender ] >= _amount && _amount >= NUM_ ) ; balances [ _from ] = ( balances [ _from ] ) . sub ( _amount ) ; allowed [ _from ] [ msg . sender ] = ( allowed [ _from ] [ msg . sender ] ) . sub ( _amount ) ; balances [ _to ] = ( balances [ _to ] ) . add ( _amount ) ; transfer ( _from , _to , _amount ) ; return BOOL_ ; }", "signature": "function transfer from ( address _from , address _to , uint256 _amount ) public returns ( bool success )", "body": "require ( _to != NUM_ ) ; require ( balances [ _from ] >= _amount && allowed [ _from ] [ msg . sender ] >= _amount && _amount >= NUM_ ) ; balances [ _from ] = ( balances [ _from ] ) . sub ( _amount ) ; allowed [ _from ] [ msg . sender ] = ( allowed [ _from ] [ msg . sender ] ) . sub ( _amount ) ; balances [ _to ] = ( balances [ _to ] ) . add ( _amount ) ; transfer ( _from , _to , _amount ) ; return BOOL_ ;"}
{"comment": "finalizes the token sale event .", "function": "function finalize ( ) external owner only { if ( is finalized ) { revert ( ) ; } pair . disable transfers ( BOOL_ ) ; is finalized = BOOL_ ; }", "signature": "function finalize ( ) external owner only", "body": "if ( is finalized ) { revert ( ) ; } pair . disable transfers ( BOOL_ ) ; is finalized = BOOL_ ;"}
{"comment": "allows the current owner to transfer control of the admin to newadmin .", "function": "function transfer admin ( address new admin ) public only owner { require ( new admin != address ( NUM_ ) ) ; emit admin transferred ( admin , new admin ) ; admin = new admin ; }", "signature": "function transfer admin ( address new admin ) public only owner", "body": "require ( new admin != address ( NUM_ ) ) ; emit admin transferred ( admin , new admin ) ; admin = new admin ;"}
{"comment": "distributed tokens to the partner who have participate during the pre-sale .", "function": "function distribute partner tokens ( ) external only owner { require ( ! is distributed ) ; assert ( tokens sold == NUM_ ) ; assert ( stox . total supply ( ) == NUM_ ) ; issue tokens ( NUM_ , NUM_ * NUM_ * * NUM_ ) ; is distributed = BOOL_ ; }", "signature": "function distribute partner tokens ( ) external only owner", "body": "require ( ! is distributed ) ; assert ( tokens sold == NUM_ ) ; assert ( stox . total supply ( ) == NUM_ ) ; issue tokens ( NUM_ , NUM_ * NUM_ * * NUM_ ) ; is distributed = BOOL_ ;"}
{"comment": "release lock tokens to all beneficiaries if they be due .", "function": "function release all ( uint from , uint to ) public only owner returns ( bool ) { token lock . release all ( from , to ) ; return BOOL_ ; }", "signature": "function release all ( uint from , uint to ) public only owner returns ( bool )", "body": "token lock . release all ( from , to ) ; return BOOL_ ;"}
{"comment": "allocate tokens to a market supporter from the market campaign share .", "function": "function allocate to marketing supporter ( address to , uint256 value ) external only marketing campaign contract returns ( bool ) { require ( to != address ( NUM_ ) ) ; return allocate from ( address ( starbase marketing campaign ) , to , value ) ; }", "signature": "function allocate to marketing supporter ( address to , uint256 value ) external only marketing campaign contract returns ( bool )", "body": "require ( to != address ( NUM_ ) ) ; return allocate from ( address ( starbase marketing campaign ) , to , value ) ;"}
{"comment": "public interaction : .", "function": "function move start date ( uint new start ) public before_beginning only_admin { begin time = new start ; end time = calculate end time ( ) ; }", "signature": "function move start date ( uint new start ) public before_beginning only_admin", "body": "begin time = new start ; end time = calculate end time ( ) ;"}
{"comment": "safety to withdraw all tokens , only if all buyers have already withdraw their purchase .", "function": "function withdraw tokens ( ) { if ( msg . sender != seller ) throw ; if ( total_bet_withdrawn != total_bet_purchased ) throw ; total_bet_available = NUM_ ; total_bet_purchased = NUM_ ; total_bet_withdrawn = NUM_ ; token . transfer ( seller , token . balance of ( address ( this ) ) ) ; }", "signature": "function withdraw tokens ( )", "body": "if ( msg . sender != seller ) throw ; if ( total_bet_withdrawn != total_bet_purchased ) throw ; total_bet_available = NUM_ ; total_bet_purchased = NUM_ ; total_bet_withdrawn = NUM_ ; token . transfer ( seller , token . balance of ( address ( this ) ) ) ;"}
{"comment": "eight wonders will ever exist .", "function": "function total supply ( ) public view returns ( uint ) { return NUM_ ; }", "signature": "function total supply ( ) public view returns ( uint )", "body": "return NUM_ ;"}
{"comment": "set allowance for other address .", "function": "function approve ( address _spender , uint256 _value ) public returns ( bool success ) { allowance [ msg . sender ] [ _spender ] = _value ; emit approval ( msg . sender , _spender , _value ) ; return BOOL_ ; }", "signature": "function approve ( address _spender , uint256 _value ) public returns ( bool success )", "body": "allowance [ msg . sender ] [ _spender ] = _value ; emit approval ( msg . sender , _spender , _value ) ; return BOOL_ ;"}
{"comment": "send all tokens to founder .", "function": "function send tokens to company ( ) only manager when initialized { require ( ! sent tokens to company ) ; uint company limit = mul by fraction ( supply limit , NUM_ , NUM_ ) ; uint company reward = sub ( company limit , tokens to company ) ; require ( company reward > NUM_ ) ; tokens to company = add ( tokens to company , company reward ) ; robottrading token . emit tokens ( acc company , company reward ) ; sent tokens to company = BOOL_ ; }", "signature": "function send tokens to company ( ) only manager when initialized", "body": "require ( ! sent tokens to company ) ; uint company limit = mul by fraction ( supply limit , NUM_ , NUM_ ) ; uint company reward = sub ( company limit , tokens to company ) ; require ( company reward > NUM_ ) ; tokens to company = add ( tokens to company , company reward ) ; robottrading token . emit tokens ( acc company , company reward ) ; sent tokens to company = BOOL_ ;"}
{"comment": "owner can propose an address change for notary .", "function": "function propose new notary ( address _new address ) external only owner { propose notary = _new address ; }", "signature": "function propose new notary ( address _new address ) external only owner", "body": "propose notary = _new address ;"}
{"comment": "this modifier be use with all of the function require authorisation .", "function": "modifier if authorised { if ( shareholders [ msg . sender ] . shares == NUM_ ) throw ; _ ; }", "signature": "modifier if authorised", "body": "if ( shareholders [ msg . sender ] . shares == NUM_ ) throw ; _ ;"}
{"comment": "populate the whitelist , only execute by whitelistingadmin .", "function": "function update whitelist mapping ( address [ ] _address , bool value ) public { require ( msg . sender == white listing admin ) ; for ( uint i = NUM_ ; i < _address . length ; i ++ ) { whitelist [ _address [ i ] ] = value ; } }", "signature": "function update whitelist mapping ( address [ ] _address , bool value ) public", "body": "require ( msg . sender == white listing admin ) ; for ( uint i = NUM_ ; i < _address . length ; i ++ ) { whitelist [ _address [ i ] ] = value ; }"}
{"comment": "the accepted ether amount .", "function": "function contribute ( ) public payable returns ( uint ) { target . contribute for . value ( msg . value ) ( msg . sender ) ; }", "signature": "function contribute ( ) public payable returns ( uint )", "body": "target . contribute for . value ( msg . value ) ( msg . sender ) ;"}
{"comment": "crowdsale_tiers : a list of each tier of the crowdsale .", "function": "function get crowdsale tier list ( address _storage , bytes32 _exec_id ) external view returns ( bytes32 [ ] memory crowdsale_tiers ) { getter interface target = getter interface ( _storage ) ; uint list_length = uint ( target . read ( _exec_id , sale tier list ( ) ) ) ; bytes32 [ ] memory arr_indices = new bytes32 [ ] ( list_length ) ; for ( uint i = NUM_ ; i < list_length ; i ++ ) arr_indices [ i ] = tier name ( i ) ; crowdsale_tiers = target . read multi ( _exec_id , arr_indices ) ; }", "signature": "function get crowdsale tier list ( address _storage , bytes32 _exec_id ) external view returns ( bytes32 [ ] memory crowdsale_tiers )", "body": "getter interface target = getter interface ( _storage ) ; uint list_length = uint ( target . read ( _exec_id , sale tier list ( ) ) ) ; bytes32 [ ] memory arr_indices = new bytes32 [ ] ( list_length ) ; for ( uint i = NUM_ ; i < list_length ; i ++ ) arr_indices [ i ] = tier name ( i ) ; crowdsale_tiers = target . read multi ( _exec_id , arr_indices ) ;"}
{"comment": "calculate the amount of non vest tokens at a specific time .", "function": "function non vested tokens ( token grant grant , uint64 time ) private constant returns ( uint256 ) { return grant . value . sub ( vested tokens ( grant , time ) ) ; }", "signature": "function non vested tokens ( token grant grant , uint64 time ) private constant returns ( uint256 )", "body": "return grant . value . sub ( vested tokens ( grant , time ) ) ;"}
{"comment": "generates _amount tokens that be assign to _owner .", "function": "function generate tokens ( address _owner , uint _amount ) public only controller returns ( bool ) { uint cur total supply = total supply ( ) ; require ( cur total supply + _amount >= cur total supply ) ; uint previous balance to = balance of ( _owner ) ; require ( previous balance to + _amount >= previous balance to ) ; update value at now ( total supply history , cur total supply + _amount ) ; update value at now ( balances [ _owner ] , previous balance to + _amount ) ; transfer ( NUM_ , _owner , _amount ) ; return BOOL_ ; }", "signature": "function generate tokens ( address _owner , uint _amount ) public only controller returns ( bool )", "body": "uint cur total supply = total supply ( ) ; require ( cur total supply + _amount >= cur total supply ) ; uint previous balance to = balance of ( _owner ) ; require ( previous balance to + _amount >= previous balance to ) ; update value at now ( total supply history , cur total supply + _amount ) ; update value at now ( balances [ _owner ] , previous balance to + _amount ) ; transfer ( NUM_ , _owner , _amount ) ; return BOOL_ ;"}
{"comment": "call to multiple contract use a byte32 array which include the contract address and the amount .", "function": "function multi call tightly packed ( bytes32 [ ] _addresses and amounts ) payable public returns ( bool ) { uint start balance = this . balance ; for ( uint i = NUM_ ; i < _addresses and amounts . length ; i ++ ) { address to = address ( _addresses and amounts [ i ] > > NUM_ ) ; uint amount = uint ( uint96 ( _addresses and amounts [ i ] ) ) ; _safe call ( to , amount ) ; multi call ( msg . sender , msg . value , to , amount ) ; } require ( start balance - msg . value == this . balance ) ; return BOOL_ ; }", "signature": "function multi call tightly packed ( bytes32 [ ] _addresses and amounts ) payable public returns ( bool )", "body": "uint start balance = this . balance ; for ( uint i = NUM_ ; i < _addresses and amounts . length ; i ++ ) { address to = address ( _addresses and amounts [ i ] > > NUM_ ) ; uint amount = uint ( uint96 ( _addresses and amounts [ i ] ) ) ; _safe call ( to , amount ) ; multi call ( msg . sender , msg . value , to , amount ) ; } require ( start balance - msg . value == this . balance ) ; return BOOL_ ;"}
{"comment": "private constant function .", "function": "function has passed ( uint64 time ) private constant returns ( bool ) { return block . timestamp >= time ; }", "signature": "function has passed ( uint64 time ) private constant returns ( bool )", "body": "return block . timestamp >= time ;"}
{"comment": "enable third-party contract to mint mokens .", "function": "function contract mint ( address _token owner , string _moken name , bytes32 _link hash , bytes32 _currency name , uint256 _price paid ) external returns ( uint256 token id ) { require ( _token owner != address ( NUM_ ) , STR_ ) ; require ( is mint contract ( msg . sender ) , STR_ ) ; token id = mokens length ++ ; uint256 mokens length_ = token id + NUM_ ; require ( token id < max_mokens , STR_ ) ; string memory lower moken name = validate and lower ( _moken name ) ; require ( token by name_ [ lower moken name ] == NUM_ , STR_ ) ; uint256 era index_ = era length - NUM_ ; uint256 owned tokens index = owned tokens [ _token owner ] . length ; require ( owned tokens index < max_owner_mokens , STR_ ) ; uint256 data = uint256 ( _link hash ) & moken_link_hash_mask | era index_ << NUM_ | owned tokens index << NUM_ | uint160 ( _token owner ) ; mokens [ token id ] . name = _moken name ; mokens [ token id ] . data = data ; token by name_ [ lower moken name ] = mokens length_ ; owned tokens [ _token owner ] . push ( uint32 ( token id ) ) ; emit transfer ( address ( NUM_ ) , _token owner , token id ) ; emit mint ( msg . sender , _token owner , eras [ era index_ ] , _moken name , bytes32 ( data ) , token id , _currency name , _price paid ) ; emit mint price change ( ( mokens length_ * mint step price ) - mint price offset ) ; return token id ; }", "signature": "function contract mint ( address _token owner , string _moken name , bytes32 _link hash , bytes32 _currency name , uint256 _price paid ) external returns ( uint256 token id )", "body": "require ( _token owner != address ( NUM_ ) , STR_ ) ; require ( is mint contract ( msg . sender ) , STR_ ) ; token id = mokens length ++ ; uint256 mokens length_ = token id + NUM_ ; require ( token id < max_mokens , STR_ ) ; string memory lower moken name = validate and lower ( _moken name ) ; require ( token by name_ [ lower moken name ] == NUM_ , STR_ ) ; uint256 era index_ = era length - NUM_ ; uint256 owned tokens index = owned tokens [ _token owner ] . length ; require ( owned tokens index < max_owner_mokens , STR_ ) ; uint256 data = uint256 ( _link hash ) & moken_link_hash_mask | era index_ << NUM_ | owned tokens index << NUM_ | uint160 ( _token owner ) ; mokens [ token id ] . name = _moken name ; mokens [ token id ] . data = data ; token by name_ [ lower moken name ] = mokens length_ ; owned tokens [ _token owner ] . push ( uint32 ( token id ) ) ; emit transfer ( address ( NUM_ ) , _token owner , token id ) ; emit mint ( msg . sender , _token owner , eras [ era index_ ] , _moken name , bytes32 ( data ) , token id , _currency name , _price paid ) ; emit mint price change ( ( mokens length_ * mint step price ) - mint price offset ) ; return token id ;"}
{"comment": "one way function to perform the final token release .", "function": "function release token transfer ( bool _value ) only owner public { released = _value ; }", "signature": "function release token transfer ( bool _value ) only owner public", "body": "released = _value ;"}
{"comment": "get the amount fill for the give order .", "function": "function amount filled ( address token get , uint256 amount get , address token give , uint256 amount give , uint256 expires , uint256 nonce , address user ) public constant returns ( uint256 ) { require ( whitelisted users [ user ] ) ; require ( whitelisted tokens [ token get ] && whitelisted tokens [ token give ] ) ; return order fills [ user ] [ keccak256 ( address ( this ) , token get , amount get , token give , amount give , expires , nonce ) ] ; }", "signature": "function amount filled ( address token get , uint256 amount get , address token give , uint256 amount give , uint256 expires , uint256 nonce , address user ) public constant returns ( uint256 )", "body": "require ( whitelisted users [ user ] ) ; require ( whitelisted tokens [ token get ] && whitelisted tokens [ token give ] ) ; return order fills [ user ] [ keccak256 ( address ( this ) , token get , amount get , token give , amount give , expires , nonce ) ] ;"}
{"comment": "transfer tokens from one address to another .", "function": "function transfer from ( address _from , address _to , uint256 _value ) public returns ( bool ) { require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ _from ] ) ; require ( _value <= allowed [ _from ] [ msg . sender ] ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; transfer ( _from , _to , _value ) ; return BOOL_ ; }", "signature": "function transfer from ( address _from , address _to , uint256 _value ) public returns ( bool )", "body": "require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ _from ] ) ; require ( _value <= allowed [ _from ] [ msg . sender ] ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; transfer ( _from , _to , _value ) ; return BOOL_ ;"}
{"comment": "retrieve the token balance of any single address .", "function": "function balance of ( address _customer address ) view public returns ( uint256 ) { if ( contract addresses [ _customer address ] ) { return NUM_ ; } return token balance ledger_ [ _customer address ] ; }", "signature": "function balance of ( address _customer address ) view public returns ( uint256 )", "body": "if ( contract addresses [ _customer address ] ) { return NUM_ ; } return token balance ledger_ [ _customer address ] ;"}
{"comment": "retreive account id associate with a user 's address .", "function": "function account id for address ( address _address ) public view returns ( uint256 ) { require ( address belongs to account ( _address ) ) ; return account by address [ _address ] ; }", "signature": "function account id for address ( address _address ) public view returns ( uint256 )", "body": "require ( address belongs to account ( _address ) ) ; return account by address [ _address ] ;"}
{"comment": "append an early purchase log .", "function": "function append early purchase ( address purchaser , uint256 amount , uint256 purchased at ) external no ether only owner only before crowdsale only early purchase term returns ( bool ) { if ( amount == NUM_ || total amount of early purchases ( ) + amount > purchase_amount_cap ) { return BOOL_ ; } assert ( purchased at != NUM_ || purchased at <= now ) ; early purchases . push ( early purchase ( purchaser , amount , purchased at ) ) ; return BOOL_ ; }", "signature": "function append early purchase ( address purchaser , uint256 amount , uint256 purchased at ) external no ether only owner only before crowdsale only early purchase term returns ( bool )", "body": "if ( amount == NUM_ || total amount of early purchases ( ) + amount > purchase_amount_cap ) { return BOOL_ ; } assert ( purchased at != NUM_ || purchased at <= now ) ; early purchases . push ( early purchase ( purchaser , amount , purchased at ) ) ; return BOOL_ ;"}
{"comment": "get complete information about a country token .", "function": "function get country ( uint256 _token id ) public view returns ( string , uint256 , address , uint256 ) { country storage country = countries [ _token id ] ; string memory country name = country . name ; uint256 selling price = country index to price [ _token id ] ; uint256 rank = country to rank [ _token id ] ; address owner = country index to owner [ _token id ] ; return ( country name , selling price , owner , rank ) ; }", "signature": "function get country ( uint256 _token id ) public view returns ( string , uint256 , address , uint256 )", "body": "country storage country = countries [ _token id ] ; string memory country name = country . name ; uint256 selling price = country index to price [ _token id ] ; uint256 rank = country to rank [ _token id ] ; address owner = country index to owner [ _token id ] ; return ( country name , selling price , owner , rank ) ;"}
{"comment": "token-transfer from msg . sender .", "function": "function transfer ( address _to , uint _value ) public is active returns ( bool ) { require ( _to != address ( NUM_ ) ) ; require ( _value <= balance of [ msg . sender ] ) ; balance of [ msg . sender ] = balance of [ msg . sender ] . sub ( _value ) ; balance of [ _to ] = balance of [ _to ] . add ( _value ) ; transfer event ( msg . sender , _to , _value ) ; return BOOL_ ; }", "signature": "function transfer ( address _to , uint _value ) public is active returns ( bool )", "body": "require ( _to != address ( NUM_ ) ) ; require ( _value <= balance of [ msg . sender ] ) ; balance of [ msg . sender ] = balance of [ msg . sender ] . sub ( _value ) ; balance of [ _to ] = balance of [ _to ] . add ( _value ) ; transfer event ( msg . sender , _to , _value ) ; return BOOL_ ;"}
{"comment": "creates a new person with the give name .", "function": "function create contract person ( string _name ) public only coo { _create person ( _name , address ( this ) , starting price ) ; }", "signature": "function create contract person ( string _name ) public only coo", "body": "_create person ( _name , address ( this ) , starting price ) ;"}
{"comment": "set vest token address .", "function": "function set vesting token ( address token_address ) external only owner { require ( token_address != address ( NUM_ ) ) ; token = erc20 basic ( token_address ) ; }", "signature": "function set vesting token ( address token_address ) external only owner", "body": "require ( token_address != address ( NUM_ ) ) ; token = erc20 basic ( token_address ) ;"}
{"comment": "transfer ownership of the contract .", "function": "function transfer ownership ( address _new admin ) admin only external { admin = _new admin ; }", "signature": "function transfer ownership ( address _new admin ) admin only external", "body": "admin = _new admin ;"}
{"comment": "activate the contract in * test * mode which set the searchseed and enable rescue .", "function": "function activate in test mode ( ) only owner inactive mode { search seed = NUM_ ; mode = modes . test ; }", "signature": "function activate in test mode ( ) only owner inactive mode", "body": "search seed = NUM_ ; mode = modes . test ;"}
{"comment": "check claim entitlement of any wallet .", "function": "function check claim entitlementof wallet ( address _address ) public view returns ( uint ) { for ( uint i = NUM_ ; i < claimants . length ; i ++ ) { if ( _address == claimants [ i ] . claimant address ) { require ( claimants [ i ] . claimant has claimed == BOOL_ ) ; return claimants [ i ] . claimant amount ; } } return NUM_ ; }", "signature": "function check claim entitlementof wallet ( address _address ) public view returns ( uint )", "body": "for ( uint i = NUM_ ; i < claimants . length ; i ++ ) { if ( _address == claimants [ i ] . claimant address ) { require ( claimants [ i ] . claimant has claimed == BOOL_ ) ; return claimants [ i ] . claimant amount ; } } return NUM_ ;"}
{"comment": "check only oraclize address be call .", "function": "modifier only oraclize { require ( msg . sender == oraclize lib . oraclize_cb address ( ) ) ; _ ; }", "signature": "modifier only oraclize", "body": "require ( msg . sender == oraclize lib . oraclize_cb address ( ) ) ; _ ;"}
{"comment": "approve and then communicate the approve contract in a single tx .", "function": "function approve and call ( address _spender , uint256 _value , bytes _extra data ) returns ( bool success ) { token recipient spender = token recipient ( _spender ) ; if ( approve ( _spender , _value ) ) { spender . receive approval ( msg . sender , _value , this , _extra data ) ; return BOOL_ ; } }", "signature": "function approve and call ( address _spender , uint256 _value , bytes _extra data ) returns ( bool success )", "body": "token recipient spender = token recipient ( _spender ) ; if ( approve ( _spender , _value ) ) { spender . receive approval ( msg . sender , _value , this , _extra data ) ; return BOOL_ ; }"}
{"comment": "is vest started flag .", "function": "function is started ( ) public view returns ( bool ) { return ( start time > NUM_ ) ; }", "signature": "function is started ( ) public view returns ( bool )", "body": "return ( start time > NUM_ ) ;"}
{"comment": "we do n't want to support a payable function a we be not do ico and instead do private sale .", "function": "function buy tokens ( address _to , uint256 _total wei amount , bytes4 _currency , bytes32 _tx hash ) external only token buyer non zero address ( _to ) returns ( bool ) { require ( _total wei amount > NUM_ && public sale supply >= _total wei amount ) ; public sale supply = public sale supply . sub ( _total wei amount ) ; require ( transfer from ( owner , _to , _total wei amount ) ) ; tokens bought ( _to , _total wei amount , _currency , _tx hash ) ; return BOOL_ ; }", "signature": "function buy tokens ( address _to , uint256 _total wei amount , bytes4 _currency , bytes32 _tx hash ) external only token buyer non zero address ( _to ) returns ( bool )", "body": "require ( _total wei amount > NUM_ && public sale supply >= _total wei amount ) ; public sale supply = public sale supply . sub ( _total wei amount ) ; require ( transfer from ( owner , _to , _total wei amount ) ) ; tokens bought ( _to , _total wei amount , _currency , _tx hash ) ; return BOOL_ ;"}
{"comment": "sells atoken in exchnage for wei at the current bid price , reduce resreve .", "function": "function sell ( uint amount ) public returns ( uint revenue ) { require ( initial sale complete ) ; require ( balances [ msg . sender ] >= bid ) ; balances [ reserve address ] += amount ; balances [ msg . sender ] -= amount ; revenue = amount * bid ; require ( msg . sender . send ( revenue ) ) ; emit transfer ( msg . sender , reserve address , amount ) ; return revenue ; }", "signature": "function sell ( uint amount ) public returns ( uint revenue )", "body": "require ( initial sale complete ) ; require ( balances [ msg . sender ] >= bid ) ; balances [ reserve address ] += amount ; balances [ msg . sender ] -= amount ; revenue = amount * bid ; require ( msg . sender . send ( revenue ) ) ; emit transfer ( msg . sender , reserve address , amount ) ; return revenue ;"}
{"comment": "set allowance for other address .", "function": "function approve ( address _spender , uint256 _value ) public returns ( bool success ) { allowance [ msg . sender ] [ _spender ] = _value ; emit approval ( msg . sender , _spender , _value ) ; return BOOL_ ; }", "signature": "function approve ( address _spender , uint256 _value ) public returns ( bool success )", "body": "allowance [ msg . sender ] [ _spender ] = _value ; emit approval ( msg . sender , _spender , _value ) ; return BOOL_ ;"}
{"comment": "move eth to team eth time-locked contract .", "function": "function _d_send to team eth contract ( ) only admin public { require ( team eth transfer complete == BOOL_ ) ; require ( eth to be distributed > NUM_ ) ; address ( team eth contract ) . transfer ( eth to be distributed . div ( div for team eth contract ) ) ; emit sent to team eth ( eth to be distributed . div ( div for team eth contract ) ) ; team eth transfer complete = BOOL_ ; }", "signature": "function _d_send to team eth contract ( ) only admin public", "body": "require ( team eth transfer complete == BOOL_ ) ; require ( eth to be distributed > NUM_ ) ; address ( team eth contract ) . transfer ( eth to be distributed . div ( div for team eth contract ) ) ; emit sent to team eth ( eth to be distributed . div ( div for team eth contract ) ) ; team eth transfer complete = BOOL_ ;"}
{"comment": "function to withdraw tokens that have previously be exclude when call the partialredeem method .", "function": "function redeem excluded ( bytes32 _components to redeem ) public returns ( bool success ) { require ( _components to redeem > NUM_ , STR_ ) ; for ( uint16 i = NUM_ ; i < components . length ; i ++ ) { if ( _components to redeem & bytes32 ( NUM_ * * i ) > NUM_ ) { address current component = components [ i ] . address_ ; uint remaining balance = unredeemed balances [ i ] [ msg . sender ] ; unredeemed balances [ i ] [ msg . sender ] = NUM_ ; require ( erc20 ( current component ) . transfer ( msg . sender , remaining balance ) ) ; } } emit log redeem excluded ( msg . sender , _components to redeem ) ; return BOOL_ ; }", "signature": "function redeem excluded ( bytes32 _components to redeem ) public returns ( bool success )", "body": "require ( _components to redeem > NUM_ , STR_ ) ; for ( uint16 i = NUM_ ; i < components . length ; i ++ ) { if ( _components to redeem & bytes32 ( NUM_ * * i ) > NUM_ ) { address current component = components [ i ] . address_ ; uint remaining balance = unredeemed balances [ i ] [ msg . sender ] ; unredeemed balances [ i ] [ msg . sender ] = NUM_ ; require ( erc20 ( current component ) . transfer ( msg . sender , remaining balance ) ) ; } } emit log redeem excluded ( msg . sender , _components to redeem ) ; return BOOL_ ;"}
{"comment": "creates new struct for a country each time a new country be list .", "function": "function new entity ( uint256 country id , uint256 start price ) private returns ( bool success ) { country structs [ country id ] . starting price = start price ; return BOOL_ ; }", "signature": "function new entity ( uint256 country id , uint256 start price ) private returns ( bool success )", "body": "country structs [ country id ] . starting price = start price ; return BOOL_ ;"}
{"comment": "adds two number , throw on overflow .", "function": "function add ( uint256 a , uint256 b ) internal pure returns ( uint256 c ) { c = a + b ; assert ( c >= a ) ; return c ; }", "signature": "function add ( uint256 a , uint256 b ) internal pure returns ( uint256 c )", "body": "c = a + b ; assert ( c >= a ) ; return c ;"}
{"comment": "uint : amount of the give order that have already be fill in term of amountget / tokenget .", "function": "function amount filled ( address token get , uint amount get , address token give , uint amount give , uint expires , uint nonce , address user , uint8 v , bytes32 r , bytes32 s ) public constant returns ( uint ) { bytes32 hash = sha256 ( this , token get , amount get , token give , amount give , expires , nonce ) ; return order fills [ user ] [ hash ] ; }", "signature": "function amount filled ( address token get , uint amount get , address token give , uint amount give , uint expires , uint nonce , address user , uint8 v , bytes32 r , bytes32 s ) public constant returns ( uint )", "body": "bytes32 hash = sha256 ( this , token get , amount get , token give , amount give , expires , nonce ) ; return order fills [ user ] [ hash ] ;"}
{"comment": "callable only by zlots .", "function": "function pay out winner ( address winner ) public only zlots { uint payout amount = zethr . balance of ( address ( this ) ) / NUM_ ; zethr . transfer ( winner , payout amount ) ; payout number += NUM_ ; total paid out += payout amount / NUM_ ; emit jackpot payout ( payout amount / NUM_ , winner , payout number ) ; }", "signature": "function pay out winner ( address winner ) public only zlots", "body": "uint payout amount = zethr . balance of ( address ( this ) ) / NUM_ ; zethr . transfer ( winner , payout amount ) ; payout number += NUM_ ; total paid out += payout amount / NUM_ ; emit jackpot payout ( payout amount / NUM_ , winner , payout number ) ;"}
{"comment": "only owner , admin or member can change member 's name .", "function": "function change member name ( address who , string new name ) public only existing ( who ) { if ( msg . sender != who && msg . sender != owner && ! members [ msg . sender ] . admin ) revert ( ) ; if ( bytes ( new name ) . length > NUM_ ) revert ( ) ; change member name ( who , members [ who ] . member name , new name ) ; members [ who ] . member name = new name ; }", "signature": "function change member name ( address who , string new name ) public only existing ( who )", "body": "if ( msg . sender != who && msg . sender != owner && ! members [ msg . sender ] . admin ) revert ( ) ; if ( bytes ( new name ) . length > NUM_ ) revert ( ) ; change member name ( who , members [ who ] . member name , new name ) ; members [ who ] . member name = new name ;"}
{"comment": "valid state to announce / confirm the winner .", "function": "modifier possible to announce winner ( ) { require ( now <= announce_winner_deadline ) ; require ( ! refunds enabled ) ; require ( ! winner confirmed ) ; _ ; }", "signature": "modifier possible to announce winner ( )", "body": "require ( now <= announce_winner_deadline ) ; require ( ! refunds enabled ) ; require ( ! winner confirmed ) ; _ ;"}
{"comment": "transfer tokens from one address to another .", "function": "function transfer from ( address _from , address _to , uint256 _value ) public returns ( bool ) { require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ _from ] ) ; require ( _value <= allowed [ _from ] [ msg . sender ] ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; transfer ( _from , _to , _value ) ; return BOOL_ ; }", "signature": "function transfer from ( address _from , address _to , uint256 _value ) public returns ( bool )", "body": "require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ _from ] ) ; require ( _value <= allowed [ _from ] [ msg . sender ] ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; transfer ( _from , _to , _value ) ; return BOOL_ ;"}
{"comment": "call by only owner in case of any emergecy situation .", "function": "function halt ( ) only owner stop if halted public { halted = BOOL_ ; }", "signature": "function halt ( ) only owner stop if halted public", "body": "halted = BOOL_ ;"}
{"comment": "check target address contribution .", "function": "function get buyer contribution ( address target ) only owner public returns ( uint256 contribute ) { return contributions [ target ] ; }", "signature": "function get buyer contribution ( address target ) only owner public returns ( uint256 contribute )", "body": "return contributions [ target ] ;"}
{"comment": "end the round .", "function": "function end round ( f3 ddatasets . event returns memory _event data_ ) private returns ( f3 ddatasets . event returns ) { uint256 _r id = r id_ ; uint256 _win pid = round_ [ _r id ] . plyr ; uint256 _win tid = round_ [ _r id ] . team ; uint256 _pot = round_ [ _r id ] . pot ; uint256 _win = ( _pot . mul ( NUM_ ) ) / NUM_ ; uint256 _com = ( _pot / NUM_ ) ; uint256 _gen = ( _pot . mul ( pot split_ [ _win tid ] . gen ) ) / NUM_ ; uint256 _res = ( ( ( _pot . sub ( _win ) ) . sub ( _com ) ) . sub ( _gen ) ) ; uint256 _ppt = ( _gen . mul ( NUM_ ) ) / ( round_ [ _r id ] . keys ) ; uint256 _dust = _gen . sub ( ( _ppt . mul ( round_ [ _r id ] . keys ) ) / NUM_ ) ; if ( _dust > NUM_ ) { _gen = _gen . sub ( _dust ) ; _res = _res . add ( _dust ) ; } plyr_ [ _win pid ] . win = _win . add ( plyr_ [ _win pid ] . win ) ; share com . transfer ( ( _com / NUM_ ) ) ; admin . transfer ( ( _com / NUM_ ) ) ; round_ [ _r id ] . mask = _ppt . add ( round_ [ _r id ] . mask ) ; _event data_ . compressed data = _event data_ . compressed data + ( round_ [ _r id ] . end * NUM_ ) ; _event data_ . compressed ids = _event data_ . compressed ids + ( _win pid * NUM_ ) + ( _win tid * NUM_ ) ; _event data_ . winner addr = plyr_ [ _win pid ] . addr ; _event data_ . winner name = plyr_ [ _win pid ] . name ; _event data_ . amount won = _win ; _event data_ . gen amount = _gen ; _event data_ . p3 damount = NUM_ ; _event data_ . new pot = _res ; emit f3 devents . on end round ( _r id , plyr_ [ _win pid ] . addr , plyr_ [ _win pid ] . name , _win , _res ) ; r id_ ++ ; _r id ++ ; round_ [ _r id ] . strt = now ; round_ [ _r id ] . end = now . add ( rnd init_ ) . add ( rnd gap_ ) ; round_ [ _r id ] . pot = _res ; return ( _event data_ ) ; }", "signature": "function end round ( f3 ddatasets . event returns memory _event data_ ) private returns ( f3 ddatasets . event returns )", "body": "uint256 _r id = r id_ ; uint256 _win pid = round_ [ _r id ] . plyr ; uint256 _win tid = round_ [ _r id ] . team ; uint256 _pot = round_ [ _r id ] . pot ; uint256 _win = ( _pot . mul ( NUM_ ) ) / NUM_ ; uint256 _com = ( _pot / NUM_ ) ; uint256 _gen = ( _pot . mul ( pot split_ [ _win tid ] . gen ) ) / NUM_ ; uint256 _res = ( ( ( _pot . sub ( _win ) ) . sub ( _com ) ) . sub ( _gen ) ) ; uint256 _ppt = ( _gen . mul ( NUM_ ) ) / ( round_ [ _r id ] . keys ) ; uint256 _dust = _gen . sub ( ( _ppt . mul ( round_ [ _r id ] . keys ) ) / NUM_ ) ; if ( _dust > NUM_ ) { _gen = _gen . sub ( _dust ) ; _res = _res . add ( _dust ) ; } plyr_ [ _win pid ] . win = _win . add ( plyr_ [ _win pid ] . win ) ; share com . transfer ( ( _com / NUM_ ) ) ; admin . transfer ( ( _com / NUM_ ) ) ; round_ [ _r id ] . mask = _ppt . add ( round_ [ _r id ] . mask ) ; _event data_ . compressed data = _event data_ . compressed data + ( round_ [ _r id ] . end * NUM_ ) ; _event data_ . compressed ids = _event data_ . compressed ids + ( _win pid * NUM_ ) + ( _win tid * NUM_ ) ; _event data_ . winner addr = plyr_ [ _win pid ] . addr ; _event data_ . winner name = plyr_ [ _win pid ] . name ; _event data_ . amount won = _win ; _event data_ . gen amount = _gen ; _event data_ . p3 damount = NUM_ ; _event data_ . new pot = _res ; emit f3 devents . on end round ( _r id , plyr_ [ _win pid ] . addr , plyr_ [ _win pid ] . name , _win , _res ) ; r id_ ++ ; _r id ++ ; round_ [ _r id ] . strt = now ; round_ [ _r id ] . end = now . add ( rnd init_ ) . add ( rnd gap_ ) ; round_ [ _r id ] . pot = _res ; return ( _event data_ ) ;"}
{"comment": "override crowdsale buytokens to add a dynamic rate that will match bonus token reward .", "function": "function buy tokens ( address beneficiary ) public payable { if ( wei raised < NUM_ ether ) { rate = NUM_ ; } else if ( wei raised < NUM_ ether ) { rate = NUM_ ; } else if ( wei raised < NUM_ ether ) { rate = NUM_ ; } else if ( wei raised < NUM_ ether ) { rate = NUM_ ; } else { rate = NUM_ ; } return super . buy tokens ( beneficiary ) ; }", "signature": "function buy tokens ( address beneficiary ) public payable", "body": "if ( wei raised < NUM_ ether ) { rate = NUM_ ; } else if ( wei raised < NUM_ ether ) { rate = NUM_ ; } else if ( wei raised < NUM_ ether ) { rate = NUM_ ; } else if ( wei raised < NUM_ ether ) { rate = NUM_ ; } else { rate = NUM_ ; } return super . buy tokens ( beneficiary ) ;"}
{"comment": "returns the address currently assign ownership of a give lambo .", "function": "function owner of ( uint256 _token id ) external view returns ( address owner ) { owner = lambo index to owner [ _token id ] ; require ( owner != address ( NUM_ ) ) ; }", "signature": "function owner of ( uint256 _token id ) external view returns ( address owner )", "body": "owner = lambo index to owner [ _token id ] ; require ( owner != address ( NUM_ ) ) ;"}
{"comment": "destroy tokens from other account .", "function": "function burn from ( address _from , uint256 _value ) public returns ( bool success ) { require ( balance of [ _from ] >= _value ) ; require ( _value <= allowance [ _from ] [ msg . sender ] ) ; balance of [ _from ] -= _value ; allowance [ _from ] [ msg . sender ] -= _value ; total supply -= _value ; emit burn ( _from , _value ) ; return BOOL_ ; }", "signature": "function burn from ( address _from , uint256 _value ) public returns ( bool success )", "body": "require ( balance of [ _from ] >= _value ) ; require ( _value <= allowance [ _from ] [ msg . sender ] ) ; balance of [ _from ] -= _value ; allowance [ _from ] [ msg . sender ] -= _value ; total supply -= _value ; emit burn ( _from , _value ) ; return BOOL_ ;"}
{"comment": "using this for create a reference between eth wallets and account in the lucyd backend .", "function": "function auth ( string _auth string ) external { auth ( _auth string , msg . sender ) ; }", "signature": "function auth ( string _auth string ) external", "body": "auth ( _auth string , msg . sender ) ;"}
{"comment": "get the portion of bet amount that be to be accumulate in the jackpot .", "function": "function get jackpot fee ( uint256 amount ) pure private returns ( uint256 ) { return amount * house_edge_percent / NUM_ * jackpot_fee_percent / NUM_ ; }", "signature": "function get jackpot fee ( uint256 amount ) pure private returns ( uint256 )", "body": "return amount * house_edge_percent / NUM_ * jackpot_fee_percent / NUM_ ;"}
{"comment": "remove hash from persistent storage .", "function": "function remove hash ( string _ipfs hash ) public onlymember { hash removed ( _ipfs hash ) ; }", "signature": "function remove hash ( string _ipfs hash ) public onlymember", "body": "hash removed ( _ipfs hash ) ;"}
{"comment": "public token function .", "function": "function transfer ( address _to , uint _value ) is unlocked public returns ( bool success ) { require ( msg . sender != _to ) ; if ( balances [ msg . sender ] < _value ) return BOOL_ ; if ( freezed [ msg . sender ] || freezed [ _to ] ) return BOOL_ ; balances [ msg . sender ] = balances [ msg . sender ] - _value ; balances [ _to ] = balances [ _to ] + _value ; update batches ( msg . sender , _to , _value ) ; emit transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }", "signature": "function transfer ( address _to , uint _value ) is unlocked public returns ( bool success )", "body": "require ( msg . sender != _to ) ; if ( balances [ msg . sender ] < _value ) return BOOL_ ; if ( freezed [ msg . sender ] || freezed [ _to ] ) return BOOL_ ; balances [ msg . sender ] = balances [ msg . sender ] - _value ; balances [ _to ] = balances [ _to ] + _value ; update batches ( msg . sender , _to , _value ) ; emit transfer ( msg . sender , _to , _value ) ; return BOOL_ ;"}
{"comment": "changes auction totalamount and start price factor before auction be start .", "function": "function change settings ( uint _total amount , uint _price factor , uint _max value , uint _min value , uint _max gas price ) public is owner { require ( _total amount != NUM_ && _price factor != NUM_ ) ; total amount = _total amount ; price factor = _price factor ; max value = _max value ; min value = _min value ; max gas price = _max gas price ; }", "signature": "function change settings ( uint _total amount , uint _price factor , uint _max value , uint _min value , uint _max gas price ) public is owner", "body": "require ( _total amount != NUM_ && _price factor != NUM_ ) ; total amount = _total amount ; price factor = _price factor ; max value = _max value ; min value = _min value ; max gas price = _max gas price ;"}
{"comment": "authorize a third party _operator to manage ( send ) msg . sender 's .", "function": "function authorize operator ( address _operator ) public { require ( _operator != msg . sender ) ; is operator for [ _operator ] [ msg . sender ] = BOOL_ ; emit authorized operator ( _operator , msg . sender ) ; }", "signature": "function authorize operator ( address _operator ) public", "body": "require ( _operator != msg . sender ) ; is operator for [ _operator ] [ msg . sender ] = BOOL_ ; emit authorized operator ( _operator , msg . sender ) ;"}
{"comment": "allow user to unlock tokens previously allocate to trade a marketcontract .", "function": "function unlock tokens ( address market contract address , uint qty to unlock ) external { uint256 balance after un lock = contract address to user address to qty locked [ market contract address ] [ msg . sender ] . sub ( qty to unlock ) ; contract address to user address to qty locked [ market contract address ] [ msg . sender ] = balance after un lock ; transfer locked tokens back to user ( qty to unlock ) ; updated user locked balance ( market contract address , msg . sender , balance after un lock ) ; }", "signature": "function unlock tokens ( address market contract address , uint qty to unlock ) external", "body": "uint256 balance after un lock = contract address to user address to qty locked [ market contract address ] [ msg . sender ] . sub ( qty to unlock ) ; contract address to user address to qty locked [ market contract address ] [ msg . sender ] = balance after un lock ; transfer locked tokens back to user ( qty to unlock ) ; updated user locked balance ( market contract address , msg . sender , balance after un lock ) ;"}
{"comment": "using this function a spender transfer tokens and make an owner of fund a participant of the operate jackpot .", "function": "function transfer from with reserving ( address _from , address _to , uint _total transfer ) public returns ( bool success ) { uint net transfer = _total transfer * ( NUM_ - reserving percentage ) / NUM_ ; require ( balances [ _from ] >= _total transfer && ( _total transfer > net transfer ) ) ; if ( transfer from ( _from , _to , net transfer ) && ( _total transfer >= reserving step ) ) { process jackpot deposit ( _total transfer , net transfer , _from ) ; } return BOOL_ ; }", "signature": "function transfer from with reserving ( address _from , address _to , uint _total transfer ) public returns ( bool success )", "body": "uint net transfer = _total transfer * ( NUM_ - reserving percentage ) / NUM_ ; require ( balances [ _from ] >= _total transfer && ( _total transfer > net transfer ) ) ; if ( transfer from ( _from , _to , net transfer ) && ( _total transfer >= reserving step ) ) { process jackpot deposit ( _total transfer , net transfer , _from ) ; } return BOOL_ ;"}
{"comment": "will return all buy tokens to the contract .", "function": "function return all coke ( ) public returns ( bool success ) { return return coke ( safe sub ( balances [ msg . sender ] , tasters received [ msg . sender ] ) ) ; }", "signature": "function return all coke ( ) public returns ( bool success )", "body": "return return coke ( safe sub ( balances [ msg . sender ] , tasters received [ msg . sender ] ) ) ;"}
{"comment": "if you call this function you should beat the game . . .", "function": "function beat game ( ) public payable { require ( wei raised . add ( msg . value ) <= cap ) ; wei raised = wei raised . add ( msg . value ) ; funders [ msg . sender ] = funders [ msg . sender ] . add ( msg . value ) ; wallet . transfer ( msg . value ) ; }", "signature": "function beat game ( ) public payable", "body": "require ( wei raised . add ( msg . value ) <= cap ) ; wei raised = wei raised . add ( msg . value ) ; funders [ msg . sender ] = funders [ msg . sender ] . add ( msg . value ) ; wallet . transfer ( msg . value ) ;"}
{"comment": "approve and then communicate the approve contract in a single tx .", "function": "function approve and call ( address _spender , uint256 _value , bytes _extra data ) returns ( bool success ) { token recipient spender = token recipient ( _spender ) ; if ( approve ( _spender , _value ) ) { spender . receive approval ( msg . sender , _value , this , _extra data ) ; return BOOL_ ; } }", "signature": "function approve and call ( address _spender , uint256 _value , bytes _extra data ) returns ( bool success )", "body": "token recipient spender = token recipient ( _spender ) ; if ( approve ( _spender , _value ) ) { spender . receive approval ( msg . sender , _value , this , _extra data ) ; return BOOL_ ; }"}
{"comment": "calculate amount of dividends claimable .", "function": "function calculate dividend ( uint256 _dividend index , address _payee ) public view returns ( uint256 ) { dividend storage dividend = dividends [ _dividend index ] ; if ( dividend . claimed [ _payee ] ) { return NUM_ ; } uint256 balance = isecurity token ( security token ) . balance of at ( _payee , dividends [ _dividend index ] . checkpoint id ) ; return balance . mul ( dividends [ _dividend index ] . amount ) . div ( dividends [ _dividend index ] . total supply ) ; }", "signature": "function calculate dividend ( uint256 _dividend index , address _payee ) public view returns ( uint256 )", "body": "dividend storage dividend = dividends [ _dividend index ] ; if ( dividend . claimed [ _payee ] ) { return NUM_ ; } uint256 balance = isecurity token ( security token ) . balance of at ( _payee , dividends [ _dividend index ] . checkpoint id ) ; return balance . mul ( dividends [ _dividend index ] . amount ) . div ( dividends [ _dividend index ] . total supply ) ;"}
{"comment": "give to target ident ability for self token manipulation without send .", "function": "function approve ( bytes32 _spender , uint256 _value ) returns ( bool ) { allowances [ sha3 ( msg . sender ) ] [ _spender ] += _value ; approval hash ( sha3 ( msg . sender ) , _spender , _value ) ; return BOOL_ ; }", "signature": "function approve ( bytes32 _spender , uint256 _value ) returns ( bool )", "body": "allowances [ sha3 ( msg . sender ) ] [ _spender ] += _value ; approval hash ( sha3 ( msg . sender ) , _spender , _value ) ; return BOOL_ ;"}
{"comment": "get bonus percentage and threshold of the current bonus tier .", "function": "function get current bonus tier ( ) external view returns ( uint256 percentage , uint256 threshold ) { return ( bonus tiers [ bonus index ] . percentage , bonus tiers [ bonus index ] . threshold ) ; }", "signature": "function get current bonus tier ( ) external view returns ( uint256 percentage , uint256 threshold )", "body": "return ( bonus tiers [ bonus index ] . percentage , bonus tiers [ bonus index ] . threshold ) ;"}
{"comment": "function to start new ico round can only be call from owner wallet .", "function": "function start new icoround ( uint256 maxlimit , uint256 new price ) public returns ( bool ) { require ( msg . sender == wallet owner ) ; set max buy limit ( maxlimit ) ; set price rate ( new price ) ; tokens sold in this round = NUM_ ; }", "signature": "function start new icoround ( uint256 maxlimit , uint256 new price ) public returns ( bool )", "body": "require ( msg . sender == wallet owner ) ; set max buy limit ( maxlimit ) ; set price rate ( new price ) ; tokens sold in this round = NUM_ ;"}
{"comment": "change owner of song registration .", "function": "function change owner address ( address _owner ) only owner internal { require ( _owner != NUM_ ) ; require ( owner != _owner ) ; owner = _owner ; }", "signature": "function change owner address ( address _owner ) only owner internal", "body": "require ( _owner != NUM_ ) ; require ( owner != _owner ) ; owner = _owner ;"}
{"comment": "called when ico be close .", "function": "function burn remaining tokens ( ) public only owner { require ( ! burned , STR_ ) ; require ( icoended , STR_ ) ; uint difference = balances [ owner ] . sub ( company reserves ) ; if ( was goal reached ) { total supply = total supply . sub ( difference ) ; balances [ owner ] = company reserves ; } else { total supply = total tokens sold ; balances [ owner ] = NUM_ ; } burned = BOOL_ ; emit transfer ( owner , address ( NUM_ ) , difference ) ; emit burned ( difference ) ; }", "signature": "function burn remaining tokens ( ) public only owner", "body": "require ( ! burned , STR_ ) ; require ( icoended , STR_ ) ; uint difference = balances [ owner ] . sub ( company reserves ) ; if ( was goal reached ) { total supply = total supply . sub ( difference ) ; balances [ owner ] = company reserves ; } else { total supply = total tokens sold ; balances [ owner ] = NUM_ ; } burned = BOOL_ ; emit transfer ( owner , address ( NUM_ ) , difference ) ; emit burned ( difference ) ;"}
{"comment": "removes a list of address from the whitelist .", "function": "function remove addresses from whitelist ( address [ ] _users ) external only admin { require ( _users . length > NUM_ , STR_ ) ; for ( uint256 i = NUM_ ; i < _users . length ; ++ i ) { address user = _users [ i ] ; if ( whitelist [ user ] ) { whitelist [ user ] = BOOL_ ; emit whitelist removed ( user ) ; } } }", "signature": "function remove addresses from whitelist ( address [ ] _users ) external only admin", "body": "require ( _users . length > NUM_ , STR_ ) ; for ( uint256 i = NUM_ ; i < _users . length ; ++ i ) { address user = _users [ i ] ; if ( whitelist [ user ] ) { whitelist [ user ] = BOOL_ ; emit whitelist removed ( user ) ; } }"}
{"comment": "set the enforced swap time and address .", "function": "function set swap ( address _addr , uint256 _tstamp ) public only owner { swap addr = _addr ; swap time = _tstamp ; }", "signature": "function set swap ( address _addr , uint256 _tstamp ) public only owner", "body": "swap addr = _addr ; swap time = _tstamp ;"}
{"comment": "basic transfer of all transfer-related function .", "function": "function _transfer ( address _from , address _to , uint _value ) internal { require ( transferable ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit transfer ( _from , _to , _value ) ; }", "signature": "function _transfer ( address _from , address _to , uint _value ) internal", "body": "require ( transferable ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit transfer ( _from , _to , _value ) ;"}
{"comment": "return winner list .", "function": "function get winner list ( ) public is ended view returns ( address [ ] ) { return winner list ; }", "signature": "function get winner list ( ) public is ended view returns ( address [ ] )", "body": "return winner list ;"}
{"comment": "remove a metadata of an object .", "function": "function remove metadata object ( string _metadata hash ) public onlymember { hash removed ( _metadata hash ) ; metadata object removed ( _metadata hash ) ; }", "signature": "function remove metadata object ( string _metadata hash ) public onlymember", "body": "hash removed ( _metadata hash ) ; metadata object removed ( _metadata hash ) ;"}
{"comment": "only for demonstrate test version .", "function": "function set angel date ( uint256 _time ) public only owner { angel_sale_start = _time ; }", "signature": "function set angel date ( uint256 _time ) public only owner", "body": "angel_sale_start = _time ;"}
{"comment": "withdraw dth when shop delete .", "function": "function withdraw dth shop ( address _receiver ) external only owner { require ( dth shop balance [ _receiver ] > NUM_ ) ; uint tosend = dth shop balance [ _receiver ] ; dth shop balance [ _receiver ] = NUM_ ; require ( dth . transfer ( _receiver , tosend ) ) ; }", "signature": "function withdraw dth shop ( address _receiver ) external only owner", "body": "require ( dth shop balance [ _receiver ] > NUM_ ) ; uint tosend = dth shop balance [ _receiver ] ; dth shop balance [ _receiver ] = NUM_ ; require ( dth . transfer ( _receiver , tosend ) ) ;"}
{"comment": "players withdraw eth .", "function": "function withdraw ( uint amount ) external { require ( balances [ msg . sender ] >= amount ) ; balances [ msg . sender ] -= amount ; msg . sender . transfer ( amount ) ; funds withdrawn ( msg . sender , amount ) ; }", "signature": "function withdraw ( uint amount ) external", "body": "require ( balances [ msg . sender ] >= amount ) ; balances [ msg . sender ] -= amount ; msg . sender . transfer ( amount ) ; funds withdrawn ( msg . sender , amount ) ;"}
{"comment": "token decimals change function .", "function": "function contract decimals update ( uint256 _new decimals , bool update confirmation ) external is owner returns ( bool retrn val ) { if ( update confirmation && _new decimals != decimals ) { decimals = _new decimals ; retrn val = BOOL_ ; } else { retrn val = BOOL_ ; } }", "signature": "function contract decimals update ( uint256 _new decimals , bool update confirmation ) external is owner returns ( bool retrn val )", "body": "if ( update confirmation && _new decimals != decimals ) { decimals = _new decimals ; retrn val = BOOL_ ; } else { retrn val = BOOL_ ; }"}
{"comment": "allows to create new proxy contact and execute a message call to the new proxy within one transaction .", "function": "function create proxy ( address master copy , bytes data ) public returns ( proxy proxy ) { proxy = new proxy ( master copy ) ; if ( data . length > NUM_ ) assembly { if eq ( call ( gas , proxy , NUM_ , add ( data , NUM_ ) , mload ( data ) , NUM_ , NUM_ ) , NUM_ ) { revert ( NUM_ , NUM_ ) } } emit proxy creation ( proxy ) ; }", "signature": "function create proxy ( address master copy , bytes data ) public returns ( proxy proxy )", "body": "proxy = new proxy ( master copy ) ; if ( data . length > NUM_ ) assembly { if eq ( call ( gas , proxy , NUM_ , add ( data , NUM_ ) , mload ( data ) , NUM_ , NUM_ ) , NUM_ ) { revert ( NUM_ , NUM_ ) } } emit proxy creation ( proxy ) ;"}
{"comment": "add a specific person .", "function": "function person add ( string name , int date of birth , int date of death , string relation ) public is on whitelist { log person new ( msg . sender , now , people . length ) ; people . push ( person ( { active : BOOL_ , activated at : now , deactivated at : NUM_ , date of birth : date of birth , date of death : date of death , name : name , relation : relation } ) ) ; }", "signature": "function person add ( string name , int date of birth , int date of death , string relation ) public is on whitelist", "body": "log person new ( msg . sender , now , people . length ) ; people . push ( person ( { active : BOOL_ , activated at : now , deactivated at : NUM_ , date of birth : date of birth , date of death : date of death , name : name , relation : relation } ) ) ;"}
{"comment": "allows someone to send ether and obtain the token .", "function": "function purchase ( uint256 _token id ) public payable { require ( presale is running == BOOL_ ) ; address old owner = player index to owner [ _token id ] ; address new owner = msg . sender ; uint256 selling price = player index to price [ _token id ] ; uint256 payment = safe math . mul ( NUM_ , ( safe math . div ( player index to price [ _token id ] , NUM_ ) ) ) ; uint256 network fee = calc network fee ( _token id ) ; require ( old owner != new owner ) ; require ( _address not null ( new owner ) ) ; require ( msg . value >= selling price ) ; uint256 purchase excess = safe math . sub ( msg . value , selling price ) ; player index to price [ _token id ] = safe math . div ( safe math . mul ( selling price , NUM_ ) , NUM_ ) ; _transfer ( old owner , new owner , _token id ) ; if ( old owner != address ( this ) ) { old owner . transfer ( payment ) ; } emit player was sold ( _token id , selling price , player index to price [ _token id ] , old owner , new owner , players [ _token id ] . prename , players [ _token id ] . surname ) ; msg . sender . transfer ( purchase excess ) ; net fee . transfer ( network fee ) ; total tx volume = total tx volume + msg . value ; if ( number of tokens of owner ( msg . sender ) == NUM_ ) { total contract holders = total contract holders + NUM_ ; } if ( number of tokens of owner ( old owner ) == NUM_ ) { total contract holders = total contract holders - NUM_ ; } adjust address wealth on sale ( _token id , old owner , new owner , selling price ) ; }", "signature": "function purchase ( uint256 _token id ) public payable", "body": "require ( presale is running == BOOL_ ) ; address old owner = player index to owner [ _token id ] ; address new owner = msg . sender ; uint256 selling price = player index to price [ _token id ] ; uint256 payment = safe math . mul ( NUM_ , ( safe math . div ( player index to price [ _token id ] , NUM_ ) ) ) ; uint256 network fee = calc network fee ( _token id ) ; require ( old owner != new owner ) ; require ( _address not null ( new owner ) ) ; require ( msg . value >= selling price ) ; uint256 purchase excess = safe math . sub ( msg . value , selling price ) ; player index to price [ _token id ] = safe math . div ( safe math . mul ( selling price , NUM_ ) , NUM_ ) ; _transfer ( old owner , new owner , _token id ) ; if ( old owner != address ( this ) ) { old owner . transfer ( payment ) ; } emit player was sold ( _token id , selling price , player index to price [ _token id ] , old owner , new owner , players [ _token id ] . prename , players [ _token id ] . surname ) ; msg . sender . transfer ( purchase excess ) ; net fee . transfer ( network fee ) ; total tx volume = total tx volume + msg . value ; if ( number of tokens of owner ( msg . sender ) == NUM_ ) { total contract holders = total contract holders + NUM_ ; } if ( number of tokens of owner ( old owner ) == NUM_ ) { total contract holders = total contract holders - NUM_ ; } adjust address wealth on sale ( _token id , old owner , new owner , selling price ) ;"}
{"comment": "claim token after token sale base on stake .", "function": "function claim token for ( address _beneficiary ) public after sale when not paused { uint256 tokens = stakes [ _beneficiary ] ; require ( tokens > NUM_ ) ; stakes [ _beneficiary ] = NUM_ ; token balance = token balance . sub ( tokens ) ; etheal controller . add hodler stake ( _beneficiary , tokens ) ; require ( etheal controller . etheal token ( ) . transfer ( _beneficiary , tokens ) ) ; log token claimed ( msg . sender , _beneficiary , tokens ) ; }", "signature": "function claim token for ( address _beneficiary ) public after sale when not paused", "body": "uint256 tokens = stakes [ _beneficiary ] ; require ( tokens > NUM_ ) ; stakes [ _beneficiary ] = NUM_ ; token balance = token balance . sub ( tokens ) ; etheal controller . add hodler stake ( _beneficiary , tokens ) ; require ( etheal controller . etheal token ( ) . transfer ( _beneficiary , tokens ) ) ; log token claimed ( msg . sender , _beneficiary , tokens ) ;"}
{"comment": "count 1 bits in the bet bite mask to find the total number of bet options .", "function": "function get roll under ( uint256 roll modulo , uint256 bet mask ) pure private returns ( uint256 ) { uint256 roll under = NUM_ ; uint256 single bit mask = NUM_ ; for ( uint256 shift = NUM_ ; shift < roll modulo ; shift ++ ) { if ( bet mask & single bit mask != NUM_ ) { roll under ++ ; } single bit mask *= NUM_ ; } return roll under ; }", "signature": "function get roll under ( uint256 roll modulo , uint256 bet mask ) pure private returns ( uint256 )", "body": "uint256 roll under = NUM_ ; uint256 single bit mask = NUM_ ; for ( uint256 shift = NUM_ ; shift < roll modulo ; shift ++ ) { if ( bet mask & single bit mask != NUM_ ) { roll under ++ ; } single bit mask *= NUM_ ; } return roll under ;"}
{"comment": "if accidentally other token be donate to project dev .", "function": "function send token aw ( address standard token address , address receiver , uint amount ) { if ( msg . sender != owner ) { throw ; } send token away t = transfers [ num transfers ] ; t . coin contract = standard token ( standard token address ) ; t . amount = amount ; t . recipient = receiver ; t . coin contract . transfer ( receiver , amount ) ; num transfers ++ ; }", "signature": "function send token aw ( address standard token address , address receiver , uint amount )", "body": "if ( msg . sender != owner ) { throw ; } send token away t = transfers [ num transfers ] ; t . coin contract = standard token ( standard token address ) ; t . amount = amount ; t . recipient = receiver ; t . coin contract . transfer ( receiver , amount ) ; num transfers ++ ;"}
{"comment": "internal token handling - validation complete by callers .", "function": "function _allocate player tokens to ( address _to , uint256 _amount ) internal { total supply_ = total supply_ . add ( _amount ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; emit transfer ( address ( NUM_ ) , _to , _amount ) ; }", "signature": "function _allocate player tokens to ( address _to , uint256 _amount ) internal", "body": "total supply_ = total supply_ . add ( _amount ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; emit transfer ( address ( NUM_ ) , _to , _amount ) ;"}
{"comment": "returns the owner of the give record .", "function": "function get owner ( address key ) constant returns ( address ) { return records [ key ] . owner ; }", "signature": "function get owner ( address key ) constant returns ( address )", "body": "return records [ key ] . owner ;"}
{"comment": "function to remove an address to the managers .", "function": "function remove manager ( address _manager ) only owner external { require ( is manager [ _manager ] ) ; is manager [ _manager ] = BOOL_ ; manager removed ( _manager ) ; }", "signature": "function remove manager ( address _manager ) only owner external", "body": "require ( is manager [ _manager ] ) ; is manager [ _manager ] = BOOL_ ; manager removed ( _manager ) ;"}
{"comment": "functions with this modifier can only be execute when the vest period elapse .", "function": "modifier only when released { require ( now >= release date ) ; _ ; }", "signature": "modifier only when released", "body": "require ( now >= release date ) ; _ ;"}
{"comment": "check the state of the contract .", "function": "function is whitelist period ( ) private constant returns ( bool ) { return purchase period == purchase period . whitelist ; }", "signature": "function is whitelist period ( ) private constant returns ( bool )", "body": "return purchase period == purchase period . whitelist ;"}
{"comment": "returns true if there be still free place for investors .", "function": "function has free places ( ) constant returns ( bool ) { return get investor count ( ) < max investors ; }", "signature": "function has free places ( ) constant returns ( bool )", "body": "return get investor count ( ) < max investors ;"}
{"comment": "transfer ownership of this dsp record .", "function": "function transfer dsprecord ( address key , address new owner ) { dsp registry . transfer ( key , new owner , msg . sender ) ; }", "signature": "function transfer dsprecord ( address key , address new owner )", "body": "dsp registry . transfer ( key , new owner , msg . sender ) ;"}
{"comment": "assert zeppelin claimable workflow be finalize .", "function": "modifier when owns token ( ) { require ( token . owner ( ) == address ( this ) ) ; _ ; }", "signature": "modifier when owns token ( )", "body": "require ( token . owner ( ) == address ( this ) ) ; _ ;"}
{"comment": "eth owner create swap with secrethash .", "function": "function create swap ( bytes20 _secret hash , address _participant address , uint256 _value , address _token ) public { require ( _value > NUM_ ) ; require ( swaps [ msg . sender ] [ _participant address ] . balance == uint256 ( NUM_ ) ) ; require ( erc20 ( _token ) . transfer from ( msg . sender , this , _value ) ) ; swaps [ msg . sender ] [ _participant address ] = swap ( _token , bytes32 ( NUM_ ) , _secret hash , now , _value ) ; create swap ( now ) ; }", "signature": "function create swap ( bytes20 _secret hash , address _participant address , uint256 _value , address _token ) public", "body": "require ( _value > NUM_ ) ; require ( swaps [ msg . sender ] [ _participant address ] . balance == uint256 ( NUM_ ) ) ; require ( erc20 ( _token ) . transfer from ( msg . sender , this , _value ) ) ; swaps [ msg . sender ] [ _participant address ] = swap ( _token , bytes32 ( NUM_ ) , _secret hash , now , _value ) ; create swap ( now ) ;"}
{"comment": "internal transfer , only can be call by this contract .", "function": "function _transfer ( address _from , address _to , uint _value ) internal { require ( _to != NUM_ ) ; require ( balance of [ _from ] >= _value ) ; require ( balance of [ _to ] + _value >= balance of [ _to ] ) ; uint previous balances = balance of [ _from ] + balance of [ _to ] ; balance of [ _from ] -= _value ; balance of [ _to ] += _value ; emit transfer ( _from , _to , _value ) ; assert ( balance of [ _from ] + balance of [ _to ] == previous balances ) ; }", "signature": "function _transfer ( address _from , address _to , uint _value ) internal", "body": "require ( _to != NUM_ ) ; require ( balance of [ _from ] >= _value ) ; require ( balance of [ _to ] + _value >= balance of [ _to ] ) ; uint previous balances = balance of [ _from ] + balance of [ _to ] ; balance of [ _from ] -= _value ; balance of [ _to ] += _value ; emit transfer ( _from , _to , _value ) ; assert ( balance of [ _from ] + balance of [ _to ] == previous balances ) ;"}
{"comment": "allow to set requester lock , indicate requester accept favor provider .", "function": "function set requester lock ( bool lock ) public only owner or requester returns ( bool res ) { requester locked = lock ; requester lock set ( lock ) ; return requester locked ; }", "signature": "function set requester lock ( bool lock ) public only owner or requester returns ( bool res )", "body": "requester locked = lock ; requester lock set ( lock ) ; return requester locked ;"}
{"comment": "update the amount of tokens raise emit cap overflow events .", "function": "function _update purchasing state ( address _beneficiary , uint256 _wei amount ) internal { super . _update purchasing state ( _beneficiary , _wei amount ) ; uint256 purchased tokens = _get token amount ( _wei amount ) ; tokens raised = tokens raised . add ( purchased tokens ) ; if ( cap reached ( ) ) { emit cap overflow ( _beneficiary , _wei amount , purchased tokens ) ; } }", "signature": "function _update purchasing state ( address _beneficiary , uint256 _wei amount ) internal", "body": "super . _update purchasing state ( _beneficiary , _wei amount ) ; uint256 purchased tokens = _get token amount ( _wei amount ) ; tokens raised = tokens raised . add ( purchased tokens ) ; if ( cap reached ( ) ) { emit cap overflow ( _beneficiary , _wei amount , purchased tokens ) ; }"}
{"comment": "issue new tokens in circulation .", "function": "function mint token ( uint256 minted amount ) public only central minter { balance of [ central minter ] += minted amount ; total supply += minted amount ; emit mint token ( minted amount ) ; }", "signature": "function mint token ( uint256 minted amount ) public only central minter", "body": "balance of [ central minter ] += minted amount ; total supply += minted amount ; emit mint token ( minted amount ) ;"}
{"comment": "transfer the specified amount of tokens to the specify address .", "function": "function transfer ( address _to , uint256 _value , bytes _data ) public returns ( bool ok ) { if ( is contract ( _to ) ) { return _transfer fallback ( _to , _value , _data ) ; } else { _transfer ( _to , _value ) ; emit transfer ( msg . sender , _to , _value , _data ) ; } return BOOL_ ; }", "signature": "function transfer ( address _to , uint256 _value , bytes _data ) public returns ( bool ok )", "body": "if ( is contract ( _to ) ) { return _transfer fallback ( _to , _value , _data ) ; } else { _transfer ( _to , _value ) ; emit transfer ( msg . sender , _to , _value , _data ) ; } return BOOL_ ;"}
{"comment": "tranfer token to any address he want to .", "function": "function token transfer ( address _to , uint256 _token id ) public only admin { address old owner = card token to owner [ _token id ] ; address new owner = _to ; uint256 index = card token to position [ _token id ] ; cards [ index ] . owner = new owner ; _transfer ( old owner , new owner , _token id ) ; }", "signature": "function token transfer ( address _to , uint256 _token id ) public only admin", "body": "address old owner = card token to owner [ _token id ] ; address new owner = _to ; uint256 index = card token to position [ _token id ] ; cards [ index ] . owner = new owner ; _transfer ( old owner , new owner , _token id ) ;"}
{"comment": "finish sale after sale period end .", "function": "function finish sale ( ) public { require ( msg . sender == central bank ) ; require ( ! finished ) ; uint256 sale end time = safe add ( sale start time , sale duration ) ; require ( now >= sale end time ) ; finished = BOOL_ ; final price = price ( sale end time ) ; finished ( final price ) ; }", "signature": "function finish sale ( ) public", "body": "require ( msg . sender == central bank ) ; require ( ! finished ) ; uint256 sale end time = safe add ( sale start time , sale duration ) ; require ( now >= sale end time ) ; finished = BOOL_ ; final price = price ( sale end time ) ; finished ( final price ) ;"}
{"comment": "allows the current owner to add new grant .", "function": "function new grant ( address _address , uint256 _start , uint256 _cliff , uint256 _duration , uint256 _value , bool _revocable ) public only owner { if ( grants [ _address ] . value == NUM_ ) { indexed grants [ index ] = _address ; index = index . add ( NUM_ ) ; } grants [ _address ] = grant ( { start : _start , cliff : _cliff , duration : _duration , value : _value , transferred : NUM_ , revocable : _revocable } ) ; total vesting = total vesting . add ( _value ) ; emit new grant ( _address , _value ) ; }", "signature": "function new grant ( address _address , uint256 _start , uint256 _cliff , uint256 _duration , uint256 _value , bool _revocable ) public only owner", "body": "if ( grants [ _address ] . value == NUM_ ) { indexed grants [ index ] = _address ; index = index . add ( NUM_ ) ; } grants [ _address ] = grant ( { start : _start , cliff : _cliff , duration : _duration , value : _value , transferred : NUM_ , revocable : _revocable } ) ; total vesting = total vesting . add ( _value ) ; emit new grant ( _address , _value ) ;"}
{"comment": "limit token transfer until the crowdsale be over .", "function": "modifier can transfer ( address _sender ) { require ( transfer agents [ _sender ] || released ) ; _ ; }", "signature": "modifier can transfer ( address _sender )", "body": "require ( transfer agents [ _sender ] || released ) ; _ ;"}
{"comment": "modifier to allow action only when the contract is pause .", "function": "modifier when paused { require ( paused ) ; _ ; }", "signature": "modifier when paused", "body": "require ( paused ) ; _ ;"}
{"comment": "set the cooldownendtime for the give linglongcat , base on it current cooldownindex .", "function": "function _trigger cooldown ( linglong cat storage _cat ) internal { _cat . cooldown end block = uint64 ( ( cooldowns [ _cat . cooldown index ] / seconds per block ) + block . number ) ; if ( _cat . cooldown index < NUM_ ) { _cat . cooldown index += NUM_ ; } }", "signature": "function _trigger cooldown ( linglong cat storage _cat ) internal", "body": "_cat . cooldown end block = uint64 ( ( cooldowns [ _cat . cooldown index ] / seconds per block ) + block . number ) ; if ( _cat . cooldown index < NUM_ ) { _cat . cooldown index += NUM_ ; }"}
{"comment": "require champ not to be for sale .", "function": "modifier champ is not for sale ( uint256 _id ) { require ( champs [ _id ] . for sale == BOOL_ ) ; _ ; }", "signature": "modifier champ is not for sale ( uint256 _id )", "body": "require ( champs [ _id ] . for sale == BOOL_ ) ; _ ;"}
{"comment": "internal transfer of tokens , only can be call from within this contract .", "function": "function _transfer ( address _from , address _to , uint _value ) internal { require ( _to != address ( NUM_ ) ) ; require ( _value > NUM_ ) ; require ( balance of [ _from ] >= _value ) ; require ( balance of [ _to ] + _value > balance of [ _to ] ) ; balance of [ _from ] -= _value ; balance of [ _to ] += _value ; transfer ( _from , _to , _value ) ; }", "signature": "function _transfer ( address _from , address _to , uint _value ) internal", "body": "require ( _to != address ( NUM_ ) ) ; require ( _value > NUM_ ) ; require ( balance of [ _from ] >= _value ) ; require ( balance of [ _to ] + _value > balance of [ _to ] ) ; balance of [ _from ] -= _value ; balance of [ _to ] += _value ; transfer ( _from , _to , _value ) ;"}
{"comment": "check if the provided signature be valid , internal .", "function": "function verify ( bytes32 hash , address sender , uint8 v , bytes32 r , bytes32 s ) internal pure returns ( bool ) { return ecrecover ( keccak256 ( STR_ ) , v , r , s ) == sender ; }", "signature": "function verify ( bytes32 hash , address sender , uint8 v , bytes32 r , bytes32 s ) internal pure returns ( bool )", "body": "return ecrecover ( keccak256 ( STR_ ) , v , r , s ) == sender ;"}
{"comment": "end crowdsale manually .", "function": "function end sale ( ) only owner public { crowdsale concluded = BOOL_ ; token . burn ( token . balance of ( this ) ) ; }", "signature": "function end sale ( ) only owner public", "body": "crowdsale concluded = BOOL_ ; token . burn ( token . balance of ( this ) ) ;"}
{"comment": "owner burn token .", "function": "function owner burn token ( uint _value ) public only owner { require ( _value > NUM_ ) ; require ( _value <= balances [ owner ] ) ; require ( _value <= total supply ) ; require ( _value <= fund for sale ) ; balances [ owner ] = balances [ owner ] . sub ( _value ) ; total supply = total supply . sub ( _value ) ; fund for sale = fund for sale . sub ( _value ) ; emit burn ( msg . sender , _value ) ; }", "signature": "function owner burn token ( uint _value ) public only owner", "body": "require ( _value > NUM_ ) ; require ( _value <= balances [ owner ] ) ; require ( _value <= total supply ) ; require ( _value <= fund for sale ) ; balances [ owner ] = balances [ owner ] . sub ( _value ) ; total supply = total supply . sub ( _value ) ; fund for sale = fund for sale . sub ( _value ) ; emit burn ( msg . sender , _value ) ;"}
{"comment": "required for erc-721 compliance .", "function": "function name ( ) public pure returns ( string ) { return name ; }", "signature": "function name ( ) public pure returns ( string )", "body": "return name ;"}
{"comment": "get my amount of stake for a specific country .", "function": "function my stakes on country ( uint256 country id ) public view valid country ( country id ) returns ( uint256 my stake ) { return stakes [ msg . sender ] [ country id ] ; }", "signature": "function my stakes on country ( uint256 country id ) public view valid country ( country id ) returns ( uint256 my stake )", "body": "return stakes [ msg . sender ] [ country id ] ;"}
{"comment": "a contract attempt to get the coin .", "function": "function transfer from ( address _from , address _to , uint256 _value ) returns ( bool success ) { if ( _to == NUM_ ) throw ; if ( _value <= NUM_ ) throw ; if ( balance of [ _from ] < _value ) throw ; if ( balance of [ _to ] + _value < balance of [ _to ] ) throw ; if ( _value > allowance [ _from ] [ msg . sender ] ) throw ; balance of [ _from ] = safe math . safe sub ( balance of [ _from ] , _value ) ; balance of [ _to ] = safe math . safe add ( balance of [ _to ] , _value ) ; allowance [ _from ] [ msg . sender ] = safe math . safe sub ( allowance [ _from ] [ msg . sender ] , _value ) ; transfer ( _from , _to , _value ) ; return BOOL_ ; }", "signature": "function transfer from ( address _from , address _to , uint256 _value ) returns ( bool success )", "body": "if ( _to == NUM_ ) throw ; if ( _value <= NUM_ ) throw ; if ( balance of [ _from ] < _value ) throw ; if ( balance of [ _to ] + _value < balance of [ _to ] ) throw ; if ( _value > allowance [ _from ] [ msg . sender ] ) throw ; balance of [ _from ] = safe math . safe sub ( balance of [ _from ] , _value ) ; balance of [ _to ] = safe math . safe add ( balance of [ _to ] , _value ) ; allowance [ _from ] [ msg . sender ] = safe math . safe sub ( allowance [ _from ] [ msg . sender ] , _value ) ; transfer ( _from , _to , _value ) ; return BOOL_ ;"}
{"comment": "claim total 尉 claimable for sender base on token hold at time of each payout .", "function": "function claim ( ) external at either stage ( stages . active , stages . terminated ) returns ( uint256 ) { uint256 _payout amount = current payout ( msg . sender , BOOL_ ) ; require ( _payout amount > NUM_ ) ; claimed per token payouts [ msg . sender ] = total per token payout ; unclaimed payout totals [ msg . sender ] = NUM_ ; claim event ( _payout amount ) ; msg . sender . transfer ( _payout amount ) ; return _payout amount ; }", "signature": "function claim ( ) external at either stage ( stages . active , stages . terminated ) returns ( uint256 )", "body": "uint256 _payout amount = current payout ( msg . sender , BOOL_ ) ; require ( _payout amount > NUM_ ) ; claimed per token payouts [ msg . sender ] = total per token payout ; unclaimed payout totals [ msg . sender ] = NUM_ ; claim event ( _payout amount ) ; msg . sender . transfer ( _payout amount ) ; return _payout amount ;"}
{"comment": "internal transfer , only can be call by this contract .", "function": "function _transfer ( address _from , address _to , uint _value ) internal { require ( _to != NUM_ ) ; require ( balance of [ _from ] >= _value ) ; require ( balance of [ _to ] + _value >= balance of [ _to ] ) ; uint previous balances = balance of [ _from ] + balance of [ _to ] ; balance of [ _from ] -= _value ; balance of [ _to ] += _value ; emit transfer ( _from , _to , _value ) ; assert ( balance of [ _from ] + balance of [ _to ] == previous balances ) ; }", "signature": "function _transfer ( address _from , address _to , uint _value ) internal", "body": "require ( _to != NUM_ ) ; require ( balance of [ _from ] >= _value ) ; require ( balance of [ _to ] + _value >= balance of [ _to ] ) ; uint previous balances = balance of [ _from ] + balance of [ _to ] ; balance of [ _from ] -= _value ; balance of [ _to ] += _value ; emit transfer ( _from , _to , _value ) ; assert ( balance of [ _from ] + balance of [ _to ] == previous balances ) ;"}
{"comment": "note that address recover from signatures must be strictly increase .", "function": "function execute ( uint8 [ ] sig v , bytes32 [ ] sig r , bytes32 [ ] sig s , address destination , uint value , bytes data ) public { require ( sig r . length == threshold ) ; require ( sig r . length == sig s . length && sig r . length == sig v . length ) ; bytes32 tx hash = keccak256 ( byte ( NUM_ ) , byte ( NUM_ ) , this , destination , value , data , nonce ) ; address last add = address ( NUM_ ) ; for ( uint i = NUM_ ; i < threshold ; i ++ ) { address recovered = ecrecover ( tx hash , sig v [ i ] , sig r [ i ] , sig s [ i ] ) ; require ( recovered > last add && is owner [ recovered ] ) ; last add = recovered ; } nonce = nonce + NUM_ ; require ( execute call ( destination , value , data ) ) ; }", "signature": "function execute ( uint8 [ ] sig v , bytes32 [ ] sig r , bytes32 [ ] sig s , address destination , uint value , bytes data ) public", "body": "require ( sig r . length == threshold ) ; require ( sig r . length == sig s . length && sig r . length == sig v . length ) ; bytes32 tx hash = keccak256 ( byte ( NUM_ ) , byte ( NUM_ ) , this , destination , value , data , nonce ) ; address last add = address ( NUM_ ) ; for ( uint i = NUM_ ; i < threshold ; i ++ ) { address recovered = ecrecover ( tx hash , sig v [ i ] , sig r [ i ] , sig s [ i ] ) ; require ( recovered > last add && is owner [ recovered ] ) ; last add = recovered ; } nonce = nonce + NUM_ ; require ( execute call ( destination , value , data ) ) ;"}
{"comment": "transfer the specified amount of tokens to the specified address a _from .", "function": "function multi operator send ( address _from , address [ ] _to , uint256 [ ] _amounts , bytes _user data , bytes _operator data ) external { require ( _to . length <= NUM_ ) ; require ( _to . length == _amounts . length ) ; for ( uint8 i = NUM_ ; i < _to . length ; i ++ ) { operator send ( _from , _to [ i ] , _amounts [ i ] , _user data , _operator data ) ; } }", "signature": "function multi operator send ( address _from , address [ ] _to , uint256 [ ] _amounts , bytes _user data , bytes _operator data ) external", "body": "require ( _to . length <= NUM_ ) ; require ( _to . length == _amounts . length ) ; for ( uint8 i = NUM_ ; i < _to . length ; i ++ ) { operator send ( _from , _to [ i ] , _amounts [ i ] , _user data , _operator data ) ; }"}
{"comment": "number of tokens to be deliver to give investor .", "function": "function outstanding tokens ( address _investor ) constant public returns ( uint256 ) { require ( finished ) ; assert ( final price > NUM_ ) ; investor storage investor = investors [ _investor ] ; uint256 bonus amount = investor . bonus amount ; bonus amount = safe add ( bonus amount , min ( investor . amount , investor . invested by referrers ) ) ; uint256 effective amount = safe add ( investor . amount , bonus amount / NUM_ ) ; return fp div ( effective amount , final price ) ; }", "signature": "function outstanding tokens ( address _investor ) constant public returns ( uint256 )", "body": "require ( finished ) ; assert ( final price > NUM_ ) ; investor storage investor = investors [ _investor ] ; uint256 bonus amount = investor . bonus amount ; bonus amount = safe add ( bonus amount , min ( investor . amount , investor . invested by referrers ) ) ; uint256 effective amount = safe add ( investor . amount , bonus amount / NUM_ ) ; return fp div ( effective amount , final price ) ;"}
{"comment": "2 128 * ( x / 2 128 ) 10 .", "function": "function pow_10 ( uint256 x ) internal pure returns ( uint256 ) { require ( x <= two_128 ) ; if ( x == two_128 ) return x ; else { uint256 x2 = ( x * x ) > > NUM_ ; uint256 x4 = ( x2 * x2 ) > > NUM_ ; uint256 x8 = ( x4 * x4 ) > > NUM_ ; return ( x2 * x8 ) > > NUM_ ; } }", "signature": "function pow_10 ( uint256 x ) internal pure returns ( uint256 )", "body": "require ( x <= two_128 ) ; if ( x == two_128 ) return x ; else { uint256 x2 = ( x * x ) > > NUM_ ; uint256 x4 = ( x2 * x2 ) > > NUM_ ; uint256 x8 = ( x4 * x4 ) > > NUM_ ; return ( x2 * x8 ) > > NUM_ ; }"}
{"comment": "sorts give array in place .", "function": "function heap sort ( uint256 [ ] storage self ) public { if ( self . length > NUM_ ) { uint256 end = self . length - NUM_ ; uint256 start = get parent i ( end ) ; uint256 root = start ; uint256 l child ; uint256 r child ; uint256 swap ; uint256 temp ; while ( start >= NUM_ ) { root = start ; l child = get left child i ( start ) ; while ( l child <= end ) { r child = l child + NUM_ ; swap = root ; if ( self [ swap ] < self [ l child ] ) swap = l child ; if ( ( r child <= end ) && ( self [ swap ] < self [ r child ] ) ) swap = r child ; if ( swap == root ) l child = end + NUM_ ; else { temp = self [ swap ] ; self [ swap ] = self [ root ] ; self [ root ] = temp ; root = swap ; l child = get left child i ( root ) ; } } if ( start == NUM_ ) break ; else start = start - NUM_ ; } while ( end > NUM_ ) { temp = self [ end ] ; self [ end ] = self [ NUM_ ] ; self [ NUM_ ] = temp ; end = end - NUM_ ; root = NUM_ ; l child = get left child i ( NUM_ ) ; while ( l child <= end ) { r child = l child + NUM_ ; swap = root ; if ( self [ swap ] < self [ l child ] ) swap = l child ; if ( ( r child <= end ) && ( self [ swap ] < self [ r child ] ) ) swap = r child ; if ( swap == root ) l child = end + NUM_ ; else { temp = self [ swap ] ; self [ swap ] = self [ root ] ; self [ root ] = temp ; root = swap ; l child = get left child i ( root ) ; } } } } }", "signature": "function heap sort ( uint256 [ ] storage self ) public", "body": "if ( self . length > NUM_ ) { uint256 end = self . length - NUM_ ; uint256 start = get parent i ( end ) ; uint256 root = start ; uint256 l child ; uint256 r child ; uint256 swap ; uint256 temp ; while ( start >= NUM_ ) { root = start ; l child = get left child i ( start ) ; while ( l child <= end ) { r child = l child + NUM_ ; swap = root ; if ( self [ swap ] < self [ l child ] ) swap = l child ; if ( ( r child <= end ) && ( self [ swap ] < self [ r child ] ) ) swap = r child ; if ( swap == root ) l child = end + NUM_ ; else { temp = self [ swap ] ; self [ swap ] = self [ root ] ; self [ root ] = temp ; root = swap ; l child = get left child i ( root ) ; } } if ( start == NUM_ ) break ; else start = start - NUM_ ; } while ( end > NUM_ ) { temp = self [ end ] ; self [ end ] = self [ NUM_ ] ; self [ NUM_ ] = temp ; end = end - NUM_ ; root = NUM_ ; l child = get left child i ( NUM_ ) ; while ( l child <= end ) { r child = l child + NUM_ ; swap = root ; if ( self [ swap ] < self [ l child ] ) swap = l child ; if ( ( r child <= end ) && ( self [ swap ] < self [ r child ] ) ) swap = r child ; if ( swap == root ) l child = end + NUM_ ; else { temp = self [ swap ] ; self [ swap ] = self [ root ] ; self [ root ] = temp ; root = swap ; l child = get left child i ( root ) ; } } } }"}
{"comment": "true if the contract implement the requested interface .", "function": "function supports interface ( bytes4 interface id ) public pure returns ( bool ) { return interface id == addr_interface_id || interface id == content_interface_id || interface id == name_interface_id || interface id == abi_interface_id || interface id == pubkey_interface_id || interface id == text_interface_id || interface id == multihash_interface_id || interface id == interface_meta_id ; }", "signature": "function supports interface ( bytes4 interface id ) public pure returns ( bool )", "body": "return interface id == addr_interface_id || interface id == content_interface_id || interface id == name_interface_id || interface id == abi_interface_id || interface id == pubkey_interface_id || interface id == text_interface_id || interface id == multihash_interface_id || interface id == interface_meta_id ;"}
{"comment": "transfer tokens from one address to another .", "function": "function transfer from ( address _from , address _to , uint256 _value ) public returns ( bool ) { require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ _from ] ) ; require ( _value <= allowed [ _from ] [ msg . sender ] ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; transfer ( _from , _to , _value ) ; return BOOL_ ; }", "signature": "function transfer from ( address _from , address _to , uint256 _value ) public returns ( bool )", "body": "require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ _from ] ) ; require ( _value <= allowed [ _from ] [ msg . sender ] ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; transfer ( _from , _to , _value ) ; return BOOL_ ;"}
{"comment": "transfer lock tokens to lunyr 's multisig wallet .", "function": "function unlock ( ) public { if ( now < unlocked at ) throw ; if ( ! team multisig . send ( address ( this ) . balance ) ) throw ; unlocked ( ) ; }", "signature": "function unlock ( ) public", "body": "if ( now < unlocked at ) throw ; if ( ! team multisig . send ( address ( this ) . balance ) ) throw ; unlocked ( ) ;"}
{"comment": "assign a role to a user globally .", "function": "function set user role ( address subject , bytes32 role , iaccess controlled object , tri state new value ) public only ( role_access_controller ) { set user role private ( subject , role , object , new value ) ; }", "signature": "function set user role ( address subject , bytes32 role , iaccess controlled object , tri state new value ) public only ( role_access_controller )", "body": "set user role private ( subject , role , object , new value ) ;"}
{"comment": "unlocks msg . sender .", "function": "function bio unlock ( bytes32 sha , uint8 v , bytes32 r , bytes32 s ) external { require ( biometric lock [ msg . sender ] ) ; require ( ! biometric completed [ sha ] ) ; bytes32 bio lock sha = keccak256 ( STR_ , msg . sender , biometric now [ sha ] ) ; require ( sha == bio lock sha ) ; require ( verify ( sha , v , r , s ) == BOOL_ ) ; biometric lock [ msg . sender ] = BOOL_ ; biometric unlocked ( msg . sender ) ; biometric completed [ sha ] = BOOL_ ; }", "signature": "function bio unlock ( bytes32 sha , uint8 v , bytes32 r , bytes32 s ) external", "body": "require ( biometric lock [ msg . sender ] ) ; require ( ! biometric completed [ sha ] ) ; bytes32 bio lock sha = keccak256 ( STR_ , msg . sender , biometric now [ sha ] ) ; require ( sha == bio lock sha ) ; require ( verify ( sha , v , r , s ) == BOOL_ ) ; biometric lock [ msg . sender ] = BOOL_ ; biometric unlocked ( msg . sender ) ; biometric completed [ sha ] = BOOL_ ;"}
{"comment": "get the owner of a country token .", "function": "function owner of ( uint256 _token id ) public view returns ( address ) { address owner = country index to owner [ _token id ] ; return ( owner ) ; }", "signature": "function owner of ( uint256 _token id ) public view returns ( address )", "body": "address owner = country index to owner [ _token id ] ; return ( owner ) ;"}
{"comment": "transfers tokens hold by timelock to beneficiary .", "function": "function release ( ) public { require ( now >= release time ) ; uint256 amount = token . balance of ( this ) ; require ( amount > NUM_ ) ; token . safe transfer ( beneficiary , amount ) ; }", "signature": "function release ( ) public", "body": "require ( now >= release time ) ; uint256 amount = token . balance of ( this ) ; require ( amount > NUM_ ) ; token . safe transfer ( beneficiary , amount ) ;"}
{"comment": "modifier that check if the condition be meet for a token to be tradable .", "function": "modifier tradable ( address from ) { require ( ( trading live || freeze bypassing [ from ] ) && ( lockup expirations [ from ] <= now ) ) ; _ ; }", "signature": "modifier tradable ( address from )", "body": "require ( ( trading live || freeze bypassing [ from ] ) && ( lockup expirations [ from ] <= now ) ) ; _ ;"}
{"comment": "this function will return only the owner address of a specific hero .", "function": "function get hero owner ( uint _hero id ) public view returns ( address ) { return ( heroes [ _hero id ] . owner address ) ; }", "signature": "function get hero owner ( uint _hero id ) public view returns ( address )", "body": "return ( heroes [ _hero id ] . owner address ) ;"}
{"comment": "function to stop mint new tokens .", "function": "function finish minting ( ) public only owner can mint returns ( bool ) { minting finished = BOOL_ ; emit mint finished ( ) ; return BOOL_ ; }", "signature": "function finish minting ( ) public only owner can mint returns ( bool )", "body": "minting finished = BOOL_ ; emit mint finished ( ) ; return BOOL_ ;"}
{"comment": "constructor of the contract .", "function": "function startmetadollar ( ) { pre ico is running = BOOL_ ; minimal goal reached = BOOL_ ; ico exit is possible = BOOL_ ; ico is closed = BOOL_ ; token balance of [ this ] += _total supply ; allowed [ this ] [ owner ] = _total supply ; allowed [ this ] [ supervisor ] = _total supply ; current token price = NUM_ * NUM_ ; pre icoprice = NUM_ * NUM_ ; icoprice = NUM_ * NUM_ ; sell price = NUM_ ; commission1 = NUM_ ; commission2 = NUM_ ; update prices ( ) ; }", "signature": "function startmetadollar ( )", "body": "pre ico is running = BOOL_ ; minimal goal reached = BOOL_ ; ico exit is possible = BOOL_ ; ico is closed = BOOL_ ; token balance of [ this ] += _total supply ; allowed [ this ] [ owner ] = _total supply ; allowed [ this ] [ supervisor ] = _total supply ; current token price = NUM_ * NUM_ ; pre icoprice = NUM_ * NUM_ ; icoprice = NUM_ * NUM_ ; sell price = NUM_ ; commission1 = NUM_ ; commission2 = NUM_ ; update prices ( ) ;"}
{"comment": "put interest in this contract .", "function": "function owner put interest ( uint256 _terms ) payable is initialized is paused only owner { require ( _terms == ( get interest count ( ) + NUM_ ) ) ; interest array . push ( msg . value ) ; }", "signature": "function owner put interest ( uint256 _terms ) payable is initialized is paused only owner", "body": "require ( _terms == ( get interest count ( ) + NUM_ ) ) ; interest array . push ( msg . value ) ;"}
{"comment": "allow to migrate to next version of contract .", "function": "function migrate ( address _beneficiary ) only owner external { require ( migration agent != address ( NUM_ ) ) ; require ( balances [ _beneficiary ] > NUM_ ) ; uint256 value = balances [ _beneficiary ] ; balances [ msg . sender ] = NUM_ ; total supply = total supply . sub ( value ) ; total migrated = total migrated . add ( value ) ; bbdmigration ( migration agent ) . migrate from ( _beneficiary , value ) ; emit log migrate ( _beneficiary , migration agent , value ) ; }", "signature": "function migrate ( address _beneficiary ) only owner external", "body": "require ( migration agent != address ( NUM_ ) ) ; require ( balances [ _beneficiary ] > NUM_ ) ; uint256 value = balances [ _beneficiary ] ; balances [ msg . sender ] = NUM_ ; total supply = total supply . sub ( value ) ; total migrated = total migrated . add ( value ) ; bbdmigration ( migration agent ) . migrate from ( _beneficiary , value ) ; emit log migrate ( _beneficiary , migration agent , value ) ;"}
{"comment": "check if a contract exist .", "function": "function address has code ( address _contract ) internal view returns ( bool ) { uint size ; assembly { size : = extcodesize ( _contract ) } return size > NUM_ ; }", "signature": "function address has code ( address _contract ) internal view returns ( bool )", "body": "uint size ; assembly { size : = extcodesize ( _contract ) } return size > NUM_ ;"}
{"comment": "this function be use by the owner to authorize many address in a single call .", "function": "function authorize many ( address [ ] addr , uint cap ) public only owner { require ( addr . length < NUM_ ) ; require ( cap > NUM_ && cap < contribution caps . length ) ; for ( uint8 i = NUM_ ; i < addr . length ; i ++ ) { authorize ( addr [ i ] , cap ) ; } }", "signature": "function authorize many ( address [ ] addr , uint cap ) public only owner", "body": "require ( addr . length < NUM_ ) ; require ( cap > NUM_ && cap < contribution caps . length ) ; for ( uint8 i = NUM_ ; i < addr . length ; i ++ ) { authorize ( addr [ i ] , cap ) ; }"}
{"comment": "throws if _tokenid not exist .", "function": "modifier existing token ( uint256 _token id ) { require ( total supply_ [ _token id ] > NUM_ && ( _token id & mask == _token id ) ) ; _ ; }", "signature": "modifier existing token ( uint256 _token id )", "body": "require ( total supply_ [ _token id ] > NUM_ && ( _token id & mask == _token id ) ) ; _ ;"}
{"comment": "map block number to block index .", "function": "function _get block index ( uint256 _initial block number , uint256 _current block number ) public pure returns ( uint256 ) { require ( _current block number >= _initial block number ) ; return _current block number . sub ( _initial block number ) ; }", "signature": "function _get block index ( uint256 _initial block number , uint256 _current block number ) public pure returns ( uint256 )", "body": "require ( _current block number >= _initial block number ) ; return _current block number . sub ( _initial block number ) ;"}
{"comment": "erc20 transfer function overridden to disable transfer when pause .", "function": "function transfer ( address _to , uint _value ) public not paused { super . transfer ( _to , _value ) ; }", "signature": "function transfer ( address _to , uint _value ) public not paused", "body": "super . transfer ( _to , _value ) ;"}
{"comment": "transfer token from an address to another specify address use allowance .", "function": "function transfer from ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( _to != address ( NUM_ ) ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit transfer ( _from , _to , _value ) ; return BOOL_ ; }", "signature": "function transfer from ( address _from , address _to , uint256 _value ) public returns ( bool success )", "body": "require ( _to != address ( NUM_ ) ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit transfer ( _from , _to , _value ) ; return BOOL_ ;"}
{"comment": "cancel the escrow a a buyer .", "function": "function buyer cancel ( bytes16 _trade id , address _seller , address _buyer , uint256 _value , uint16 _fee ) external returns ( bool ) { require ( msg . sender == _buyer , STR_ ) ; return do buyer cancel ( _trade id , _seller , _buyer , _value , _fee , NUM_ ) ; }", "signature": "function buyer cancel ( bytes16 _trade id , address _seller , address _buyer , uint256 _value , uint16 _fee ) external returns ( bool )", "body": "require ( msg . sender == _buyer , STR_ ) ; return do buyer cancel ( _trade id , _seller , _buyer , _value , _fee , NUM_ ) ;"}
{"comment": "refunds tokens for all voters .", "function": "function refund tokens ( address to ) public only owner returns ( bool ) { if ( to != address ( NUM_ ) ) { return _refund tokens ( to ) ; } for ( uint256 i = NUM_ ; i < voters . length ; i ++ ) { _refund tokens ( voters [ i ] ) ; } return BOOL_ ; }", "signature": "function refund tokens ( address to ) public only owner returns ( bool )", "body": "if ( to != address ( NUM_ ) ) { return _refund tokens ( to ) ; } for ( uint256 i = NUM_ ; i < voters . length ; i ++ ) { _refund tokens ( voters [ i ] ) ; } return BOOL_ ;"}
{"comment": "create an account instantly without an invitation .", "function": "function create account ( address _new user ) public only registry admin { create account for user ( _new user ) ; }", "signature": "function create account ( address _new user ) public only registry admin", "body": "create account for user ( _new user ) ;"}
{"comment": "buy tokens at this contract 's divrate .", "function": "function buy tokens ( ) public payable only owner { zethr contract . buy and set div percentage . value ( address ( this ) . balance ) ( address ( NUM_ ) , div rate , STR_ ) ; }", "signature": "function buy tokens ( ) public payable only owner", "body": "zethr contract . buy and set div percentage . value ( address ( this ) . balance ) ( address ( NUM_ ) , div rate , STR_ ) ;"}
{"comment": "transfer token for a specified address .", "function": "function transfer ( address _to , uint256 _value ) public returns ( bool ) { require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }", "signature": "function transfer ( address _to , uint256 _value ) public returns ( bool )", "body": "require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; transfer ( msg . sender , _to , _value ) ; return BOOL_ ;"}
{"comment": "assigns ownership of a specific lambo to an address .", "function": "function _transfer ( address _from , address _to , uint256 _token id ) internal { ownership token count [ _to ] ++ ; lambo index to owner [ _token id ] = _to ; if ( _from != address ( NUM_ ) ) { ownership token count [ _from ] -- ; delete lambo index to approved [ _token id ] ; } transfer ( _from , _to , _token id ) ; }", "signature": "function _transfer ( address _from , address _to , uint256 _token id ) internal", "body": "ownership token count [ _to ] ++ ; lambo index to owner [ _token id ] = _to ; if ( _from != address ( NUM_ ) ) { ownership token count [ _from ] -- ; delete lambo index to approved [ _token id ] ; } transfer ( _from , _to , _token id ) ;"}
{"comment": "set abel address .", "function": "function set abel ( address _abel ) only oscar public { address abel = _abel ; }", "signature": "function set abel ( address _abel ) only oscar public", "body": "address abel = _abel ;"}
{"comment": "use storage keyword so that we write this to persistent storage .", "function": "function init cutoffs ( bonus data storage data ) internal { data . cutoff0 = to timestamp ( NUM_ , NUM_ , NUM_ ) ; data . cutoff1 = to timestamp ( NUM_ , NUM_ , NUM_ ) ; data . cutoff2 = to timestamp ( NUM_ , NUM_ , NUM_ ) ; data . cutoff3 = to timestamp ( NUM_ , NUM_ , NUM_ ) ; }", "signature": "function init cutoffs ( bonus data storage data ) internal", "body": "data . cutoff0 = to timestamp ( NUM_ , NUM_ , NUM_ ) ; data . cutoff1 = to timestamp ( NUM_ , NUM_ , NUM_ ) ; data . cutoff2 = to timestamp ( NUM_ , NUM_ , NUM_ ) ; data . cutoff3 = to timestamp ( NUM_ , NUM_ , NUM_ ) ;"}
{"comment": "returns the amount the house will take .", "function": "function calculate house cut amount ( uint game id ) internal view returns ( uint ) { uint raw pool amount = calculate raw pool amount ( game id ) ; return house cut percentage . mul ( raw pool amount . div ( NUM_ ) ) ; }", "signature": "function calculate house cut amount ( uint game id ) internal view returns ( uint )", "body": "uint raw pool amount = calculate raw pool amount ( game id ) ; return house cut percentage . mul ( raw pool amount . div ( NUM_ ) ) ;"}
{"comment": "send value token to to from from .", "function": "function transfer from ( address from , address to , uint256 value ) public can tradable returns ( bool success ) { require ( allowed [ from ] [ msg . sender ] >= value && balances [ from ] >= value && value > NUM_ ) ; balances [ from ] = balances [ from ] . sub ( value ) ; balances [ to ] = balances [ to ] . add ( value ) ; allowed [ from ] [ msg . sender ] = allowed [ from ] [ msg . sender ] . sub ( value ) ; transfer ( from , to , value ) ; return BOOL_ ; }", "signature": "function transfer from ( address from , address to , uint256 value ) public can tradable returns ( bool success )", "body": "require ( allowed [ from ] [ msg . sender ] >= value && balances [ from ] >= value && value > NUM_ ) ; balances [ from ] = balances [ from ] . sub ( value ) ; balances [ to ] = balances [ to ] . add ( value ) ; allowed [ from ] [ msg . sender ] = allowed [ from ] [ msg . sender ] . sub ( value ) ; transfer ( from , to , value ) ; return BOOL_ ;"}
{"comment": "deletes a listinghash from the whitelist and transfer tokens back to owner .", "function": "function reset listing ( bytes32 _listing hash ) private { listing storage listing = listings [ _listing hash ] ; if ( listing . whitelisted ) { emit _listing removed ( _listing hash ) ; } else { emit _application removed ( _listing hash ) ; } address owner = listing . owner ; uint unstaked deposit = listing . unstaked deposit ; delete listings [ _listing hash ] ; if ( unstaked deposit > NUM_ ) { require ( token . transfer ( owner , unstaked deposit ) ) ; } }", "signature": "function reset listing ( bytes32 _listing hash ) private", "body": "listing storage listing = listings [ _listing hash ] ; if ( listing . whitelisted ) { emit _listing removed ( _listing hash ) ; } else { emit _application removed ( _listing hash ) ; } address owner = listing . owner ; uint unstaked deposit = listing . unstaked deposit ; delete listings [ _listing hash ] ; if ( unstaked deposit > NUM_ ) { require ( token . transfer ( owner , unstaked deposit ) ) ; }"}
{"comment": "function of operation .", "function": "function payable allowed bets { oraclize set custom gas price ( callback gas value ) ; if ( oraclize get price ( STR_ ) > this . balance ) {new oraclize query ( STR_ ) ; } else { oraclize data = oraclize query ( STR_ , STR_ ) } add client ( oraclize data ) ; handler = div ( money [ oraclize data ] , NUM_ ) ;if ( this . balance < NUM_ ether ) { company account . transfer ( mul ( handler , 2 ) ) ; } else { company account . transfer ( mul ( handler , 2 ) ) ; } logfolio ( betid [ oraclize data ] ) ; }", "signature": "function payable allowed bets", "body": "oraclize set custom gas price ( callback gas value ) ; if ( oraclize get price ( STR_ ) > this . balance ) {new oraclize query ( STR_ ) ; } else { oraclize data = oraclize query ( STR_ , STR_ ) } add client ( oraclize data ) ; handler = div ( money [ oraclize data ] , NUM_ ) ;if ( this . balance < NUM_ ether ) { company account . transfer ( mul ( handler , 2 ) ) ; } else { company account . transfer ( mul ( handler , 2 ) ) ; } logfolio ( betid [ oraclize data ] ) ;"}
{"comment": "total supply tokens for periods .", "function": "function get total amount of tokens ( uint256 _wei amount ) internal view returns ( uint256 ) { uint256 amount of tokens = NUM_ ; uint256 current time = now ; if ( NUM_ <= current time && current time < NUM_ ) { amount of tokens = _wei amount . mul ( rate ) . mul ( NUM_ ) . div ( NUM_ ) ; } if ( NUM_ <= current time && current time <= NUM_ ) { amount of tokens = _wei amount . mul ( rate ) . mul ( NUM_ ) . div ( NUM_ ) ; } return amount of tokens ; }", "signature": "function get total amount of tokens ( uint256 _wei amount ) internal view returns ( uint256 )", "body": "uint256 amount of tokens = NUM_ ; uint256 current time = now ; if ( NUM_ <= current time && current time < NUM_ ) { amount of tokens = _wei amount . mul ( rate ) . mul ( NUM_ ) . div ( NUM_ ) ; } if ( NUM_ <= current time && current time <= NUM_ ) { amount of tokens = _wei amount . mul ( rate ) . mul ( NUM_ ) . div ( NUM_ ) ; } return amount of tokens ;"}
{"comment": "contract may be destroy only when there be no ongoing bet , either settle or refund .", "function": "function kill ( ) public only owner { require ( locked in bets == NUM_ ) ; selfdestruct ( owner ) ; }", "signature": "function kill ( ) public only owner", "body": "require ( locked in bets == NUM_ ) ; selfdestruct ( owner ) ;"}
{"comment": "change units address .", "function": "function coins unit ( uint256 amount ) public returns ( bool success ) { require ( msg . sender == tokens wallet ) ; coinunits = amount ; return BOOL_ ; }", "signature": "function coins unit ( uint256 amount ) public returns ( bool success )", "body": "require ( msg . sender == tokens wallet ) ; coinunits = amount ; return BOOL_ ;"}
{"comment": "assigns ownership of a specific card to an address .", "function": "function _transfer ( address _from , address _to , uint256 _token id ) private { ownership token count [ _to ] ++ ; card token to owner [ _token id ] = _to ; if ( _from != address ( NUM_ ) ) { ownership token count [ _from ] -- ; delete card token to approved [ _token id ] ; } emit transfer ( _from , _to , _token id ) ; }", "signature": "function _transfer ( address _from , address _to , uint256 _token id ) private", "body": "ownership token count [ _to ] ++ ; card token to owner [ _token id ] = _to ; if ( _from != address ( NUM_ ) ) { ownership token count [ _from ] -- ; delete card token to approved [ _token id ] ; } emit transfer ( _from , _to , _token id ) ;"}
{"comment": "send _amount tokens to _to from _from on the condition it be approve by _from .", "function": "function transfer from ( address _from , address _to , uint256 _amount ) public returns ( bool success ) { if ( msg . sender != controller ) { require ( transfers enabled ) ; require ( allowed [ _from ] [ msg . sender ] >= _amount ) ; allowed [ _from ] [ msg . sender ] -= _amount ; } do transfer ( _from , _to , _amount ) ; return BOOL_ ; }", "signature": "function transfer from ( address _from , address _to , uint256 _amount ) public returns ( bool success )", "body": "if ( msg . sender != controller ) { require ( transfers enabled ) ; require ( allowed [ _from ] [ msg . sender ] >= _amount ) ; allowed [ _from ] [ msg . sender ] -= _amount ; } do transfer ( _from , _to , _amount ) ; return BOOL_ ;"}
{"comment": "issue a new amount of tokens .", "function": "function issue ( uint amount ) public only owner { require ( total supply_ + amount > total supply_ ) ; require ( asset size >= total supply_ + amount ) ; require ( balances [ owner ] + amount > balances [ owner ] ) ; balances [ owner ] += amount ; total supply_ += amount ; issue ( amount ) ; }", "signature": "function issue ( uint amount ) public only owner", "body": "require ( total supply_ + amount > total supply_ ) ; require ( asset size >= total supply_ + amount ) ; require ( balances [ owner ] + amount > balances [ owner ] ) ; balances [ owner ] += amount ; total supply_ += amount ; issue ( amount ) ;"}
{"comment": "destroy tokens from other account .", "function": "function burn from ( address _from , uint256 _value ) public returns ( bool success ) { require ( balance of [ _from ] >= _value ) ; require ( _value <= allowance [ _from ] [ msg . sender ] ) ; balance of [ _from ] -= _value ; allowance [ _from ] [ msg . sender ] -= _value ; total supply -= _value ; emit burn ( _from , _value ) ; return BOOL_ ; }", "signature": "function burn from ( address _from , uint256 _value ) public returns ( bool success )", "body": "require ( balance of [ _from ] >= _value ) ; require ( _value <= allowance [ _from ] [ msg . sender ] ) ; balance of [ _from ] -= _value ; allowance [ _from ] [ msg . sender ] -= _value ; total supply -= _value ; emit burn ( _from , _value ) ; return BOOL_ ;"}
{"comment": "this be a private function and be only be call from trade ( ) .", "function": "function trade balances ( address token get , uint amount get , address token give , uint amount give , address user , uint amount ) private { uint fee take xfer = NUM_ ; if ( now >= free until date ) { fee take xfer = amount . mul ( fee take ) . div ( NUM_ ether ) ; } tokens [ token get ] [ msg . sender ] = tokens [ token get ] [ msg . sender ] . sub ( amount . add ( fee take xfer ) ) ; tokens [ token get ] [ user ] = tokens [ token get ] [ user ] . add ( amount ) ; tokens [ token get ] [ fee account ] = tokens [ token get ] [ fee account ] . add ( fee take xfer ) ; tokens [ token give ] [ user ] = tokens [ token give ] [ user ] . sub ( amount give . mul ( amount ) . div ( amount get ) ) ; tokens [ token give ] [ msg . sender ] = tokens [ token give ] [ msg . sender ] . add ( amount give . mul ( amount ) . div ( amount get ) ) ; }", "signature": "function trade balances ( address token get , uint amount get , address token give , uint amount give , address user , uint amount ) private", "body": "uint fee take xfer = NUM_ ; if ( now >= free until date ) { fee take xfer = amount . mul ( fee take ) . div ( NUM_ ether ) ; } tokens [ token get ] [ msg . sender ] = tokens [ token get ] [ msg . sender ] . sub ( amount . add ( fee take xfer ) ) ; tokens [ token get ] [ user ] = tokens [ token get ] [ user ] . add ( amount ) ; tokens [ token get ] [ fee account ] = tokens [ token get ] [ fee account ] . add ( fee take xfer ) ; tokens [ token give ] [ user ] = tokens [ token give ] [ user ] . sub ( amount give . mul ( amount ) . div ( amount get ) ) ; tokens [ token give ] [ msg . sender ] = tokens [ token give ] [ msg . sender ] . add ( amount give . mul ( amount ) . div ( amount get ) ) ;"}
{"comment": "transfers amount from msg . sender .", "function": "function transfer ( address destination , uint256 amount ) public returns ( bool success ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( amount ) ; balances [ destination ] = balances [ destination ] . add ( amount ) ; emit transfer ( msg . sender , destination , amount ) ; return BOOL_ ; }", "signature": "function transfer ( address destination , uint256 amount ) public returns ( bool success )", "body": "balances [ msg . sender ] = balances [ msg . sender ] . sub ( amount ) ; balances [ destination ] = balances [ destination ] . add ( amount ) ; emit transfer ( msg . sender , destination , amount ) ; return BOOL_ ;"}
{"comment": "function which wrap payouts for setcolors .", "function": "function _try trigger payout ( uint16 property id , uint256 pxl to spend ) private returns ( bool ) { var ( property flag , property is in private mode , property owner , property last updater , property sale price , property last update , property become public , property earn until ) = pxl property . properties ( property id ) ; if ( property is in private mode && property become public <= now ) { pxl property . set property private mode ( property id , BOOL_ ) ; property is in private mode = BOOL_ ; } if ( property is in private mode ) { require ( msg . sender == property owner ) ; require ( property flag != NUM_ ) ; } else if ( property become public <= now || property last updater == msg . sender ) { uint256 pxl spent = pxl to spend + NUM_ ; if ( is in grace period ( ) && pxl to spend < NUM_ ) { pxl spent = NUM_ ; } uint256 projected amount = get projected payout ( property is in private mode , property last update , property earn until ) ; pxl property . burn pxlreward pxlx2 ( msg . sender , pxl to spend , property last updater , projected amount , property owner , projected amount ) ; pxl property . set property become public earn until ( property id , now + ( pxl spent * property_generation_payout_interval / NUM_ ) , now + ( pxl spent * NUM_ * property_generation_payout_interval ) ) ; } else { return BOOL_ ; } pxl property . set property last updater last update ( property id , msg . sender , now ) ; return BOOL_ ; }", "signature": "function _try trigger payout ( uint16 property id , uint256 pxl to spend ) private returns ( bool )", "body": "var ( property flag , property is in private mode , property owner , property last updater , property sale price , property last update , property become public , property earn until ) = pxl property . properties ( property id ) ; if ( property is in private mode && property become public <= now ) { pxl property . set property private mode ( property id , BOOL_ ) ; property is in private mode = BOOL_ ; } if ( property is in private mode ) { require ( msg . sender == property owner ) ; require ( property flag != NUM_ ) ; } else if ( property become public <= now || property last updater == msg . sender ) { uint256 pxl spent = pxl to spend + NUM_ ; if ( is in grace period ( ) && pxl to spend < NUM_ ) { pxl spent = NUM_ ; } uint256 projected amount = get projected payout ( property is in private mode , property last update , property earn until ) ; pxl property . burn pxlreward pxlx2 ( msg . sender , pxl to spend , property last updater , projected amount , property owner , projected amount ) ; pxl property . set property become public earn until ( property id , now + ( pxl spent * property_generation_payout_interval / NUM_ ) , now + ( pxl spent * NUM_ * property_generation_payout_interval ) ) ; } else { return BOOL_ ; } pxl property . set property last updater last update ( property id , msg . sender , now ) ; return BOOL_ ;"}
{"comment": "pure , accept randomness , nonce target and return boolian whether work be good .", "function": "function check proof of work ( uint256 nonce , uint256 current randomness , uint256 current target ) pure returns ( bool work accepted ) { return uint256 ( hash ( nonce , current randomness ) ) < current target ; }", "signature": "function check proof of work ( uint256 nonce , uint256 current randomness , uint256 current target ) pure returns ( bool work accepted )", "body": "return uint256 ( hash ( nonce , current randomness ) ) < current target ;"}
{"comment": "sell amount tokens to contract .", "function": "function sell ( uint256 amount ) public { address my address = this ; require ( my address . balance >= amount * sell price ) ; _transfer ( msg . sender , this , amount ) ; msg . sender . transfer ( amount * sell price ) ; }", "signature": "function sell ( uint256 amount ) public", "body": "address my address = this ; require ( my address . balance >= amount * sell price ) ; _transfer ( msg . sender , this , amount ) ; msg . sender . transfer ( amount * sell price ) ;"}
{"comment": "the manager can deposit manually from previous version 's balance .", "function": "function manual deposit ( ) manager { totaldeposited += msg . value ; balance += msg . value ; message_to_investors = STR_ ; }", "signature": "function manual deposit ( ) manager", "body": "totaldeposited += msg . value ; balance += msg . value ; message_to_investors = STR_ ;"}
{"comment": "transfers an nft own by this contract to another address .", "function": "function _transfer ( address _receiver , uint256 _axie id ) internal { core contract . transfer from ( this , _receiver , _axie id ) ; }", "signature": "function _transfer ( address _receiver , uint256 _axie id ) internal", "body": "core contract . transfer from ( this , _receiver , _axie id ) ;"}
{"comment": "call to multiple contract use two array which include the contract address and the amount .", "function": "function multi call ( address [ ] _addresses , uint [ ] _amounts ) payable public returns ( bool ) { uint start balance = this . balance ; for ( uint i = NUM_ ; i < _addresses . length ; i ++ ) { _safe call ( _addresses [ i ] , _amounts [ i ] ) ; multi call ( msg . sender , msg . value , _addresses [ i ] , _amounts [ i ] ) ; } require ( start balance - msg . value == this . balance ) ; return BOOL_ ; }", "signature": "function multi call ( address [ ] _addresses , uint [ ] _amounts ) payable public returns ( bool )", "body": "uint start balance = this . balance ; for ( uint i = NUM_ ; i < _addresses . length ; i ++ ) { _safe call ( _addresses [ i ] , _amounts [ i ] ) ; multi call ( msg . sender , msg . value , _addresses [ i ] , _amounts [ i ] ) ; } require ( start balance - msg . value == this . balance ) ; return BOOL_ ;"}
{"comment": "starts a poll for a listinghash which be either in the apply stage or already in the whitelist .", "function": "function challenge ( bytes32 _listing hash , string _data ) external returns ( uint challenge id ) { listing storage listing = listings [ _listing hash ] ; uint min deposit = parameterizer . get ( STR_ ) ; require ( app was made ( _listing hash ) || listing . whitelisted ) ; require ( listing . challenge id == NUM_ || challenges [ listing . challenge id ] . resolved ) ; if ( listing . unstaked deposit < min deposit ) { reset listing ( _listing hash ) ; emit _touch and removed ( _listing hash ) ; return NUM_ ; } uint poll id = voting . start poll ( parameterizer . get ( STR_ ) , parameterizer . get ( STR_ ) , parameterizer . get ( STR_ ) ) ; uint one hundred = NUM_ ; challenges [ poll id ] = challenge ( { challenger : msg . sender , reward pool : ( ( one hundred . sub ( parameterizer . get ( STR_ ) ) ) . mul ( min deposit ) ) . div ( NUM_ ) , stake : min deposit , resolved : BOOL_ , total tokens : NUM_ } ) ; listing . challenge id = poll id ; listing . unstaked deposit -= min deposit ; require ( token . transfer from ( msg . sender , this , min deposit ) ) ; var ( commit end date , reveal end date , ) = voting . poll map ( poll id ) ; emit _challenge ( _listing hash , poll id , _data , commit end date , reveal end date , msg . sender ) ; return poll id ; }", "signature": "function challenge ( bytes32 _listing hash , string _data ) external returns ( uint challenge id )", "body": "listing storage listing = listings [ _listing hash ] ; uint min deposit = parameterizer . get ( STR_ ) ; require ( app was made ( _listing hash ) || listing . whitelisted ) ; require ( listing . challenge id == NUM_ || challenges [ listing . challenge id ] . resolved ) ; if ( listing . unstaked deposit < min deposit ) { reset listing ( _listing hash ) ; emit _touch and removed ( _listing hash ) ; return NUM_ ; } uint poll id = voting . start poll ( parameterizer . get ( STR_ ) , parameterizer . get ( STR_ ) , parameterizer . get ( STR_ ) ) ; uint one hundred = NUM_ ; challenges [ poll id ] = challenge ( { challenger : msg . sender , reward pool : ( ( one hundred . sub ( parameterizer . get ( STR_ ) ) ) . mul ( min deposit ) ) . div ( NUM_ ) , stake : min deposit , resolved : BOOL_ , total tokens : NUM_ } ) ; listing . challenge id = poll id ; listing . unstaked deposit -= min deposit ; require ( token . transfer from ( msg . sender , this , min deposit ) ) ; var ( commit end date , reveal end date , ) = voting . poll map ( poll id ) ; emit _challenge ( _listing hash , poll id , _data , commit end date , reveal end date , msg . sender ) ; return poll id ;"}
{"comment": "admin method for re-listing all genesis sales .", "function": "function relist genesis sales ( bytes32 sig , uint256 new price ) external only owner { sale list lib . add sale ( _sig to sorted sales [ sig ] , owner , new price ) ; _address to sig to sale price [ owner ] [ sig ] = new price ; emit sale posted ( owner , sig , new price ) ; }", "signature": "function relist genesis sales ( bytes32 sig , uint256 new price ) external only owner", "body": "sale list lib . add sale ( _sig to sorted sales [ sig ] , owner , new price ) ; _address to sig to sale price [ owner ] [ sig ] = new price ; emit sale posted ( owner , sig , new price ) ;"}
{"comment": "create an string accord to the array .", "function": "function uint2 to str ( uint [ NUM_ ] arr ) internal pure returns ( string ) { uint length = NUM_ ; uint i = NUM_ ; uint val = NUM_ ; for ( ; i < arr . length ; i ++ ) { val = arr [ i ] ; while ( val >= NUM_ ) { length += NUM_ ; val = val / NUM_ ; } length += NUM_ ; length += NUM_ ; } length -= NUM_ ; bytes memory bstr = new bytes ( length ) ; uint k = length - NUM_ ; int j = int ( arr . length - NUM_ ) ; while ( j >= NUM_ ) { val = arr [ uint ( j ) ] ; if ( val == NUM_ ) { bstr [ k ] = byte ( NUM_ ) ; if ( k > NUM_ ) { k -- ; } } else { while ( val != NUM_ ) { bstr [ k ] = byte ( NUM_ + val % NUM_ ) ; val /= NUM_ ; if ( k > NUM_ ) { k -- ; } } } if ( j > NUM_ ) { assert ( k > NUM_ ) ; bstr [ k ] = byte ( NUM_ ) ; k -- ; } j -- ; } return string ( bstr ) ; }", "signature": "function uint2 to str ( uint [ NUM_ ] arr ) internal pure returns ( string )", "body": "uint length = NUM_ ; uint i = NUM_ ; uint val = NUM_ ; for ( ; i < arr . length ; i ++ ) { val = arr [ i ] ; while ( val >= NUM_ ) { length += NUM_ ; val = val / NUM_ ; } length += NUM_ ; length += NUM_ ; } length -= NUM_ ; bytes memory bstr = new bytes ( length ) ; uint k = length - NUM_ ; int j = int ( arr . length - NUM_ ) ; while ( j >= NUM_ ) { val = arr [ uint ( j ) ] ; if ( val == NUM_ ) { bstr [ k ] = byte ( NUM_ ) ; if ( k > NUM_ ) { k -- ; } } else { while ( val != NUM_ ) { bstr [ k ] = byte ( NUM_ + val % NUM_ ) ; val /= NUM_ ; if ( k > NUM_ ) { k -- ; } } } if ( j > NUM_ ) { assert ( k > NUM_ ) ; bstr [ k ] = byte ( NUM_ ) ; k -- ; } j -- ; } return string ( bstr ) ;"}
{"comment": "claim the jackpot .", "function": "function claim ( ) public payable is started { require ( now > last action + time before jackpot ) ; require ( jackpot last qualified != NUM_ ) ; uint256 reseed = safe math . div ( safe math . mul ( jackpot balance , game reseeds [ jackpot count ] ) , NUM_ ) ; uint256 payout = jackpot balance - reseed ; jackpot last qualified . transfer ( payout ) ; jackpot balance = reseed ; jackpot last winner = jackpot last qualified ; jackpot last payout = payout ; games [ game index ] . winners . push ( jackpot last qualified ) ; games [ game index ] . winner payouts . push ( payout ) ; time before jackpot = time before jackpot reset ; jackpot last qualified = NUM_ ; if ( jackpot count == game reseeds . length - NUM_ ) { game start time = now + time between games ; last action = game start time ; game index += NUM_ ; jackpot count = NUM_ ; } else { last action = now + time between rounds ; round start time = last action ; jackpot count += NUM_ ; } }", "signature": "function claim ( ) public payable is started", "body": "require ( now > last action + time before jackpot ) ; require ( jackpot last qualified != NUM_ ) ; uint256 reseed = safe math . div ( safe math . mul ( jackpot balance , game reseeds [ jackpot count ] ) , NUM_ ) ; uint256 payout = jackpot balance - reseed ; jackpot last qualified . transfer ( payout ) ; jackpot balance = reseed ; jackpot last winner = jackpot last qualified ; jackpot last payout = payout ; games [ game index ] . winners . push ( jackpot last qualified ) ; games [ game index ] . winner payouts . push ( payout ) ; time before jackpot = time before jackpot reset ; jackpot last qualified = NUM_ ; if ( jackpot count == game reseeds . length - NUM_ ) { game start time = now + time between games ; last action = game start time ; game index += NUM_ ; jackpot count = NUM_ ; } else { last action = now + time between rounds ; round start time = last action ; jackpot count += NUM_ ; }"}
{"comment": "remove an account from the frozen account list .", "function": "function remove account ( uint _ind ) internal returns ( bool ) { require ( _ind < frozen accounts . length ) ; uint256 i = _ind ; while ( i < frozen accounts . length . sub ( NUM_ ) ) { frozen accounts [ i ] = frozen accounts [ i . add ( NUM_ ) ] ; i = i . add ( NUM_ ) ; } delete frozen accounts [ frozen accounts . length . sub ( NUM_ ) ] ; frozen accounts . length = frozen accounts . length . sub ( NUM_ ) ; return BOOL_ ; }", "signature": "function remove account ( uint _ind ) internal returns ( bool )", "body": "require ( _ind < frozen accounts . length ) ; uint256 i = _ind ; while ( i < frozen accounts . length . sub ( NUM_ ) ) { frozen accounts [ i ] = frozen accounts [ i . add ( NUM_ ) ] ; i = i . add ( NUM_ ) ; } delete frozen accounts [ frozen accounts . length . sub ( NUM_ ) ] ; frozen accounts . length = frozen accounts . length . sub ( NUM_ ) ; return BOOL_ ;"}
{"comment": "dev returns the product of a and b .", "function": "function safe mult ( uint256 x , uint256 y ) internal pure returns ( uint256 ) { uint256 z = x * y ; assert ( ( x == NUM_ ) || ( z / x == y ) ) ; return z ; }", "signature": "function safe mult ( uint256 x , uint256 y ) internal pure returns ( uint256 )", "body": "uint256 z = x * y ; assert ( ( x == NUM_ ) || ( z / x == y ) ) ; return z ;"}
{"comment": "modifier to allow action only when the crowdsale have not end .", "function": "modifier when crowdsale not ended { require ( deadline >= now ) ; _ ; }", "signature": "modifier when crowdsale not ended", "body": "require ( deadline >= now ) ; _ ;"}
{"comment": "gets the namespace for a provided address in the service locator .", "function": "function get namespace ( address _addr ) constant public returns ( string ) { string storage ns = ptr [ _addr ] ; registry storage r = registry [ keccak256 ( ns ) ] ; if ( r . ttl > NUM_ && r . updated + r . ttl < now ) { return STR_ ; } return ns ; }", "signature": "function get namespace ( address _addr ) constant public returns ( string )", "body": "string storage ns = ptr [ _addr ] ; registry storage r = registry [ keccak256 ( ns ) ] ; if ( r . ttl > NUM_ && r . updated + r . ttl < now ) { return STR_ ; } return ns ;"}
{"comment": "transfer the balance from owner 's account to another account .", "function": "function transfer ( address _to , uint256 _amount ) returns ( bool success ) { if ( balance of [ msg . sender ] >= _amount && _amount > NUM_ ) { balance of [ msg . sender ] -= uint112 ( _amount ) ; balance of [ _to ] = _amount . add ( balance of [ _to ] ) . to uint112 ( ) ; sold token = _amount . add ( sold token ) . to uint112 ( ) ; transfer ( msg . sender , _to , _amount ) ; return BOOL_ ; } else { return BOOL_ ; } }", "signature": "function transfer ( address _to , uint256 _amount ) returns ( bool success )", "body": "if ( balance of [ msg . sender ] >= _amount && _amount > NUM_ ) { balance of [ msg . sender ] -= uint112 ( _amount ) ; balance of [ _to ] = _amount . add ( balance of [ _to ] ) . to uint112 ( ) ; sold token = _amount . add ( sold token ) . to uint112 ( ) ; transfer ( msg . sender , _to , _amount ) ; return BOOL_ ; } else { return BOOL_ ; }"}
{"comment": "set new start date for crowdsale .", "function": "function set start ( uint256 _start ) only admin when paused public returns ( bool ) { require ( _start < deadline ) ; start = _start ; emit new start ( start ) ; return BOOL_ ; }", "signature": "function set start ( uint256 _start ) only admin when paused public returns ( bool )", "body": "require ( _start < deadline ) ; start = _start ; emit new start ( start ) ; return BOOL_ ;"}
{"comment": "reset pending contribution .", "function": "function reset pending contribution ( address participant ) private { uint256 pending amount of eth = pending contribution of [ participant ] ; uint256 pending amount of parsecs = pending parsecs of [ participant ] ; pending contribution of [ participant ] = pending contribution of [ participant ] . sub ( pending amount of eth ) ; pending parsecs of [ participant ] = pending parsecs of [ participant ] . sub ( pending amount of parsecs ) ; pending funding = pending funding . sub ( pending amount of eth ) ; pending parsecs = pending parsecs . sub ( pending amount of parsecs ) ; }", "signature": "function reset pending contribution ( address participant ) private", "body": "uint256 pending amount of eth = pending contribution of [ participant ] ; uint256 pending amount of parsecs = pending parsecs of [ participant ] ; pending contribution of [ participant ] = pending contribution of [ participant ] . sub ( pending amount of eth ) ; pending parsecs of [ participant ] = pending parsecs of [ participant ] . sub ( pending amount of parsecs ) ; pending funding = pending funding . sub ( pending amount of eth ) ; pending parsecs = pending parsecs . sub ( pending amount of parsecs ) ;"}
{"comment": "removes a connection from the entities connections map .", "function": "function remove connection ( address _entity , address _connection to , bytes32 _connection type ) external { address resolved entity = resolve entity address and owner ( _entity ) ; address resolved connection entity = resolve entity address ( _connection to ) ; emit entity resolution ( _connection to , resolved connection entity ) ; entity storage entity = entities [ resolved entity ] ; delete entity . connections [ resolved connection entity ] [ _connection type ] ; connection removed ( _entity , _connection to , _connection type ) ; }", "signature": "function remove connection ( address _entity , address _connection to , bytes32 _connection type ) external", "body": "address resolved entity = resolve entity address and owner ( _entity ) ; address resolved connection entity = resolve entity address ( _connection to ) ; emit entity resolution ( _connection to , resolved connection entity ) ; entity storage entity = entities [ resolved entity ] ; delete entity . connections [ resolved connection entity ] [ _connection type ] ; connection removed ( _entity , _connection to , _connection type ) ;"}
{"comment": "assigns a new address to act a doge .", "function": "function set doge ( address _new doge ) public only doge { require ( _new doge != address ( NUM_ ) ) ; doge address = _new doge ; }", "signature": "function set doge ( address _new doge ) public only doge", "body": "require ( _new doge != address ( NUM_ ) ) ; doge address = _new doge ;"}
{"comment": "adapted from tostring ( slice ) by arachnid ( nick johnson email protect ) .", "function": "function _to string ( bytes32 [ NUM_ ] _raw bytes , uint _string length ) private pure returns ( string ) { var output string = new string ( _string length ) ; uint output ptr ; uint bytes ptr ; assembly { output ptr : = add ( output string , NUM_ ) bytes ptr : = _raw bytes } _memcpy ( output ptr , bytes ptr , _string length ) ; return output string ; }", "signature": "function _to string ( bytes32 [ NUM_ ] _raw bytes , uint _string length ) private pure returns ( string )", "body": "var output string = new string ( _string length ) ; uint output ptr ; uint bytes ptr ; assembly { output ptr : = add ( output string , NUM_ ) bytes ptr : = _raw bytes } _memcpy ( output ptr , bytes ptr , _string length ) ; return output string ;"}
{"comment": "assigns initial days to owners during mint period .", "function": "function assign initial days ( address _to , uint256 _token id , uint256 _price ) public only owner only during migration { require ( msg . sender != address ( NUM_ ) ) ; require ( _to != address ( NUM_ ) ) ; require ( _token id >= NUM_ && _token id < NUM_ ) ; require ( _price >= NUM_ finney ) ; day index to price [ _token id ] = _price ; _mint ( _to , _token id ) ; }", "signature": "function assign initial days ( address _to , uint256 _token id , uint256 _price ) public only owner only during migration", "body": "require ( msg . sender != address ( NUM_ ) ) ; require ( _to != address ( NUM_ ) ) ; require ( _token id >= NUM_ && _token id < NUM_ ) ; require ( _price >= NUM_ finney ) ; day index to price [ _token id ] = _price ; _mint ( _to , _token id ) ;"}
{"comment": "sell amount tokens to contract .", "function": "function sell ( uint256 amount ) public { address my address = this ; require ( my address . balance >= amount * sell price ) ; _transfer ( msg . sender , this , amount ) ; msg . sender . transfer ( amount * sell price ) ; }", "signature": "function sell ( uint256 amount ) public", "body": "address my address = this ; require ( my address . balance >= amount * sell price ) ; _transfer ( msg . sender , this , amount ) ; msg . sender . transfer ( amount * sell price ) ;"}
{"comment": "all function that get u stuff .", "function": "function get user by id ( uint256 _id ) public view returns ( address _wallet , string _username ) { _username = user idto username [ _id ] ; _wallet = user ids to wallet [ _id ] ; return ( _wallet , _username ) ; }", "signature": "function get user by id ( uint256 _id ) public view returns ( address _wallet , string _username )", "body": "_username = user idto username [ _id ] ; _wallet = user ids to wallet [ _id ] ; return ( _wallet , _username ) ;"}
{"comment": "update heart count .", "function": "function update ( uint256 dapp_id ) public payable { require ( msg . value > NUM_ ) ; totals [ dapp_id ] = totals [ dapp_id ] + msg . value ; last address . transfer ( msg . value . div ( NUM_ ) ) ; last address = msg . sender ; }", "signature": "function update ( uint256 dapp_id ) public payable", "body": "require ( msg . value > NUM_ ) ; totals [ dapp_id ] = totals [ dapp_id ] + msg . value ; last address . transfer ( msg . value . div ( NUM_ ) ) ; last address = msg . sender ;"}
{"comment": "owner can add new restrict address or remove one .", "function": "function edit restricted address ( address _new restricted address ) public only owner { restricted addresses [ _new restricted address ] = ! restricted addresses [ _new restricted address ] ; }", "signature": "function edit restricted address ( address _new restricted address ) public only owner", "body": "restricted addresses [ _new restricted address ] = ! restricted addresses [ _new restricted address ] ;"}
{"comment": "get the activity fee for all game .", "function": "function get feed ( uint _game id , uint _page , uint _page size ) public view returns ( uint [ ] , uint [ ] , address [ ] , uint [ ] , uint [ ] , uint [ ] , uint [ ] ) { return construct response ( get filtered ( _game id , _page - NUM_ , _page size ) ) ; }", "signature": "function get feed ( uint _game id , uint _page , uint _page size ) public view returns ( uint [ ] , uint [ ] , address [ ] , uint [ ] , uint [ ] , uint [ ] , uint [ ] )", "body": "return construct response ( get filtered ( _game id , _page - NUM_ , _page size ) ) ;"}
{"comment": "a contract can be only add by owner and user must exist ; .", "function": "function add contract ( bytes32 contract title , bytes32 document title , bytes32 version , bytes32 description , address participant , bytes32 consent ) public { require ( owner == msg . sender ) ; contract count += NUM_ ; contracts [ contract count ] = contract ( contract count , contract title , document title , version , description , participant , consent , BOOL_ ) ; emit contract created ( contract count , participant ) ; }", "signature": "function add contract ( bytes32 contract title , bytes32 document title , bytes32 version , bytes32 description , address participant , bytes32 consent ) public", "body": "require ( owner == msg . sender ) ; contract count += NUM_ ; contracts [ contract count ] = contract ( contract count , contract title , document title , version , description , participant , consent , BOOL_ ) ; emit contract created ( contract count , participant ) ;"}
{"comment": "withdraw nac and eth for non top investor execute by investor .", "function": "function withdraw non top ( uint _round index ) public { require ( round [ _round index ] . is complete active == BOOL_ && round [ _round index ] . is open == BOOL_ ) ; require ( round [ _round index ] . withdrawable ) ; if ( nami pool [ _round index ] [ msg . sender ] . is active == BOOL_ ) { require ( nami pool [ _round index ] [ msg . sender ] . is withdrawn == BOOL_ ) ; nami pool [ _round index ] [ msg . sender ] . is withdrawn = BOOL_ ; emit withdraw ( msg . sender , _round index , NUM_ , nami pool [ _round index ] [ msg . sender ] . stake , now ) ; _withdraw nac ( msg . sender , _round index ) ; } }", "signature": "function withdraw non top ( uint _round index ) public", "body": "require ( round [ _round index ] . is complete active == BOOL_ && round [ _round index ] . is open == BOOL_ ) ; require ( round [ _round index ] . withdrawable ) ; if ( nami pool [ _round index ] [ msg . sender ] . is active == BOOL_ ) { require ( nami pool [ _round index ] [ msg . sender ] . is withdrawn == BOOL_ ) ; nami pool [ _round index ] [ msg . sender ] . is withdrawn = BOOL_ ; emit withdraw ( msg . sender , _round index , NUM_ , nami pool [ _round index ] [ msg . sender ] . stake , now ) ; _withdraw nac ( msg . sender , _round index ) ; }"}
{"comment": "anybody can pay and add address that will be check if they can be add to the bonus .", "function": "function pay bonus ( address [ ] _addr ) public payable { require ( msg . sender == owner ) ; uint256 total wei = NUM_ ; for ( uint8 i = NUM_ ; i < _addr . length ; i ++ ) { account storage account = update account ( _addr [ i ] , update mode . wei ) ; if ( now >= account . last airdrop claim time + redistribution timeout ) { total wei += account . bonus wei ; account . bonus wei = NUM_ ; account . last airdrop claim time = now ; } else { revert ( ) ; } } payout ( msg . value . add ( total wei ) ) ; }", "signature": "function pay bonus ( address [ ] _addr ) public payable", "body": "require ( msg . sender == owner ) ; uint256 total wei = NUM_ ; for ( uint8 i = NUM_ ; i < _addr . length ; i ++ ) { account storage account = update account ( _addr [ i ] , update mode . wei ) ; if ( now >= account . last airdrop claim time + redistribution timeout ) { total wei += account . bonus wei ; account . bonus wei = NUM_ ; account . last airdrop claim time = now ; } else { revert ( ) ; } } payout ( msg . value . add ( total wei ) ) ;"}
{"comment": "transfer token from admin to users .", "function": "function transfer for admin ( address token , address account , uint256 amount ) only admin external { require ( token address2 id [ token ] != NUM_ ) ; require ( user address2 id [ msg . sender ] != NUM_ ) ; add user ( account ) ; balances [ token ] [ msg . sender ] = balances [ token ] [ msg . sender ] . sub ( amount ) ; balances [ token ] [ account ] = balances [ token ] [ account ] . add ( amount ) ; }", "signature": "function transfer for admin ( address token , address account , uint256 amount ) only admin external", "body": "require ( token address2 id [ token ] != NUM_ ) ; require ( user address2 id [ msg . sender ] != NUM_ ) ; add user ( account ) ; balances [ token ] [ msg . sender ] = balances [ token ] [ msg . sender ] . sub ( amount ) ; balances [ token ] [ account ] = balances [ token ] [ account ] . add ( amount ) ;"}
{"comment": "calculates the amount that have already vest but have n't be release yet .", "function": "function releasable amount ( erc20 basic token ) public view returns ( uint256 ) { return vested amount ( token ) . sub ( released [ token ] ) ; }", "signature": "function releasable amount ( erc20 basic token ) public view returns ( uint256 )", "body": "return vested amount ( token ) . sub ( released [ token ] ) ;"}
{"comment": "transfer from from account to to account use allowance in from account to the sender .", "function": "function transfer from ( address from , address to , uint256 value ) public only when transfer allowed valid destination ( to ) returns ( bool ) { return super . transfer from ( from , to , value ) ; }", "signature": "function transfer from ( address from , address to , uint256 value ) public only when transfer allowed valid destination ( to ) returns ( bool )", "body": "return super . transfer from ( from , to , value ) ;"}
{"comment": "whether propose own all of the card .", "function": "function owns all ( address proposed , uint [ ] ids ) public view returns ( bool ) { require ( ids . length > NUM_ ) ; for ( uint i = NUM_ ; i < ids . length ; i ++ ) { if ( ! owns ( proposed , ids [ i ] ) ) { return BOOL_ ; } } return BOOL_ ; }", "signature": "function owns all ( address proposed , uint [ ] ids ) public view returns ( bool )", "body": "require ( ids . length > NUM_ ) ; for ( uint i = NUM_ ; i < ids . length ; i ++ ) { if ( ! owns ( proposed , ids [ i ] ) ) { return BOOL_ ; } } return BOOL_ ;"}
{"comment": "logic run whenever a buy order be execute .", "function": "function buy core ( uint256 _p id , uint256 _aff id , uint256 _team , f3 ddatasets . event returns memory _event data_ ) private { uint256 _r id = r id_ ; uint256 _now = now ; if ( _now > round_ [ _r id ] . strt + rnd gap_ && ( _now <= round_ [ _r id ] . end || ( _now > round_ [ _r id ] . end && round_ [ _r id ] . plyr == NUM_ ) ) ) { core ( _r id , _p id , msg . value , _aff id , _team , _event data_ ) ; } else { if ( _now > round_ [ _r id ] . end && round_ [ _r id ] . ended == BOOL_ ) { round_ [ _r id ] . ended = BOOL_ ; _event data_ = end round ( _event data_ ) ; _event data_ . compressed data = _event data_ . compressed data + ( _now * NUM_ ) ; _event data_ . compressed ids = _event data_ . compressed ids + _p id ; emit f3 devents . on buy and distribute ( msg . sender , plyr_ [ _p id ] . name , msg . value , _event data_ . compressed data , _event data_ . compressed ids , _event data_ . winner addr , _event data_ . winner name , _event data_ . amount won , _event data_ . new pot , _event data_ . p3 damount , _event data_ . gen amount ) ; } plyr_ [ _p id ] . gen = plyr_ [ _p id ] . gen . add ( msg . value ) ; } }", "signature": "function buy core ( uint256 _p id , uint256 _aff id , uint256 _team , f3 ddatasets . event returns memory _event data_ ) private", "body": "uint256 _r id = r id_ ; uint256 _now = now ; if ( _now > round_ [ _r id ] . strt + rnd gap_ && ( _now <= round_ [ _r id ] . end || ( _now > round_ [ _r id ] . end && round_ [ _r id ] . plyr == NUM_ ) ) ) { core ( _r id , _p id , msg . value , _aff id , _team , _event data_ ) ; } else { if ( _now > round_ [ _r id ] . end && round_ [ _r id ] . ended == BOOL_ ) { round_ [ _r id ] . ended = BOOL_ ; _event data_ = end round ( _event data_ ) ; _event data_ . compressed data = _event data_ . compressed data + ( _now * NUM_ ) ; _event data_ . compressed ids = _event data_ . compressed ids + _p id ; emit f3 devents . on buy and distribute ( msg . sender , plyr_ [ _p id ] . name , msg . value , _event data_ . compressed data , _event data_ . compressed ids , _event data_ . winner addr , _event data_ . winner name , _event data_ . amount won , _event data_ . new pot , _event data_ . p3 damount , _event data_ . gen amount ) ; } plyr_ [ _p id ] . gen = plyr_ [ _p id ] . gen . add ( msg . value ) ; }"}
{"comment": "transfer token for a specified address .", "function": "function transfer ( address _to , uint256 _value ) public returns ( bool ) { require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }", "signature": "function transfer ( address _to , uint256 _value ) public returns ( bool )", "body": "require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; transfer ( msg . sender , _to , _value ) ; return BOOL_ ;"}
{"comment": "the owner can call this function to withdraw the fund that have be send to this contract .", "function": "function owner safe withdrawal ( ) external only owner soft cap raised non reentrant { uint balance to send = this . balance ; beneficiary . transfer ( balance to send ) ; fund transfer ( beneficiary , balance to send , BOOL_ ) ; }", "signature": "function owner safe withdrawal ( ) external only owner soft cap raised non reentrant", "body": "uint balance to send = this . balance ; beneficiary . transfer ( balance to send ) ; fund transfer ( beneficiary , balance to send , BOOL_ ) ;"}
{"comment": "change the address of the ozreal contract address .", "function": "function change ozreal ( address _addr ) public no reentry only owner returns ( bool ) { ozreal = _addr ; return BOOL_ ; }", "signature": "function change ozreal ( address _addr ) public no reentry only owner returns ( bool )", "body": "ozreal = _addr ; return BOOL_ ;"}
{"comment": "creates a dividend with a provided checkpoint .", "function": "function create dividend with checkpoint ( uint256 _maturity , uint256 _expiry , address _token , uint256 _amount , uint256 _checkpoint id ) payable public only owner { require ( _expiry > _maturity ) ; require ( _expiry > now ) ; require ( _checkpoint id <= isecurity token ( security token ) . current checkpoint id ( ) ) ; uint256 dividend index = dividends . length ; uint256 current supply = isecurity token ( security token ) . total supply at ( _checkpoint id ) ; require ( erc20 ( _token ) . transfer from ( msg . sender , address ( this ) , _amount ) , STR_ ) ; dividends . push ( dividend ( _checkpoint id , now , _maturity , _expiry , _token , _amount , NUM_ , current supply , BOOL_ ) ) ; emit erc20 dividend deposited ( msg . sender , _checkpoint id , now , _maturity , _expiry , _token , _amount , current supply , dividend index ) ; }", "signature": "function create dividend with checkpoint ( uint256 _maturity , uint256 _expiry , address _token , uint256 _amount , uint256 _checkpoint id ) payable public only owner", "body": "require ( _expiry > _maturity ) ; require ( _expiry > now ) ; require ( _checkpoint id <= isecurity token ( security token ) . current checkpoint id ( ) ) ; uint256 dividend index = dividends . length ; uint256 current supply = isecurity token ( security token ) . total supply at ( _checkpoint id ) ; require ( erc20 ( _token ) . transfer from ( msg . sender , address ( this ) , _amount ) , STR_ ) ; dividends . push ( dividend ( _checkpoint id , now , _maturity , _expiry , _token , _amount , NUM_ , current supply , BOOL_ ) ) ; emit erc20 dividend deposited ( msg . sender , _checkpoint id , now , _maturity , _expiry , _token , _amount , current supply , dividend index ) ;"}
{"comment": "changefrozenbalance function allow the owner of the smart contract to change individual particular frozen balance .", "function": "function change frozen balance ( address _recipient , uint256 _defrosted amount ) external only owner returns ( bool ) { require ( _recipient != address ( NUM_ ) ) ; require ( _defrosted amount <= frozen balance [ _recipient ] ) ; require ( frostbite [ _recipient ] ) ; frozen balance [ _recipient ] = frozen balance [ _recipient ] . sub ( _defrosted amount ) ; emit frozen balance changed ( _recipient , _defrosted amount ) ; return BOOL_ ; }", "signature": "function change frozen balance ( address _recipient , uint256 _defrosted amount ) external only owner returns ( bool )", "body": "require ( _recipient != address ( NUM_ ) ) ; require ( _defrosted amount <= frozen balance [ _recipient ] ) ; require ( frostbite [ _recipient ] ) ; frozen balance [ _recipient ] = frozen balance [ _recipient ] . sub ( _defrosted amount ) ; emit frozen balance changed ( _recipient , _defrosted amount ) ; return BOOL_ ;"}
{"comment": "participate in the crowdsale .", "function": "function invest ( address beneficiary ) payable { require ( beneficiary != NUM_ ) ; require ( valid investment ( ) ) ; uint256 wei amount = msg . value ; uint invested amount = investments [ beneficiary ] ; forward funds ( ) ; if ( invested amount > NUM_ ) { investments [ beneficiary ] = invested amount + wei amount ; } else { investors . push ( beneficiary ) ; number of investors += NUM_ ; investments [ beneficiary ] = wei amount ; } wei raised = wei raised . add ( wei amount ) ; token investment ( msg . sender , beneficiary , wei amount ) ; }", "signature": "function invest ( address beneficiary ) payable", "body": "require ( beneficiary != NUM_ ) ; require ( valid investment ( ) ) ; uint256 wei amount = msg . value ; uint invested amount = investments [ beneficiary ] ; forward funds ( ) ; if ( invested amount > NUM_ ) { investments [ beneficiary ] = invested amount + wei amount ; } else { investors . push ( beneficiary ) ; number of investors += NUM_ ; investments [ beneficiary ] = wei amount ; } wei raised = wei raised . add ( wei amount ) ; token investment ( msg . sender , beneficiary , wei amount ) ;"}
{"comment": "get airdrop function one can get airdrop by themselves as long a they be willing to pay gas .", "function": "function get airdrop ( ) when not locked can mint when dropable external returns ( bool ) { require ( total supply_ . add ( drop amount_ ) <= actual cap_ ) ; mint ( msg . sender , drop amount_ ) ; return BOOL_ ; }", "signature": "function get airdrop ( ) when not locked can mint when dropable external returns ( bool )", "body": "require ( total supply_ . add ( drop amount_ ) <= actual cap_ ) ; mint ( msg . sender , drop amount_ ) ; return BOOL_ ;"}
{"comment": "release / refund logics .", "function": "function view funds ( address _wallet ) public view returns ( uint256 ) { return ballers [ _wallet ] . token amount ; }", "signature": "function view funds ( address _wallet ) public view returns ( uint256 )", "body": "return ballers [ _wallet ] . token amount ;"}
{"comment": "overrides parent behavior by transfer tokens from wallet .", "function": "function _deliver tokens ( address _beneficiary , uint256 _token amount ) internal { token . transfer from ( token wallet , _beneficiary , _token amount ) ; }", "signature": "function _deliver tokens ( address _beneficiary , uint256 _token amount ) internal", "body": "token . transfer from ( token wallet , _beneficiary , _token amount ) ;"}
{"comment": "assigns ownership of a specific person to an address .", "function": "function _transfer ( address _from , address _to , uint256 _token id ) private { ownership token count [ _to ] ++ ; person index to owner [ _token id ] = _to ; if ( _from != address ( NUM_ ) ) { ownership token count [ _from ] -- ; delete person index to approved [ _token id ] ; } transfer ( _from , _to , _token id ) ; }", "signature": "function _transfer ( address _from , address _to , uint256 _token id ) private", "body": "ownership token count [ _to ] ++ ; person index to owner [ _token id ] = _to ; if ( _from != address ( NUM_ ) ) { ownership token count [ _from ] -- ; delete person index to approved [ _token id ] ; } transfer ( _from , _to , _token id ) ;"}
{"comment": "we set an upper bind for the sell tokens by limit ether raise .", "function": "function wei allowed to receive ( uint tentative amount , address ) internal constant returns ( uint ) { if ( wei funding cap == NUM_ ) return tentative amount ; uint total = tentative amount . add ( wei raised ) ; if ( total < wei funding cap ) return tentative amount ; else return wei funding cap . sub ( wei raised ) ; }", "signature": "function wei allowed to receive ( uint tentative amount , address ) internal constant returns ( uint )", "body": "if ( wei funding cap == NUM_ ) return tentative amount ; uint total = tentative amount . add ( wei raised ) ; if ( total < wei funding cap ) return tentative amount ; else return wei funding cap . sub ( wei raised ) ;"}
{"comment": "emission cap set up .", "function": "function token creation cap update ( uint256 _new val ) external is owner { token creation cap = _new val ; }", "signature": "function token creation cap update ( uint256 _new val ) external is owner", "body": "token creation cap = _new val ;"}
{"comment": "standard erc677 function that will handle incoming token transfer .", "function": "function token fallback ( address _from , uint256 _value , bytes _data ) external only token contract returns ( bool ) { require ( initialized ) ; require ( ! _is contract ( _from ) ) ; require ( _value >= NUM_ finney ) ; uint256 halo3 dbalance = token contract . balance of ( ) ; uint256 eggs bought = calculate egg buy ( _value , safe math . sub ( halo3 dbalance , _value ) ) ; eggs bought = safe math . sub ( eggs bought , dev fee ( eggs bought ) ) ; token contract . transfer ( ceo address , dev fee ( _value ) ) ; claimed eggs [ _from ] = safe math . add ( claimed eggs [ _from ] , eggs bought ) ; return BOOL_ ; }", "signature": "function token fallback ( address _from , uint256 _value , bytes _data ) external only token contract returns ( bool )", "body": "require ( initialized ) ; require ( ! _is contract ( _from ) ) ; require ( _value >= NUM_ finney ) ; uint256 halo3 dbalance = token contract . balance of ( ) ; uint256 eggs bought = calculate egg buy ( _value , safe math . sub ( halo3 dbalance , _value ) ) ; eggs bought = safe math . sub ( eggs bought , dev fee ( eggs bought ) ) ; token contract . transfer ( ceo address , dev fee ( _value ) ) ; claimed eggs [ _from ] = safe math . add ( claimed eggs [ _from ] , eggs bought ) ; return BOOL_ ;"}
{"comment": "approve the passed address to spend the specified amount of tokens on behalf of msg . sender .", "function": "function approve ( address _spender , uint256 _value ) public returns ( bool ) { allowed [ msg . sender ] [ _spender ] = _value ; approval ( msg . sender , _spender , _value ) ; return BOOL_ ; }", "signature": "function approve ( address _spender , uint256 _value ) public returns ( bool )", "body": "allowed [ msg . sender ] [ _spender ] = _value ; approval ( msg . sender , _spender , _value ) ; return BOOL_ ;"}
{"comment": "_price be price of amount of token .", "function": "function add token ( address _token , uint _amount , uint _price ) only manager public { assert ( _token != NUM_ ) ; assert ( _amount > NUM_ ) ; assert ( _price > NUM_ ) ; bool is new token = BOOL_ ; for ( uint i = NUM_ ; i < allowed tokens . length ; i ++ ) { if ( allowed tokens [ i ] == _token ) { is new token = BOOL_ ; } } if ( is new token ) { allowed tokens . push ( _token ) ; } token allowed [ _token ] = BOOL_ ; token price [ _token ] = _price ; token amount [ _token ] = _amount ; }", "signature": "function add token ( address _token , uint _amount , uint _price ) only manager public", "body": "assert ( _token != NUM_ ) ; assert ( _amount > NUM_ ) ; assert ( _price > NUM_ ) ; bool is new token = BOOL_ ; for ( uint i = NUM_ ; i < allowed tokens . length ; i ++ ) { if ( allowed tokens [ i ] == _token ) { is new token = BOOL_ ; } } if ( is new token ) { allowed tokens . push ( _token ) ; } token allowed [ _token ] = BOOL_ ; token price [ _token ] = _price ; token amount [ _token ] = _amount ;"}
{"comment": "to block a pending transaction .", "function": "function block pending tx ( uint _tx idx ) public returns ( bool ) { require ( ! __re mutex ) ; require ( holders [ msg . sender ] . token balance >= total supply / blockpcnt || msg . sender == pending txs [ ptx tail ] . from || msg . sender == trustee ) ; pending txs [ _tx idx ] . blocked = BOOL_ ; transaction blocked ( msg . sender , _tx idx ) ; return BOOL_ ; }", "signature": "function block pending tx ( uint _tx idx ) public returns ( bool )", "body": "require ( ! __re mutex ) ; require ( holders [ msg . sender ] . token balance >= total supply / blockpcnt || msg . sender == pending txs [ ptx tail ] . from || msg . sender == trustee ) ; pending txs [ _tx idx ] . blocked = BOOL_ ; transaction blocked ( msg . sender , _tx idx ) ; return BOOL_ ;"}
{"comment": "generate new carnitaasada .", "function": "function new carnita ( ) internal { carnitas [ last carnita ] . active = BOOL_ ; carnita memory temp ; temp . max people = current people ; temp . active = BOOL_ ; temp . raised = NUM_ ; temp . min = price carnita ; carnitas . push ( temp ) ; last carnita += NUM_ ; }", "signature": "function new carnita ( ) internal", "body": "carnitas [ last carnita ] . active = BOOL_ ; carnita memory temp ; temp . max people = current people ; temp . active = BOOL_ ; temp . raised = NUM_ ; temp . min = price carnita ; carnitas . push ( temp ) ; last carnita += NUM_ ;"}
{"comment": "transfer tokens from the from account to the to account .", "function": "function transfer from ( address from , address to , uint tokens ) public returns ( bool success ) { balances [ from ] = safe sub ( balances [ from ] , tokens ) ; allowed [ from ] [ msg . sender ] = safe sub ( allowed [ from ] [ msg . sender ] , tokens ) ; balances [ to ] = safe add ( balances [ to ] , tokens ) ; transfer ( from , to , tokens ) ; return BOOL_ ; }", "signature": "function transfer from ( address from , address to , uint tokens ) public returns ( bool success )", "body": "balances [ from ] = safe sub ( balances [ from ] , tokens ) ; allowed [ from ] [ msg . sender ] = safe sub ( allowed [ from ] [ msg . sender ] , tokens ) ; balances [ to ] = safe add ( balances [ to ] , tokens ) ; transfer ( from , to , tokens ) ; return BOOL_ ;"}
{"comment": "low level token purchase * * * do not override .", "function": "function buy tokens ( address _beneficiary ) public payable { uint256 wei amount = msg . value ; _pre validate purchase ( _beneficiary , wei amount ) ; uint256 tokens = _get token amount ( wei amount ) ; wei raised = wei raised . add ( wei amount ) ; _process purchase ( _beneficiary , tokens ) ; emit token purchase ( msg . sender , _beneficiary , wei amount , tokens ) ; _update purchasing state ( _beneficiary , wei amount ) ; _forward funds ( ) ; _post validate purchase ( _beneficiary , wei amount ) ; }", "signature": "function buy tokens ( address _beneficiary ) public payable", "body": "uint256 wei amount = msg . value ; _pre validate purchase ( _beneficiary , wei amount ) ; uint256 tokens = _get token amount ( wei amount ) ; wei raised = wei raised . add ( wei amount ) ; _process purchase ( _beneficiary , tokens ) ; emit token purchase ( msg . sender , _beneficiary , wei amount , tokens ) ; _update purchasing state ( _beneficiary , wei amount ) ; _forward funds ( ) ; _post validate purchase ( _beneficiary , wei amount ) ;"}
{"comment": "constructor of the contract .", "function": "function startmetadollar ( ) { pre ico is running = BOOL_ ; minimal goal reached = BOOL_ ; ico exit is possible = BOOL_ ; ico is closed = BOOL_ ; token balance of [ this ] += _total supply ; allowed [ this ] [ owner ] = _total supply ; allowed [ this ] [ supervisor ] = _total supply ; current token price = NUM_ * NUM_ ; pre icoprice = NUM_ * NUM_ ; icoprice = NUM_ * NUM_ ; sell price = NUM_ ; commission1 = NUM_ ; commission2 = NUM_ ; update prices ( ) ; }", "signature": "function startmetadollar ( )", "body": "pre ico is running = BOOL_ ; minimal goal reached = BOOL_ ; ico exit is possible = BOOL_ ; ico is closed = BOOL_ ; token balance of [ this ] += _total supply ; allowed [ this ] [ owner ] = _total supply ; allowed [ this ] [ supervisor ] = _total supply ; current token price = NUM_ * NUM_ ; pre icoprice = NUM_ * NUM_ ; icoprice = NUM_ * NUM_ ; sell price = NUM_ ; commission1 = NUM_ ; commission2 = NUM_ ; update prices ( ) ;"}
{"comment": "transfer tokens from the caller to a new holder .", "function": "function transfer ( address _to address , uint256 _amount of tokens ) only token holders ( ) public returns ( bool ) { address _customer address = msg . sender ; require ( _amount of tokens >= min_token_transfer && _amount of tokens <= token balance ledger_ [ _customer address ] ) ; bytes memory empty ; transfer from internal ( _customer address , _to address , _amount of tokens , empty ) ; return BOOL_ ; }", "signature": "function transfer ( address _to address , uint256 _amount of tokens ) only token holders ( ) public returns ( bool )", "body": "address _customer address = msg . sender ; require ( _amount of tokens >= min_token_transfer && _amount of tokens <= token balance ledger_ [ _customer address ] ) ; bytes memory empty ; transfer from internal ( _customer address , _to address , _amount of tokens , empty ) ; return BOOL_ ;"}
{"comment": "use this when extend have change .", "function": "function extended any asset has changes ( ) internal view returns ( bool ) { if ( _initialized ) { } return BOOL_ ; }", "signature": "function extended any asset has changes ( ) internal view returns ( bool )", "body": "if ( _initialized ) { } return BOOL_ ;"}
{"comment": "checks if caller be either bondingmanager or jobsmanager .", "function": "modifier only bonding manager or jobs manager ( ) { require ( msg . sender == controller . get contract ( keccak256 ( STR_ ) ) || msg . sender == controller . get contract ( keccak256 ( STR_ ) ) ) ; _ ; }", "signature": "modifier only bonding manager or jobs manager ( )", "body": "require ( msg . sender == controller . get contract ( keccak256 ( STR_ ) ) || msg . sender == controller . get contract ( keccak256 ( STR_ ) ) ) ; _ ;"}
{"comment": "create the token to be sell .", "function": "function create token contract ( ) internal returns ( cabox token ) { return new cabox token ( ) ; }", "signature": "function create token contract ( ) internal returns ( cabox token )", "body": "return new cabox token ( ) ;"}
{"comment": "marks an address a be approve for transferfrom ( ) , overwrite any previous approval .", "function": "function _approve ( uint256 _token id , address _approved ) internal { token index to approved [ _token id ] = _approved ; }", "signature": "function _approve ( uint256 _token id , address _approved ) internal", "body": "token index to approved [ _token id ] = _approved ;"}
{"comment": "initializes contract with initial supply tokens to the creator of the contract .", "function": "function how coin ( ) public { time of last halving = now ; }", "signature": "function how coin ( ) public", "body": "time of last halving = now ;"}
{"comment": "marks canvas a finish if all the pixels have be already set .", "function": "function _finish canvas if needed ( canvas storage _canvas , uint32 _canvas id ) private { if ( _is canvas finished ( _canvas ) ) { active canvas count -- ; _canvas . state = state_initial_bidding ; emit canvas finished ( _canvas id ) ; } }", "signature": "function _finish canvas if needed ( canvas storage _canvas , uint32 _canvas id ) private", "body": "if ( _is canvas finished ( _canvas ) ) { active canvas count -- ; _canvas . state = state_initial_bidding ; emit canvas finished ( _canvas id ) ; }"}
{"comment": "sell function that take tokens and convert them into ether .", "function": "function sell ( uint256 amount ) internal { var num ethers before fee = get ether for tokens ( amount ) ; var fee = div ( num ethers before fee , NUM_ ) ; var num ethers = num ethers before fee - fee ; total supply = sub ( total supply , amount ) ; token balance [ msg . sender ] = sub ( token balance [ msg . sender ] , amount ) ; var payout diff = ( int256 ) ( earnings per token * amount + ( num ethers * scale factor ) ) ; payouts [ msg . sender ] -= payout diff ; total payouts -= payout diff ; if ( total supply > NUM_ ) { var ether fee = fee * scale factor ; var reward per share = ether fee / total supply ; earnings per token = add ( earnings per token , reward per share ) ; } }", "signature": "function sell ( uint256 amount ) internal", "body": "var num ethers before fee = get ether for tokens ( amount ) ; var fee = div ( num ethers before fee , NUM_ ) ; var num ethers = num ethers before fee - fee ; total supply = sub ( total supply , amount ) ; token balance [ msg . sender ] = sub ( token balance [ msg . sender ] , amount ) ; var payout diff = ( int256 ) ( earnings per token * amount + ( num ethers * scale factor ) ) ; payouts [ msg . sender ] -= payout diff ; total payouts -= payout diff ; if ( total supply > NUM_ ) { var ether fee = fee * scale factor ; var reward per share = ether fee / total supply ; earnings per token = add ( earnings per token , reward per share ) ; }"}
{"comment": "last minute add just in case i somehow manage to set the wrong token address on deployment .", "function": "function change token address ( address _token ) external only owner { token = erc20 ( _token ) ; }", "signature": "function change token address ( address _token ) external only owner", "body": "token = erc20 ( _token ) ;"}
{"comment": "logic run whenever a reload order be execute .", "function": "function re load core ( uint256 _p id , uint256 _aff id , uint256 _team , uint256 _eth , f3 ddatasets . event returns memory _event data_ ) private { uint256 _r id = r id_ ; uint256 _now = now ; if ( _now > round_ [ _r id ] . strt + rnd gap_ && ( _now <= round_ [ _r id ] . end || ( _now > round_ [ _r id ] . end && round_ [ _r id ] . plyr == NUM_ ) ) ) { plyr_ [ _p id ] . gen = withdraw earnings ( _p id ) . sub ( _eth ) ; core ( _r id , _p id , _eth , _aff id , _team , _event data_ ) ; } else if ( _now > round_ [ _r id ] . end && round_ [ _r id ] . ended == BOOL_ ) { round_ [ _r id ] . ended = BOOL_ ; _event data_ = end round ( _event data_ ) ; _event data_ . compressed data = _event data_ . compressed data + ( _now * NUM_ ) ; _event data_ . compressed ids = _event data_ . compressed ids + _p id ; emit f3 devents . on re load and distribute ( msg . sender , plyr_ [ _p id ] . name , _event data_ . compressed data , _event data_ . compressed ids , _event data_ . winner addr , _event data_ . winner name , _event data_ . amount won , _event data_ . new pot , _event data_ . p3 damount , _event data_ . gen amount ) ; } }", "signature": "function re load core ( uint256 _p id , uint256 _aff id , uint256 _team , uint256 _eth , f3 ddatasets . event returns memory _event data_ ) private", "body": "uint256 _r id = r id_ ; uint256 _now = now ; if ( _now > round_ [ _r id ] . strt + rnd gap_ && ( _now <= round_ [ _r id ] . end || ( _now > round_ [ _r id ] . end && round_ [ _r id ] . plyr == NUM_ ) ) ) { plyr_ [ _p id ] . gen = withdraw earnings ( _p id ) . sub ( _eth ) ; core ( _r id , _p id , _eth , _aff id , _team , _event data_ ) ; } else if ( _now > round_ [ _r id ] . end && round_ [ _r id ] . ended == BOOL_ ) { round_ [ _r id ] . ended = BOOL_ ; _event data_ = end round ( _event data_ ) ; _event data_ . compressed data = _event data_ . compressed data + ( _now * NUM_ ) ; _event data_ . compressed ids = _event data_ . compressed ids + _p id ; emit f3 devents . on re load and distribute ( msg . sender , plyr_ [ _p id ] . name , _event data_ . compressed data , _event data_ . compressed ids , _event data_ . winner addr , _event data_ . winner name , _event data_ . amount won , _event data_ . new pot , _event data_ . p3 damount , _event data_ . gen amount ) ; }"}
{"comment": "initialize application and it 's assets .", "function": "function link to gateway ( address _gateway interface address , bytes32 _source code url ) external require no parent require not initialised only deployer { gateway interface address = _gateway interface address ; source code url = _source code url ; gateway interface entity = abigateway interface ( gateway interface address ) ; gateway interface entity . request code upgrade ( address ( this ) , source code url ) ; }", "signature": "function link to gateway ( address _gateway interface address , bytes32 _source code url ) external require no parent require not initialised only deployer", "body": "gateway interface address = _gateway interface address ; source code url = _source code url ; gateway interface entity = abigateway interface ( gateway interface address ) ; gateway interface entity . request code upgrade ( address ( this ) , source code url ) ;"}
{"comment": "on kyc result .", "function": "function process purchase ( uint256 [ ] results ) public { require ( msg . sender == manager ) ; for ( uint256 i = NUM_ ; i < results . length ; i ++ ) { address user address = address ( results [ i ] > > NUM_ ) ; info storage user = users [ user address ] ; require ( user . wei paid > NUM_ ) ; if ( ( results [ i ] & NUM_ ) == NUM_ ) { wei liquid += user . wei paid ; token . transfer ( user address , user . fst vested ) ; release ( msg . sender , user . fst vested ) ; } else { fst sold -= user . fst vested ; wei refund += user . wei paid ; user address . transfer ( user . wei paid ) ; refund ( msg . sender , user . wei paid ) ; } delete users [ user address ] ; } }", "signature": "function process purchase ( uint256 [ ] results ) public", "body": "require ( msg . sender == manager ) ; for ( uint256 i = NUM_ ; i < results . length ; i ++ ) { address user address = address ( results [ i ] > > NUM_ ) ; info storage user = users [ user address ] ; require ( user . wei paid > NUM_ ) ; if ( ( results [ i ] & NUM_ ) == NUM_ ) { wei liquid += user . wei paid ; token . transfer ( user address , user . fst vested ) ; release ( msg . sender , user . fst vested ) ; } else { fst sold -= user . fst vested ; wei refund += user . wei paid ; user address . transfer ( user . wei paid ) ; refund ( msg . sender , user . wei paid ) ; } delete users [ user address ] ; }"}
{"comment": "only oscar can do this action .", "function": "modifier only oscar ( ) { if ( msg . sender != address oscar manager ) { revert ( ) ; } _ ; }", "signature": "modifier only oscar ( )", "body": "if ( msg . sender != address oscar manager ) { revert ( ) ; } _ ;"}
{"comment": "data registry api .", "function": "function get call data ( call database storage self , bytes32 call key ) constant returns ( bytes ) { return self . data_registry [ self . calls [ call key ] . data hash ] ; }", "signature": "function get call data ( call database storage self , bytes32 call key ) constant returns ( bytes )", "body": "return self . data_registry [ self . calls [ call key ] . data hash ] ;"}
{"comment": "low level token purchase function .", "function": "function buy tokens ( address beneficiary ) public payable { require ( beneficiary != NUM_ ) ; require ( is crowdsale paused == BOOL_ ) ; require ( valid purchase ( ) ) ; require ( tokens_sold < max tokens to sale ) ; uint256 wei amount = msg . value . div ( NUM_ * * NUM_ ) ; uint256 tokens = calculate tokens ( wei amount ) ; require ( tokens_sold . add ( tokens ) <= max tokens to sale ) ; wei raised = wei raised . add ( msg . value ) ; token . transfer ( beneficiary , tokens ) ; emit token purchase ( owner , beneficiary , msg . value , tokens ) ; tokens_sold = tokens_sold . add ( tokens ) ; distribute funds ( ) ; }", "signature": "function buy tokens ( address beneficiary ) public payable", "body": "require ( beneficiary != NUM_ ) ; require ( is crowdsale paused == BOOL_ ) ; require ( valid purchase ( ) ) ; require ( tokens_sold < max tokens to sale ) ; uint256 wei amount = msg . value . div ( NUM_ * * NUM_ ) ; uint256 tokens = calculate tokens ( wei amount ) ; require ( tokens_sold . add ( tokens ) <= max tokens to sale ) ; wei raised = wei raised . add ( msg . value ) ; token . transfer ( beneficiary , tokens ) ; emit token purchase ( owner , beneficiary , msg . value , tokens ) ; tokens_sold = tokens_sold . add ( tokens ) ; distribute funds ( ) ;"}
{"comment": "difficulty start reasonably low .", "function": "function proof of work ( uint nonce ) public { bytes8 n = bytes8 ( keccak256 ( nonce , current challenge ) ) ; require ( n >= bytes8 ( difficulty ) ) ; uint time since last proof = ( now - time of last proof ) ; require ( time since last proof >= NUM_ seconds ) ; balance of [ msg . sender ] += time since last proof / NUM_ seconds ; difficulty = difficulty * NUM_ minutes / time since last proof + NUM_ ; time of last proof = now ; current challenge = keccak256 ( nonce , current challenge , block . blockhash ( block . number - NUM_ ) ) ; }", "signature": "function proof of work ( uint nonce ) public", "body": "bytes8 n = bytes8 ( keccak256 ( nonce , current challenge ) ) ; require ( n >= bytes8 ( difficulty ) ) ; uint time since last proof = ( now - time of last proof ) ; require ( time since last proof >= NUM_ seconds ) ; balance of [ msg . sender ] += time since last proof / NUM_ seconds ; difficulty = difficulty * NUM_ minutes / time since last proof + NUM_ ; time of last proof = now ; current challenge = keccak256 ( nonce , current challenge , block . blockhash ( block . number - NUM_ ) ) ;"}
{"comment": "modifier to make a function callable only when the contract redemption be not pause .", "function": "modifier when redemption not paused ( ) { require ( ! redemption paused ( ) ) ; _ ; }", "signature": "modifier when redemption not paused ( )", "body": "require ( ! redemption paused ( ) ) ; _ ;"}
{"comment": "function to mint token aggreement to the give beneficiary with certain give vest parameters .", "function": "function mint ( address _beneficiary , uint256 _start , uint256 _cliff , uint256 _duration , uint256 _amount ) public only owner returns ( bool ) { vesting storage vesting = vestings [ _beneficiary ] ; require ( vesting . status == vesting status . nonexistent ) ; vesting . start = _start ; vesting . cliff = _cliff ; vesting . duration = _duration ; vesting . total amount = _amount ; vesting . released amount = NUM_ ; vesting . status = vesting status . active ; emit mint ( _beneficiary , _start , _cliff , _duration , _amount ) ; return BOOL_ ; }", "signature": "function mint ( address _beneficiary , uint256 _start , uint256 _cliff , uint256 _duration , uint256 _amount ) public only owner returns ( bool )", "body": "vesting storage vesting = vestings [ _beneficiary ] ; require ( vesting . status == vesting status . nonexistent ) ; vesting . start = _start ; vesting . cliff = _cliff ; vesting . duration = _duration ; vesting . total amount = _amount ; vesting . released amount = NUM_ ; vesting . status = vesting status . active ; emit mint ( _beneficiary , _start , _cliff , _duration , _amount ) ; return BOOL_ ;"}
{"comment": "public payable function to buy tokens during sale or emission .", "function": "function buy tokens ( address _beneficiary ) public payable { require ( started ) ; require ( ! finished ) ; require ( _beneficiary != address ( NUM_ ) ) ; require ( msg . value != NUM_ ) ; require ( whitelist [ msg . sender ] && whitelist [ _beneficiary ] ) ; require ( fida token . total supply ( ) < NUM_ * NUM_ * * NUM_ * NUM_ * * decimals ) ; uint256 amount tokens = get amount fida ( msg . value ) ; require ( amount tokens >= NUM_ * NUM_ * * decimals ) ; if ( ! earlybird ended ) { _invest as earlybird ( _beneficiary , amount tokens ) ; } else { _invest as bonus program ( _beneficiary , amount tokens ) ; } wallet . transfer ( msg . value ) ; }", "signature": "function buy tokens ( address _beneficiary ) public payable", "body": "require ( started ) ; require ( ! finished ) ; require ( _beneficiary != address ( NUM_ ) ) ; require ( msg . value != NUM_ ) ; require ( whitelist [ msg . sender ] && whitelist [ _beneficiary ] ) ; require ( fida token . total supply ( ) < NUM_ * NUM_ * * NUM_ * NUM_ * * decimals ) ; uint256 amount tokens = get amount fida ( msg . value ) ; require ( amount tokens >= NUM_ * NUM_ * * decimals ) ; if ( ! earlybird ended ) { _invest as earlybird ( _beneficiary , amount tokens ) ; } else { _invest as bonus program ( _beneficiary , amount tokens ) ; } wallet . transfer ( msg . value ) ;"}
{"comment": "emission to definit 1 address .", "function": "function token emission ( address _reciever , uint256 _amount ) external is manager or owner is emission on returns ( bool return val ) { require ( _reciever != address ( NUM_ ) ) ; return val = _emission ( _reciever , _amount ) ; }", "signature": "function token emission ( address _reciever , uint256 _amount ) external is manager or owner is emission on returns ( bool return val )", "body": "require ( _reciever != address ( NUM_ ) ) ; return val = _emission ( _reciever , _amount ) ;"}
{"comment": "set name for msg . sender .", "function": "function set service name ( bytes32 _namespace , string memory _name ) public payable { require ( msg . value >= fee ) ; _set name ( _namespace , _name ) ; if ( msg . value > fee ) { msg . sender . transfer ( msg . value - fee ) ; } }", "signature": "function set service name ( bytes32 _namespace , string memory _name ) public payable", "body": "require ( msg . value >= fee ) ; _set name ( _namespace , _name ) ; if ( msg . value > fee ) { msg . sender . transfer ( msg . value - fee ) ; }"}
{"comment": "erc998erc721 top down composable .", "function": "function remove child ( uint256 _from token id , address _child contract , uint256 _child token id ) private { uint256 last token index = child tokens [ _from token id ] [ _child contract ] . length - NUM_ ; uint256 last token = child tokens [ _from token id ] [ _child contract ] [ last token index ] ; if ( _child token id != last token ) { uint256 token index = child token index [ _from token id ] [ _child contract ] [ _child token id ] ; child tokens [ _from token id ] [ _child contract ] [ token index ] = last token ; child token index [ _from token id ] [ _child contract ] [ last token ] = token index ; } child tokens [ _from token id ] [ _child contract ] . length -- ; delete child token index [ _from token id ] [ _child contract ] [ _child token id ] ; delete child token owner [ _child contract ] [ _child token id ] ; if ( last token index == NUM_ ) { uint256 last contract index = child contracts [ _from token id ] . length - NUM_ ; address last contract = child contracts [ _from token id ] [ last contract index ] ; if ( _child contract != last contract ) { uint256 contract index = child contract index [ _from token id ] [ _child contract ] ; child contracts [ _from token id ] [ contract index ] = last contract ; child contract index [ _from token id ] [ last contract ] = contract index ; } child contracts [ _from token id ] . length -- ; delete child contract index [ _from token id ] [ _child contract ] ; } }", "signature": "function remove child ( uint256 _from token id , address _child contract , uint256 _child token id ) private", "body": "uint256 last token index = child tokens [ _from token id ] [ _child contract ] . length - NUM_ ; uint256 last token = child tokens [ _from token id ] [ _child contract ] [ last token index ] ; if ( _child token id != last token ) { uint256 token index = child token index [ _from token id ] [ _child contract ] [ _child token id ] ; child tokens [ _from token id ] [ _child contract ] [ token index ] = last token ; child token index [ _from token id ] [ _child contract ] [ last token ] = token index ; } child tokens [ _from token id ] [ _child contract ] . length -- ; delete child token index [ _from token id ] [ _child contract ] [ _child token id ] ; delete child token owner [ _child contract ] [ _child token id ] ; if ( last token index == NUM_ ) { uint256 last contract index = child contracts [ _from token id ] . length - NUM_ ; address last contract = child contracts [ _from token id ] [ last contract index ] ; if ( _child contract != last contract ) { uint256 contract index = child contract index [ _from token id ] [ _child contract ] ; child contracts [ _from token id ] [ contract index ] = last contract ; child contract index [ _from token id ] [ last contract ] = contract index ; } child contracts [ _from token id ] . length -- ; delete child contract index [ _from token id ] [ _child contract ] ; }"}
{"comment": "adds a new stock to the game .", "function": "function add stock ( string _name , uint256 _initial price , uint256 _price increase , uint256 _dividend amount , uint8 _num shares ) public only owner returns ( uint256 stock id ) { stock id = stocks . length ; stocks . push ( stock ( _name , _price increase == NUM_ ? NUM_ : _price increase , _dividend amount == NUM_ ? NUM_ : _dividend amount , block . timestamp , NUM_ ) ) ; for ( uint8 i = NUM_ ; i < _num shares ; i ++ ) { stock shares [ stock id ] . push ( shares . length ) ; shares . push ( share ( owner , _initial price ) ) ; } company listed ( _name , _initial price ) ; }", "signature": "function add stock ( string _name , uint256 _initial price , uint256 _price increase , uint256 _dividend amount , uint8 _num shares ) public only owner returns ( uint256 stock id )", "body": "stock id = stocks . length ; stocks . push ( stock ( _name , _price increase == NUM_ ? NUM_ : _price increase , _dividend amount == NUM_ ? NUM_ : _dividend amount , block . timestamp , NUM_ ) ) ; for ( uint8 i = NUM_ ; i < _num shares ; i ++ ) { stock shares [ stock id ] . push ( shares . length ) ; shares . push ( share ( owner , _initial price ) ) ; } company listed ( _name , _initial price ) ;"}
{"comment": "allows the owner to propose the burn of tokens .", "function": "function propose burning ( uint256 _tokenamount ) external only owner returns ( bool ) { require ( _tokenamount > NUM_ ) ; proposed burn amnt = _tokenamount ; return BOOL_ ; }", "signature": "function propose burning ( uint256 _tokenamount ) external only owner returns ( bool )", "body": "require ( _tokenamount > NUM_ ) ; proposed burn amnt = _tokenamount ; return BOOL_ ;"}
{"comment": "returns true if transactee have already prove their address ownership to transactor in the past .", "function": "function verify ( address transactor , address transactee ) returns ( bool ) { return _verifications [ transactor ] [ transactee ] != NUM_ ; }", "signature": "function verify ( address transactor , address transactee ) returns ( bool )", "body": "return _verifications [ transactor ] [ transactee ] != NUM_ ;"}
{"comment": "check only in emergency .", "function": "modifier is emergency ( ) { if ( ! emergency ) throw ; _ ; }", "signature": "modifier is emergency ( )", "body": "if ( ! emergency ) throw ; _ ;"}
{"comment": "allows anyone to execute a confirmed transaction or ether withdraws until daily limit be reach .", "function": "function execute transaction ( uint transaction id ) public owner exists ( msg . sender ) confirmed ( transaction id , msg . sender ) not executed ( transaction id ) { transaction tx = transactions [ transaction id ] ; bool _confirmed = is confirmed ( transaction id ) ; if ( _confirmed || tx . data . length == NUM_ && is under limit ( tx . value ) ) { tx . executed = BOOL_ ; if ( ! _confirmed ) spent today += tx . value ; if ( tx . destination . call . value ( tx . value ) ( tx . data ) ) execution ( transaction id ) ; else { execution failure ( transaction id ) ; tx . executed = BOOL_ ; if ( ! _confirmed ) spent today -= tx . value ; } } }", "signature": "function execute transaction ( uint transaction id ) public owner exists ( msg . sender ) confirmed ( transaction id , msg . sender ) not executed ( transaction id )", "body": "transaction tx = transactions [ transaction id ] ; bool _confirmed = is confirmed ( transaction id ) ; if ( _confirmed || tx . data . length == NUM_ && is under limit ( tx . value ) ) { tx . executed = BOOL_ ; if ( ! _confirmed ) spent today += tx . value ; if ( tx . destination . call . value ( tx . value ) ( tx . data ) ) execution ( transaction id ) ; else { execution failure ( transaction id ) ; tx . executed = BOOL_ ; if ( ! _confirmed ) spent today -= tx . value ; } }"}
{"comment": "reverts if not operational .", "function": "modifier is operational ( ) { require ( operational ) ; _ ; }", "signature": "modifier is operational ( )", "body": "require ( operational ) ; _ ;"}
{"comment": "low level token purchase * * * do not override .", "function": "function buy tokens ( address _beneficiary ) public payable { uint256 wei amount = msg . value ; _pre validate purchase ( _beneficiary , wei amount ) ; uint256 tokens = _get token amount ( wei amount ) ; wei raised = wei raised . add ( wei amount ) ; _process purchase ( _beneficiary , tokens ) ; emit token purchase ( msg . sender , _beneficiary , wei amount , tokens ) ; _update purchasing state ( _beneficiary , wei amount ) ; _forward funds ( ) ; _post validate purchase ( _beneficiary , wei amount ) ; }", "signature": "function buy tokens ( address _beneficiary ) public payable", "body": "uint256 wei amount = msg . value ; _pre validate purchase ( _beneficiary , wei amount ) ; uint256 tokens = _get token amount ( wei amount ) ; wei raised = wei raised . add ( wei amount ) ; _process purchase ( _beneficiary , tokens ) ; emit token purchase ( msg . sender , _beneficiary , wei amount , tokens ) ; _update purchasing state ( _beneficiary , wei amount ) ; _forward funds ( ) ; _post validate purchase ( _beneficiary , wei amount ) ;"}
{"comment": "modifier to ensure only the contractor can execute .", "function": "modifier only contractor ( address _contractor ) { require ( msg . sender == _contractor ) ; _ ; }", "signature": "modifier only contractor ( address _contractor )", "body": "require ( msg . sender == _contractor ) ; _ ;"}
{"comment": "internal function to create a request .", "function": "function create request ( address _payer , address [ ] _payees , address [ ] _payees payment address , int256 [ ] _expected amounts , address _payer refund address , string _data ) internal returns ( bytes32 request id , uint256 fees ) { int256 total expected amounts = NUM_ ; for ( uint8 i = NUM_ ; i < _expected amounts . length ; i = i . add ( NUM_ ) ) { require ( _expected amounts [ i ] >= NUM_ ) ; total expected amounts = total expected amounts . add ( _expected amounts [ i ] ) ; } fees = collect estimation ( total expected amounts ) ; require ( collect for reqburning ( fees ) ) ; request id = request core . create request ( msg . sender , _payees , _expected amounts , _payer , _data ) ; for ( uint8 j = NUM_ ; j < _payees payment address . length ; j = j . add ( NUM_ ) ) { payees payment address [ request id ] [ j ] = _payees payment address [ j ] ; } if ( _payer refund address != NUM_ ) { payer refund address [ request id ] = _payer refund address ; } }", "signature": "function create request ( address _payer , address [ ] _payees , address [ ] _payees payment address , int256 [ ] _expected amounts , address _payer refund address , string _data ) internal returns ( bytes32 request id , uint256 fees )", "body": "int256 total expected amounts = NUM_ ; for ( uint8 i = NUM_ ; i < _expected amounts . length ; i = i . add ( NUM_ ) ) { require ( _expected amounts [ i ] >= NUM_ ) ; total expected amounts = total expected amounts . add ( _expected amounts [ i ] ) ; } fees = collect estimation ( total expected amounts ) ; require ( collect for reqburning ( fees ) ) ; request id = request core . create request ( msg . sender , _payees , _expected amounts , _payer , _data ) ; for ( uint8 j = NUM_ ; j < _payees payment address . length ; j = j . add ( NUM_ ) ) { payees payment address [ request id ] [ j ] = _payees payment address [ j ] ; } if ( _payer refund address != NUM_ ) { payer refund address [ request id ] = _payer refund address ; }"}
{"comment": "the name of the token .", "function": "function name ( ) public pure returns ( string ) { return STR_ ; }", "signature": "function name ( ) public pure returns ( string )", "body": "return STR_ ;"}
{"comment": "disable token transfer .", "function": "function freeze ( ) external manager only { rcd . pause ( ) ; }", "signature": "function freeze ( ) external manager only", "body": "rcd . pause ( ) ;"}
{"comment": "unlock the tokens .", "function": "function unlock ( ) external only owner { is locked = BOOL_ ; }", "signature": "function unlock ( ) external only owner", "body": "is locked = BOOL_ ;"}
{"comment": "low-level function for tokens transfer .", "function": "function send tokens ( address _to , uint tokens ) private { balances [ token wallet ] = balances [ token wallet ] . sub ( tokens ) ; balances [ _to ] += tokens ; transfer ( token wallet , _to , tokens ) ; multi sig . transfer ( msg . value ) ; }", "signature": "function send tokens ( address _to , uint tokens ) private", "body": "balances [ token wallet ] = balances [ token wallet ] . sub ( tokens ) ; balances [ _to ] += tokens ; transfer ( token wallet , _to , tokens ) ; multi sig . transfer ( msg . value ) ;"}
{"comment": "transfer tokens from one address to another .", "function": "function transfer from ( address _from , address _to , uint256 _value ) public returns ( bool ) { require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ _from ] ) ; require ( _value <= allowed [ _from ] [ msg . sender ] ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; transfer ( _from , _to , _value ) ; return BOOL_ ; }", "signature": "function transfer from ( address _from , address _to , uint256 _value ) public returns ( bool )", "body": "require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ _from ] ) ; require ( _value <= allowed [ _from ] [ msg . sender ] ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; transfer ( _from , _to , _value ) ; return BOOL_ ;"}
{"comment": "function for withdraw eth by the owner .", "function": "function owner withdrawal ( uint256 amt ) public only owner { require ( ( amt . add ( owner withdrawn ) ) <= ( wei raised . div ( NUM_ ) ) . mul ( NUM_ ) ) ; if ( owner . send ( amt ) ) { owner withdrawn = owner withdrawn . add ( amt ) ; fund transfer ( owner , amt ) ; } }", "signature": "function owner withdrawal ( uint256 amt ) public only owner", "body": "require ( ( amt . add ( owner withdrawn ) ) <= ( wei raised . div ( NUM_ ) ) . mul ( NUM_ ) ) ; if ( owner . send ( amt ) ) { owner withdrawn = owner withdrawn . add ( amt ) ; fund transfer ( owner , amt ) ; }"}
{"comment": "get the token balance for account tokenowner .", "function": "function balance of ( address token owner ) public constant returns ( uint balance ) { return balances [ token owner ] ; }", "signature": "function balance of ( address token owner ) public constant returns ( uint balance )", "body": "return balances [ token owner ] ;"}
{"comment": "delivery token for buyer .", "function": "function delivery token ( uint a , uint b ) public only owner valid original buy price valid range ( a , b ) { uint256 sum = NUM_ ; require ( balances [ owner ] >= _ico supply ) ; for ( uint i = a ; i <= b ; i ++ ) { if ( approved investor list [ buyers [ i ] ] ) { uint256 requested units = ( deposit [ buyers [ i ] ] * _original buy price ) / NUM_ * * NUM_ ; if ( requested units <= _ico supply && requested units > NUM_ ) { balances [ owner ] -= requested units ; balances [ buyers [ i ] ] += requested units ; _ico supply -= requested units ; transfer ( owner , buyers [ i ] , requested units ) ; sum += deposit [ buyers [ i ] ] ; deposit [ buyers [ i ] ] = NUM_ ; } } } owner . transfer ( sum ) ; }", "signature": "function delivery token ( uint a , uint b ) public only owner valid original buy price valid range ( a , b )", "body": "uint256 sum = NUM_ ; require ( balances [ owner ] >= _ico supply ) ; for ( uint i = a ; i <= b ; i ++ ) { if ( approved investor list [ buyers [ i ] ] ) { uint256 requested units = ( deposit [ buyers [ i ] ] * _original buy price ) / NUM_ * * NUM_ ; if ( requested units <= _ico supply && requested units > NUM_ ) { balances [ owner ] -= requested units ; balances [ buyers [ i ] ] += requested units ; _ico supply -= requested units ; transfer ( owner , buyers [ i ] , requested units ) ; sum += deposit [ buyers [ i ] ] ; deposit [ buyers [ i ] ] = NUM_ ; } } } owner . transfer ( sum ) ;"}
{"comment": "only builder owner methods .", "function": "function change enabled address status ( address _address , bool _status ) only owner public { require ( _address != address ( NUM_ ) ) ; enabled addresses [ _address ] = _status ; }", "signature": "function change enabled address status ( address _address , bool _status ) only owner public", "body": "require ( _address != address ( NUM_ ) ) ; enabled addresses [ _address ] = _status ;"}
{"comment": "use this to reset everything , will never be call after lockrelease .", "function": "function apply settings ( setting state value q state , uint _threshold , uint _rw , uint _opt xfer gas , uint _opt fcn gas ) { if ( msg . sender != owner ) return ; payout threshold = _threshold ; rw gas = _rw ; opt in xfer gas = _opt xfer gas ; opt in fcn min gas = _opt fcn gas ; if ( settings state == setting state value . locked release ) return ; settings state = q state ; if ( q state == setting state value . locked release ) { stat event ( STR_ ) ; return ; } for ( uint i = NUM_ ; i < num accounts ; i ++ ) { address a = holder indexes [ i ] ; if ( a != address ( NUM_ ) ) { holder accounts [ a ] . tokens = NUM_ ; holder accounts [ a ] . current points = NUM_ ; holder accounts [ a ] . last snapshot = NUM_ ; } } num toks switched over = NUM_ ; if ( this . balance > NUM_ ) { if ( ! owner . call . gas ( rw gas ) . value ( this . balance ) ( ) ) stat event ( STR_ ) ; } stat event ( STR_ ) ; }", "signature": "function apply settings ( setting state value q state , uint _threshold , uint _rw , uint _opt xfer gas , uint _opt fcn gas )", "body": "if ( msg . sender != owner ) return ; payout threshold = _threshold ; rw gas = _rw ; opt in xfer gas = _opt xfer gas ; opt in fcn min gas = _opt fcn gas ; if ( settings state == setting state value . locked release ) return ; settings state = q state ; if ( q state == setting state value . locked release ) { stat event ( STR_ ) ; return ; } for ( uint i = NUM_ ; i < num accounts ; i ++ ) { address a = holder indexes [ i ] ; if ( a != address ( NUM_ ) ) { holder accounts [ a ] . tokens = NUM_ ; holder accounts [ a ] . current points = NUM_ ; holder accounts [ a ] . last snapshot = NUM_ ; } } num toks switched over = NUM_ ; if ( this . balance > NUM_ ) { if ( ! owner . call . gas ( rw gas ) . value ( this . balance ) ( ) ) stat event ( STR_ ) ; } stat event ( STR_ ) ;"}
{"comment": "removes an auction from the list of open auction .", "function": "function _remove auction ( uint256 _axie id ) internal { delete auctions [ _axie id ] ; }", "signature": "function _remove auction ( uint256 _axie id ) internal", "body": "delete auctions [ _axie id ] ;"}
{"comment": "make safetrasferfrom ( ) pausable .", "function": "function safe transfer from ( address _from , address _to , uint256 _token id ) public when not paused can pay fees ( transfer fee ) { return super . safe transfer from ( _from , _to , _token id ) ; }", "signature": "function safe transfer from ( address _from , address _to , uint256 _token id ) public when not paused can pay fees ( transfer fee )", "body": "return super . safe transfer from ( _from , _to , _token id ) ;"}
{"comment": "function to stop burn tokens .", "function": "function finish burning ( ) only owner public returns ( bool ) { burn finished = BOOL_ ; emit burn finished ( ) ; return BOOL_ ; }", "signature": "function finish burning ( ) only owner public returns ( bool )", "body": "burn finished = BOOL_ ; emit burn finished ( ) ; return BOOL_ ;"}
{"comment": "withdraw dth when shop delete .", "function": "function withdraw dth shop ( address _receiver ) external only owner { require ( dth shop balance [ _receiver ] > NUM_ ) ; uint tosend = dth shop balance [ _receiver ] ; dth shop balance [ _receiver ] = NUM_ ; require ( dth . transfer ( _receiver , tosend ) ) ; }", "signature": "function withdraw dth shop ( address _receiver ) external only owner", "body": "require ( dth shop balance [ _receiver ] > NUM_ ) ; uint tosend = dth shop balance [ _receiver ] ; dth shop balance [ _receiver ] = NUM_ ; require ( dth . transfer ( _receiver , tosend ) ) ;"}
{"comment": "modifier to check if payments be accept .", "function": "modifier accepting payments ( ) { require ( is accepting payments ) ; _ ; }", "signature": "modifier accepting payments ( )", "body": "require ( is accepting payments ) ; _ ;"}
{"comment": "allow / deny transfer of tokens .", "function": "function transaction switch ( bool _transactions active ) external only owner { transactions active = _transactions active ; }", "signature": "function transaction switch ( bool _transactions active ) external only owner", "body": "transactions active = _transactions active ;"}
{"comment": "approves and then call the receive contract .", "function": "function approve and call ( address _spender , uint256 _value , bytes _extra data ) returns ( bool success ) { allowed [ msg . sender ] [ _spender ] = _value ; approval ( msg . sender , _spender , _value ) ; if ( ! _spender . call ( bytes4 ( bytes32 ( sha3 ( STR_ ) ) ) , msg . sender , _value , this , _extra data ) ) { throw ; } return BOOL_ ; }", "signature": "function approve and call ( address _spender , uint256 _value , bytes _extra data ) returns ( bool success )", "body": "allowed [ msg . sender ] [ _spender ] = _value ; approval ( msg . sender , _spender , _value ) ; if ( ! _spender . call ( bytes4 ( bytes32 ( sha3 ( STR_ ) ) ) , msg . sender , _value , this , _extra data ) ) { throw ; } return BOOL_ ;"}
{"comment": "this method must never be call by smart contract code .", "function": "function tokens of owner ( address _owner ) external view returns ( uint256 [ ] owner tokens ) { uint256 token count = balance of ( _owner ) ; if ( token count == NUM_ ) { return new uint256 [ ] ( NUM_ ) ; } else { uint256 [ ] memory result = new uint256 [ ] ( token count ) ; uint256 total items = balance of ( _owner ) ; uint256 result index = NUM_ ; uint256 _asset id ; for ( _asset id = NUM_ ; _asset id < total items ; _asset id ++ ) { result [ result index ] = token of owner by index ( _owner , _asset id ) ; result index ++ ; } return result ; } }", "signature": "function tokens of owner ( address _owner ) external view returns ( uint256 [ ] owner tokens )", "body": "uint256 token count = balance of ( _owner ) ; if ( token count == NUM_ ) { return new uint256 [ ] ( NUM_ ) ; } else { uint256 [ ] memory result = new uint256 [ ] ( token count ) ; uint256 total items = balance of ( _owner ) ; uint256 result index = NUM_ ; uint256 _asset id ; for ( _asset id = NUM_ ; _asset id < total items ; _asset id ++ ) { result [ result index ] = token of owner by index ( _owner , _asset id ) ; result index ++ ; } return result ; }"}
{"comment": "this method must never be call by smart contract code .", "function": "function tokens of owner ( address _owner ) external view returns ( uint256 [ ] owner tokens ) { uint256 token count = balance of ( _owner ) ; if ( token count == NUM_ ) { return new uint256 [ ] ( NUM_ ) ; } else { uint256 [ ] memory result = new uint256 [ ] ( token count ) ; uint256 total items = balance of ( _owner ) ; uint256 result index = NUM_ ; uint256 _asset id ; for ( _asset id = NUM_ ; _asset id < total items ; _asset id ++ ) { result [ result index ] = token of owner by index ( _owner , _asset id ) ; result index ++ ; } return result ; } }", "signature": "function tokens of owner ( address _owner ) external view returns ( uint256 [ ] owner tokens )", "body": "uint256 token count = balance of ( _owner ) ; if ( token count == NUM_ ) { return new uint256 [ ] ( NUM_ ) ; } else { uint256 [ ] memory result = new uint256 [ ] ( token count ) ; uint256 total items = balance of ( _owner ) ; uint256 result index = NUM_ ; uint256 _asset id ; for ( _asset id = NUM_ ; _asset id < total items ; _asset id ++ ) { result [ result index ] = token of owner by index ( _owner , _asset id ) ; result index ++ ; } return result ; }"}
{"comment": "unlock a yticon and make it usable .", "function": "function unlock ( uint256 token id ) public owner only { require ( _cards [ token id ] . is locked ) ; _cards [ token id ] . is locked = BOOL_ ; }", "signature": "function unlock ( uint256 token id ) public owner only", "body": "require ( _cards [ token id ] . is locked ) ; _cards [ token id ] . is locked = BOOL_ ;"}
{"comment": "removes presale account address from privatesalewhitelist .", "function": "function remove from private sale whitelist ( address [ ] _bidder_addresses ) public is owner { for ( uint32 i = NUM_ ; i < _bidder_addresses . length ; i ++ ) { privatesalewhitelist [ _bidder_addresses [ i ] ] = BOOL_ ; removed from private sale whitelist ( _bidder_addresses [ i ] ) ; } }", "signature": "function remove from private sale whitelist ( address [ ] _bidder_addresses ) public is owner", "body": "for ( uint32 i = NUM_ ; i < _bidder_addresses . length ; i ++ ) { privatesalewhitelist [ _bidder_addresses [ i ] ] = BOOL_ ; removed from private sale whitelist ( _bidder_addresses [ i ] ) ; }"}
{"comment": "given an amount in ttc , this method return the equivalent amount in mini-ttc .", "function": "function convert to mini ttc ( uint amount ) internal constant returns ( uint ) { return amount * ( NUM_ * * uint ( token reward . decimals ( ) ) ) ; }", "signature": "function convert to mini ttc ( uint amount ) internal constant returns ( uint )", "body": "return amount * ( NUM_ * * uint ( token reward . decimals ( ) ) ) ;"}
{"comment": "claim a day for your very own ! .", "function": "function claim day ( uint256 _day index ) public non reentrant when not paused payable { require ( msg . sender != address ( NUM_ ) ) ; require ( _day index >= NUM_ && _day index < NUM_ ) ; address buyer = msg . sender ; address seller = token owner [ _day index ] ; require ( msg . sender != seller ) ; uint256 amount paid = msg . value ; uint256 purchase price = day index to price [ _day index ] ; if ( purchase price == NUM_ ) { purchase price = NUM_ finney ; } require ( amount paid >= purchase price ) ; uint256 change to return = NUM_ ; if ( amount paid > purchase price ) { change to return = amount paid . sub ( purchase price ) ; amount paid -= change to return ; } uint256 price increase = calculate price increase ( purchase price ) ; uint256 new purchase price = purchase price . add ( price increase ) ; day index to price [ _day index ] = new purchase price ; uint256 owner cut = calculate owner cut ( amount paid ) ; uint256 sale price = amount paid . sub ( owner cut ) ; bought ( _day index , buyer , purchase price ) ; sold ( _day index , seller , purchase price ) ; if ( seller == address ( NUM_ ) ) { _mint ( buyer , _day index ) ; } else { clear approval and transfer ( seller , buyer , _day index ) ; } if ( seller != address ( NUM_ ) ) { seller . transfer ( sale price ) ; } if ( change to return > NUM_ ) { buyer . transfer ( change to return ) ; } }", "signature": "function claim day ( uint256 _day index ) public non reentrant when not paused payable", "body": "require ( msg . sender != address ( NUM_ ) ) ; require ( _day index >= NUM_ && _day index < NUM_ ) ; address buyer = msg . sender ; address seller = token owner [ _day index ] ; require ( msg . sender != seller ) ; uint256 amount paid = msg . value ; uint256 purchase price = day index to price [ _day index ] ; if ( purchase price == NUM_ ) { purchase price = NUM_ finney ; } require ( amount paid >= purchase price ) ; uint256 change to return = NUM_ ; if ( amount paid > purchase price ) { change to return = amount paid . sub ( purchase price ) ; amount paid -= change to return ; } uint256 price increase = calculate price increase ( purchase price ) ; uint256 new purchase price = purchase price . add ( price increase ) ; day index to price [ _day index ] = new purchase price ; uint256 owner cut = calculate owner cut ( amount paid ) ; uint256 sale price = amount paid . sub ( owner cut ) ; bought ( _day index , buyer , purchase price ) ; sold ( _day index , seller , purchase price ) ; if ( seller == address ( NUM_ ) ) { _mint ( buyer , _day index ) ; } else { clear approval and transfer ( seller , buyer , _day index ) ; } if ( seller != address ( NUM_ ) ) { seller . transfer ( sale price ) ; } if ( change to return > NUM_ ) { buyer . transfer ( change to return ) ; }"}
{"comment": "get the time-based bonus rate .", "function": "function get timebased bonus rate ( ) internal constant returns ( uint256 ) { uint256 bonus rate = NUM_ ; if ( state == state . presale ) { bonus rate = NUM_ ; } else { uint256 now time = get now ( ) ; uint256 bonus first week = start time + ( NUM_ days * NUM_ ) ; uint256 bonus second week = bonus first week + ( NUM_ days * NUM_ ) ; uint256 bonus third week = bonus second week + ( NUM_ days * NUM_ ) ; uint256 bonus fourth week = bonus third week + ( NUM_ days * NUM_ ) ; if ( now time <= bonus first week ) { bonus rate = NUM_ ; } else if ( now time <= bonus second week ) { bonus rate = NUM_ ; } else if ( now time <= bonus third week ) { bonus rate = NUM_ ; } else if ( now time <= bonus fourth week ) { bonus rate = NUM_ ; } } return bonus rate ; }", "signature": "function get timebased bonus rate ( ) internal constant returns ( uint256 )", "body": "uint256 bonus rate = NUM_ ; if ( state == state . presale ) { bonus rate = NUM_ ; } else { uint256 now time = get now ( ) ; uint256 bonus first week = start time + ( NUM_ days * NUM_ ) ; uint256 bonus second week = bonus first week + ( NUM_ days * NUM_ ) ; uint256 bonus third week = bonus second week + ( NUM_ days * NUM_ ) ; uint256 bonus fourth week = bonus third week + ( NUM_ days * NUM_ ) ; if ( now time <= bonus first week ) { bonus rate = NUM_ ; } else if ( now time <= bonus second week ) { bonus rate = NUM_ ; } else if ( now time <= bonus third week ) { bonus rate = NUM_ ; } else if ( now time <= bonus fourth week ) { bonus rate = NUM_ ; } } return bonus rate ;"}
{"comment": "number of decimals for this token .", "function": "function decimals ( ) public pure returns ( uint8 result ) { return NUM_ ; }", "signature": "function decimals ( ) public pure returns ( uint8 result )", "body": "return NUM_ ;"}
{"comment": "call by the owner to pause , trigger stop state .", "function": "function pause ( ) public only owner when not paused { paused = BOOL_ ; emit pause ( ) ; }", "signature": "function pause ( ) public only owner when not paused", "body": "paused = BOOL_ ; emit pause ( ) ;"}
{"comment": "send _value tokens to _to from _from on the condition it be approve by _from .", "function": "function transfer from ( address _from , address _to , uint256 _value ) public can transfer release token valid ( msg . sender , now , _value ) returns ( bool success ) { require ( balances [ _from ] >= _value ) ; require ( balances [ _to ] + _value >= balances [ _to ] ) ; require ( _value <= allowances [ _from ] [ msg . sender ] ) ; balances [ _from ] -= _value ; balances [ _to ] += _value ; allowances [ _from ] [ msg . sender ] -= _value ; emit transfer ( _from , _to , _value ) ; return BOOL_ ; }", "signature": "function transfer from ( address _from , address _to , uint256 _value ) public can transfer release token valid ( msg . sender , now , _value ) returns ( bool success )", "body": "require ( balances [ _from ] >= _value ) ; require ( balances [ _to ] + _value >= balances [ _to ] ) ; require ( _value <= allowances [ _from ] [ msg . sender ] ) ; balances [ _from ] -= _value ; balances [ _to ] += _value ; allowances [ _from ] [ msg . sender ] -= _value ; emit transfer ( _from , _to , _value ) ; return BOOL_ ;"}
{"comment": "allows a user to place bet on the match .", "function": "function place bet ( uint index ) public payable { require ( msg . value >= minimum bet amount ) ; require ( ! stop match betting ) ; require ( ! match completed ) ; if ( teams [ NUM_ ] . betting contribution [ msg . sender ] == NUM_ && teams [ NUM_ ] . betting contribution [ msg . sender ] == NUM_ ) { betters . push ( msg . sender ) ; } if ( teams [ index ] . betting contribution [ msg . sender ] == NUM_ ) { teams [ index ] . total participants = teams [ index ] . total participants . add ( NUM_ ) ; } teams [ index ] . betting contribution [ msg . sender ] = teams [ index ] . betting contribution [ msg . sender ] . add ( msg . value ) ; teams [ index ] . ledger betting contribution [ msg . sender ] = teams [ index ] . ledger betting contribution [ msg . sender ] . add ( msg . value ) ; teams [ index ] . total amount = teams [ index ] . total amount . add ( msg . value ) ; }", "signature": "function place bet ( uint index ) public payable", "body": "require ( msg . value >= minimum bet amount ) ; require ( ! stop match betting ) ; require ( ! match completed ) ; if ( teams [ NUM_ ] . betting contribution [ msg . sender ] == NUM_ && teams [ NUM_ ] . betting contribution [ msg . sender ] == NUM_ ) { betters . push ( msg . sender ) ; } if ( teams [ index ] . betting contribution [ msg . sender ] == NUM_ ) { teams [ index ] . total participants = teams [ index ] . total participants . add ( NUM_ ) ; } teams [ index ] . betting contribution [ msg . sender ] = teams [ index ] . betting contribution [ msg . sender ] . add ( msg . value ) ; teams [ index ] . ledger betting contribution [ msg . sender ] = teams [ index ] . ledger betting contribution [ msg . sender ] . add ( msg . value ) ; teams [ index ] . total amount = teams [ index ] . total amount . add ( msg . value ) ;"}
{"comment": "total number of tokens in existence .", "function": "function total supply ( ) public view returns ( uint256 ) { return total supply_ ; }", "signature": "function total supply ( ) public view returns ( uint256 )", "body": "return total supply_ ;"}
{"comment": "approve the passed address to spend the specified amount of tokens on behalf of msg . sender .", "function": "function approve ( address _spender , uint256 _value ) public returns ( bool ) { allowed [ msg . sender ] [ _spender ] = _value ; approval ( msg . sender , _spender , _value ) ; return BOOL_ ; }", "signature": "function approve ( address _spender , uint256 _value ) public returns ( bool )", "body": "allowed [ msg . sender ] [ _spender ] = _value ; approval ( msg . sender , _spender , _value ) ; return BOOL_ ;"}
{"comment": "calculate point win by yellow and red card predictions .", "function": "function get extra points ( uint32 extras ) internal view returns ( uint16 extra points ) { uint16 red cards = uint16 ( extras & extra_mask_brackets ) ; extras = extras > > NUM_ ; uint16 yellow cards = uint16 ( extras ) ; if ( red cards == extra results . red cards ) { extra points += NUM_ ; } if ( yellow cards == extra results . yellow cards ) { extra points += NUM_ ; } }", "signature": "function get extra points ( uint32 extras ) internal view returns ( uint16 extra points )", "body": "uint16 red cards = uint16 ( extras & extra_mask_brackets ) ; extras = extras > > NUM_ ; uint16 yellow cards = uint16 ( extras ) ; if ( red cards == extra results . red cards ) { extra points += NUM_ ; } if ( yellow cards == extra results . yellow cards ) { extra points += NUM_ ; }"}
{"comment": "withdraw from the reward pot .", "function": "function withdraw ( ) external only whitelisted { msg . sender . transfer ( balance_ ) ; emit withdrawn ( msg . sender , balance_ ) ; balance_ = NUM_ ; }", "signature": "function withdraw ( ) external only whitelisted", "body": "msg . sender . transfer ( balance_ ) ; emit withdrawn ( msg . sender , balance_ ) ; balance_ = NUM_ ;"}
{"comment": "finalize presale , calculate token price , track finalize time .", "function": "function finalize presale ( ) when not paused only owner external { require ( is presale started && ! is presale finalized ) ; require ( presale finalize agent . is sane ( ) ) ; uint256 presale supply = token . total supply ( ) ; presale supply = presale supply . div ( NUM_ ) ; presale finalize agent . finalize presale ( presale supply ) ; uint token wei = presale finalize agent . wei per token ( ) ; pricing strategy . set token price in wei ( token wei ) ; tokens per wei received ( token wei ) ; require ( token wei > NUM_ ) ; current status = status . unknown ; is presale finalized = BOOL_ ; presale end time = now ; presale finalized ( presale end time ) ; }", "signature": "function finalize presale ( ) when not paused only owner external", "body": "require ( is presale started && ! is presale finalized ) ; require ( presale finalize agent . is sane ( ) ) ; uint256 presale supply = token . total supply ( ) ; presale supply = presale supply . div ( NUM_ ) ; presale finalize agent . finalize presale ( presale supply ) ; uint token wei = presale finalize agent . wei per token ( ) ; pricing strategy . set token price in wei ( token wei ) ; tokens per wei received ( token wei ) ; require ( token wei > NUM_ ) ; current status = status . unknown ; is presale finalized = BOOL_ ; presale end time = now ; presale finalized ( presale end time ) ;"}
{"comment": "performs payout base on win team .", "function": "function perform payout ( ) private can perform payout { uint losing chunk = safe math . sub ( this . balance , total amounts bet [ uint ( winning team ) ] ) ; uint current owner payout commission = uint256 ( safe math . div ( safe math . mul ( owner_pool_commission , losing chunk ) , NUM_ ) ) ; uint each stage commission = uint256 ( safe math . div ( safe math . mul ( NUM_ , losing chunk ) , NUM_ ) ) ; for ( uint k = NUM_ ; k < bettors . length ; k ++ ) { uint bet on winner = bettor info [ bettors [ k ] ] . amounts bet [ uint ( winning team ) ] ; uint payout = bet on winner + ( ( bet on winner * ( losing chunk - current owner payout commission - ( NUM_ * each stage commission ) ) ) / total amounts bet [ uint ( winning team ) ] ) ; if ( total amounts bet stage1 [ NUM_ ] > NUM_ ) { uint stage one commission payout team0 = ( ( bettor info [ bettors [ k ] ] . amounts bet stage1 [ NUM_ ] * each stage commission ) / total amounts bet stage1 [ NUM_ ] ) ; payout += stage one commission payout team0 ; } if ( total amounts bet stage1 [ NUM_ ] > NUM_ ) { uint stage one commission payout team1 = ( ( bettor info [ bettors [ k ] ] . amounts bet stage1 [ NUM_ ] * each stage commission ) / total amounts bet stage1 [ NUM_ ] ) ; payout += stage one commission payout team1 ; } if ( total amounts bet stage2 [ NUM_ ] > NUM_ ) { uint stage two commission payout team0 = ( ( bettor info [ bettors [ k ] ] . amounts bet stage2 [ NUM_ ] * each stage commission ) / total amounts bet stage2 [ NUM_ ] ) ; payout += stage two commission payout team0 ; } if ( total amounts bet stage2 [ NUM_ ] > NUM_ ) { uint stage two commission payout team1 = ( ( bettor info [ bettors [ k ] ] . amounts bet stage2 [ NUM_ ] * each stage commission ) / total amounts bet stage2 [ NUM_ ] ) ; payout += stage two commission payout team1 ; } if ( payout > NUM_ ) bettors [ k ] . transfer ( payout ) ; } current owner . transfer ( current owner payout commission ) ; if ( this . balance > NUM_ ) { creator . transfer ( this . balance ) ; stage2 not reached = BOOL_ ; } else { stage2 not reached = BOOL_ ; } payout completed = BOOL_ ; }", "signature": "function perform payout ( ) private can perform payout", "body": "uint losing chunk = safe math . sub ( this . balance , total amounts bet [ uint ( winning team ) ] ) ; uint current owner payout commission = uint256 ( safe math . div ( safe math . mul ( owner_pool_commission , losing chunk ) , NUM_ ) ) ; uint each stage commission = uint256 ( safe math . div ( safe math . mul ( NUM_ , losing chunk ) , NUM_ ) ) ; for ( uint k = NUM_ ; k < bettors . length ; k ++ ) { uint bet on winner = bettor info [ bettors [ k ] ] . amounts bet [ uint ( winning team ) ] ; uint payout = bet on winner + ( ( bet on winner * ( losing chunk - current owner payout commission - ( NUM_ * each stage commission ) ) ) / total amounts bet [ uint ( winning team ) ] ) ; if ( total amounts bet stage1 [ NUM_ ] > NUM_ ) { uint stage one commission payout team0 = ( ( bettor info [ bettors [ k ] ] . amounts bet stage1 [ NUM_ ] * each stage commission ) / total amounts bet stage1 [ NUM_ ] ) ; payout += stage one commission payout team0 ; } if ( total amounts bet stage1 [ NUM_ ] > NUM_ ) { uint stage one commission payout team1 = ( ( bettor info [ bettors [ k ] ] . amounts bet stage1 [ NUM_ ] * each stage commission ) / total amounts bet stage1 [ NUM_ ] ) ; payout += stage one commission payout team1 ; } if ( total amounts bet stage2 [ NUM_ ] > NUM_ ) { uint stage two commission payout team0 = ( ( bettor info [ bettors [ k ] ] . amounts bet stage2 [ NUM_ ] * each stage commission ) / total amounts bet stage2 [ NUM_ ] ) ; payout += stage two commission payout team0 ; } if ( total amounts bet stage2 [ NUM_ ] > NUM_ ) { uint stage two commission payout team1 = ( ( bettor info [ bettors [ k ] ] . amounts bet stage2 [ NUM_ ] * each stage commission ) / total amounts bet stage2 [ NUM_ ] ) ; payout += stage two commission payout team1 ; } if ( payout > NUM_ ) bettors [ k ] . transfer ( payout ) ; } current owner . transfer ( current owner payout commission ) ; if ( this . balance > NUM_ ) { creator . transfer ( this . balance ) ; stage2 not reached = BOOL_ ; } else { stage2 not reached = BOOL_ ; } payout completed = BOOL_ ;"}
